<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no" />
  <link href="assets/images/favicon.png" rel="icon" />
  <title>Dokumentacja | Projekt Specjalnościowy</title>
  <meta name="description" content="Dokumentacja na projekt specjalnościowy" />
  <meta name="author" content="Ingrid Pruszyńska 7051" />

  <!-- Stylesheet
============================== -->
  <!-- Bootstrap -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/bootstrap/css/bootstrap.min.css" />
  <!-- Font Awesome Icon -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/font-awesome/css/all.min.css" />
  <!-- Magnific Popup -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/magnific-popup/magnific-popup.min.css" />
  <!-- Highlight Syntax -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/highlight.js/styles/github.css" />
  <!-- Custom Stylesheet -->
  <link rel="stylesheet" type="text/css" href="assets/css/stylesheet.css" />
  <link rel="stylesheet" type="text/css" href="assets/css/color-orange.css" />
  <link rel="stylesheet" type="text/css" href="assets/css/custom.css" />
</head>

<body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">
  <!-- Document Wrapper   
=============================== -->
  <div id="main-wrapper">
    <!-- Header
  ============================ -->
    <header id="header" class="sticky-top">
      <!-- Navbar -->
      <nav class="primary-menu navbar navbar-expand-lg navbar-dropdown-light">
        <div class="container-fluid">
          <!-- Sidebar Toggler -->
          <button id="sidebarCollapse" class="navbar-toggler d-block d-md-none" type="button">
            <span></span><span class="w-75"></span><span class="w-50"></span>
          </button>

          <!-- Logo -->
          <a class="logo ml-md-3" href="index.html" title="Projekt specjalnosciowy">
            Projekt specjalnościowy
          </a>
          <span class="text-2 ml-2">v1.0</span>
          <!-- Logo End -->

        </div>
      </nav>
      <!-- Navbar End -->
    </header>
    <!-- Header End -->

    <!-- Content
  ============================ -->
    <div id="content" role="main">
      <!-- Sidebar Navigation
	============================ -->
      <div class="idocs-navigation bg-light navbar-dropdown-light">
        <ul class="nav flex-column">
          <!-- Podstawowe informacje -->
          <li class="nav-item">
            <a class="nav-link active" href="#idocs_start">Podstawowe informacje</a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#idocs_repozytorium">Repozytorium</a>
              </li>
              <!-- <li class="nav-item">
                <a class="nav-link" href="#idocs_wersja_live">Wersja Live</a>
              </li> -->
              <li class="nav-item">
                <a class="nav-link" href="#idocs_wykorzystane_technologie">Wykorzystane technologie</a>
              </li>

              <li class="nav-item">
                <a class="nav-link" href="#idocs_omowienie_kodu">Omówienie kodu</a>
              </li>
            </ul>
          </li>
          <!-- Analiza komponentów -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_analiza_komponentow">Analiza komponentów</a>
            <ul class="nav flex-column">
              <!-- homepage -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_homepage">homepage</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_homepage_component">
                      homepage.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_homepage_styles">
                      homepage.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_homepage_test">
                      homepage.test</a>
                  </li>
                </ul>
              </li>
              <!-- header -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_header">header</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_header_component">
                      header.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_header_styles">
                      header.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_header_test">
                      header.test</a>
                  </li>
                </ul>
              </li>
              <!-- cart-icon -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_cart_icon">cart-icon</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_icon_component">
                      cart-icon.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_icon_styles">
                      cart-icon.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_icon_test">
                      cart-icon.test</a>
                  </li>
                </ul>
              </li>
              <!-- cart-dropdown -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_cart_dropdown">cart-dropdown</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_dropdown_component">
                      cart-dropdown.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_dropdown_styles">
                      cart-dropdown.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_dropdown_test">
                      cart-dropdown.test</a>
                  </li>
                </ul>
              </li>
              <!-- cart-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_cart_item">cart-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_item_component">
                      cart-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_item_styles">
                      cart-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_item_test">
                      cart-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- menu-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_menu_item">menu-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_menu_item_component">
                      menu-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_menu_item_styles">
                      menu-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_menu_item_test">
                      menu-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- directory -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_directory">directory</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_directory_component">
                      directory.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_directory_styles">
                      directory.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_directory_test">
                      directory.test</a>
                  </li>
                </ul>
              </li>
              <!-- footer -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_footer">footer</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_footer_component">
                      footer.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_footer_styles">
                      footer.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_footer_test">
                      footer.test</a>
                  </li>
                </ul>
              </li>
              <!-- shoppage -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_shoppage">shop</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_shop_component">
                      shop.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_shop_styles">
                      shop.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_shop_test"> shop.test</a>
                  </li>
                </ul>
              </li>
              <!-- collections-overview -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collections_overview">collections-overview</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_container">
                      collections-overview.container</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_component">
                      collections-overview.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_styles">
                      collections-overview.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_test">
                      collections-overview.test</a>
                  </li>
                </ul>
              </li>
              <!-- collection-preview -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collection_preview">collection-preview</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_preview_component">
                      collection-preview.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_preview_styles">
                      collection-preview.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_preview_test">
                      collection-preview.test</a>
                  </li>
                </ul>
              </li>
              <!-- collection-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collection_item">collection-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_item_component">
                      collection-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_item_styles">
                      collection-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_item_test">
                      collection-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- custom-button -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_custom_button">custom-button</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_custom_button_component">
                      custom-button.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_custom_button_styles">
                      custom-button.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_custom_button_test">
                      custom-button.test</a>
                  </li>
                </ul>
              </li>
              <!-- with-spinner -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_with_spinner">with-spinner</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_with_spinner_component">
                      with-spinner.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_with_spinner_test">
                      with-spinner.test</a>
                  </li>
                </ul>
              </li>
              <!-- spinner -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_spinner">spinner</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_spinner_component">
                      spinner.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_spinner_styles">
                      spinner.styles</a>
                  </li>
                </ul>
              </li>
              <!-- collection -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collection">collection</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_container">
                      collection.container</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_component">
                      collection.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_styles">
                      collection.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_test">
                      collection.test</a>
                  </li>
                </ul>
              </li>
              <!-- checkout -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_checkout">checkout</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_component">
                      checkout.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_styles">
                      checkout.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_test">
                      checkout.test</a>
                  </li>
                </ul>
              </li>
              <!-- checkout-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_checkout_item">checkout-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_item_component">
                      checkout-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_item_styles">
                      checkout-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_item_test">
                      checkout-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- stripe-button -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_stripe_button">stripe-button</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_stripe_button_component">
                      stripe-button.component</a>
                  </li>
                </ul>
              </li>
              <!-- sign-in-and-sign-up-page -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown"
                  href="#idocs_sign_in_and_sign_up_page">sign-in-and-sign-up-page</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_and_sign_up_page_component">
                      sign-in-and-sign-up-page.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_and_sign_up_page_styles">
                      sign-in-and-sign-up-page.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_and_sign_up_page_test">
                      sign-in-and-sign-up-page.test</a>
                  </li>
                </ul>
              </li>
              <!-- sign-in -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_sign_in">sign-in</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_component">
                      sign-in.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_styles">
                      sign-in.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_test">
                      sign-in.test</a>
                  </li>
                </ul>
              </li>
              <!-- form-input -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_form_input">form-input</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_form_input_component">
                      form-input.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_form_input_styles">
                      form-input.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_form_input_test">
                      form-input.test</a>
                  </li>
                </ul>
              </li>
              <!-- sign-up -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_sign_up">sign-up</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_up_component">
                      sign-up.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_up_styles">
                      sign-up.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_up_test">
                      sign-up.test</a>
                  </li>
                </ul>
              </li>
              <!-- error-boundary -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_sign_up">error-boundary</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_error_boundary_component">
                      error-boundary.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_error_boundary_styles">
                      error-boundary.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_error_boundary_test">
                      error-boundary.test</a>
                  </li>
                </ul>
              </li>
              <!-- utils -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown"
                  href="#idocs_scroll_to_top_component">scroll-to-top.component.jsx</a>
              </li>
            </ul>

            <!-- Redux -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_redux">Redux</a>
            <ul class="nav flex-column">
              <!-- store -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_store">store.js</a>
              </li>
              <!-- saga_testing_utils -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_saga_testing_utils">saga-testing.utils.js</a>
              </li>
              <!-- root_saga -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_root_saga">root-saga.js</a>
              </li>
              <!-- root_reducer -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_root_reducer">root-reducer.js</a>
              </li>
              <!-- cart -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_redux_cart">cart</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_actions">
                      cart.actions.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_actions_test">
                      cart.actions.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_actions">
                      cart.actions.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_actions_test">
                      cart.actions.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_reducer">
                      cart.reducer.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_reducer_test">
                      cart.reducer.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_sagas">
                      cart.sagas.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_sagas_test">
                      cart.sagas.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_selectors">
                      cart.selectors.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_types">
                      cart.types.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_utils">
                      cart.utils.js</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <!-- Dodatkowe wyjaśnienia -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_dodatkowe_wyjasnienia">Dodatkowe wyjaśnienia</a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#idocs_komponent">Komponent</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_rozklad_komponentow">Rozkład komponentów</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_props">Props</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_styled_components">Styled Components</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_jest">Jest</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_mock">Mock</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_snapshot_testing">Snapshot testing</a>
              </li>
            </ul>
          </li>
          </li>
        </ul>
      </div>

      <!-- Docs Content
	============================ -->
      <div class="idocs-content">
        <div class="container">
          <!-- Podstawowe Informacje
		============================ -->
          <section id="idocs_start">
            <h1>Dokumentacja</h1>
            <h2>Projekt Specjalnościowy</h2>
            <p class="lead">Szczegółowe omówienie kodu i narzędzi</p>
            <hr />
            <div class="row">
              <div class="col-sm-6 col-lg-4">
                <ul class="list-unstyled">
                  <li><strong>Indeksy:</strong> 7051, 6480</li>
                  <li><strong>Autorzy:</strong> Ingrid Pruszyńska, Przemysław Jadaś</li>
                </ul>
              </div>
              <div class="col-sm-6 col-lg-4">
                <ul class="list-unstyled">
                  <li><strong>Semestr:</strong> 6</li>
                  <li><strong>Kierunek:</strong> Informatyka</li>
                </ul>
              </div>
            </div>
          </section>
          <hr class="divider" />

          <!-- Repozytorium
		============================ -->
          <section id="idocs_repozytorium">
            <h2>Repozytorium</h2>
            <p class="lead">
              Linki do repozytorium: <br />
              <a href="https://github.com/ilshae/projekt-specjalnosciowy"
                target="_blank">https://github.com/ilshae/projekt-specjalnosciowy</a><br/>
              <a href="https://github.com/przemek-j/projekt-Specjalnosciowy-backend"
                target="_blank">https://github.com/przemek-j/projekt-Specjalnosciowy-backend</a>
            </p>
          </section>
          <hr class="divider" />

          <!-- Wersja live
		============================ -->
          <!-- <section id="idocs_wersja_live">
            <h2>Wersja live</h2>
            <p class="lead">
              Strona jest dostępna tutaj:<br /><a href="https://zadanie-na-uczelnie.pl/"
                target="_blank">https://zadanie-na-uczelnie.pl/</a>
            </p>

            <br />
          </section>
          <hr class="divider" /> -->

          <!-- Wykorzystane technologie
		============================ -->
          <section id="idocs_wykorzystane_technologie">
            <h2>Wykorzystane technologie</h2>
            <p>
              <b>Front end:</b> <br />HTML, CSS, Javascript, React,
              StyledComponents, Redux
            </p>
            <p><b>Back end:</b> <br />Spring</p>
          </section>
          <hr class="divider" />

          <!-- Omówienie kodu
		============================ -->
          <section id="idocs_omowienie_kodu">
            <h2>Omówienie kodu</h2>
            <p class="lead">
              Zapoznamy się z aplikacją za pomocą screenshotów
              funkcjonalności. Następnie rozbijemy je na komponenty Reacta i
              wyjaśnimy kod. <br />
              W miejscach wymagających znajomości konkretnych bibliotek lub
              pojęć będą wstawione odnośniki z wyjaśnieniami. <br />
              Po obejrzeniu indywidualnych komponentów powiemy jak one
              oddziałują na siebie, np. jak działa nawigacja. <br />
            </p>
          </section>
          <hr class="divider" />

          <!-- Analiza komponentów
		============================ -->
          <section id="idocs_analiza_komponentow">
            <h2>Analiza komponentów</h2>
            <p class="lead mb-5">
              Komponenty będą przedstawiane od szczegółu do ogółu poprzez
              obejrzenie wszystkich podstron dostępnych dla użytkowników.
            </p>
          </section>
          <hr class="divider" />

          <!-- Homepage
		============================ -->
          <section id="idocs_homepage">
            <h2>homepage</h2>
            <div id="idocs_homepage_component">
              <h4>homepage.component.jsx</h4>
              <!-- <p class="lead mb-4">
                Strona główna znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/" target="_blank">https://zadanie-na-uczelnie.pl/</a>
              </p>-->
              <p>
                Strona homepage to strona główna sklepu. Zawiera logo, nawigację i kafelki z kategoriami produktów i
                stopkę z autorem.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów
                odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">Homepage</strong>
                znajduje się
                <strong style="color: rgb(0, 0, 255)">Directory</strong>, a w
                nim <strong style="color: rgb(255, 0, 255)">MenuItem</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/homepage.png"><img class="img-fluid border"
                    src="assets/images/homepage.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import Directory from '../../components/directory/directory.component';  // import komponentu występującego w Homepage
                  
import { HomePageContainer } from './homepage.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const HomePage = () =&gt; (  // deklaracja komponentu funkcyjnego
  &lt;HomePageContainer&gt;
    &lt;Directory /&gt;
  &lt;/HomePageContainer&gt;
);

export default HomePage; // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_homepage_styles">
              <h4 class="mt-5">homepage.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components i animacji

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
export const HomePageContainer = styled.main`  // tworzy komponent HomePageContainer, który renderuje tag html main z określonymi stylami
  display: flex;
  flex-direction: column;
  align-items: center;
  animation: 0.2s ${fadeIn};
`;</code></pre>
            </div>
            <div id="idocs_homepage_test">
              <h4 class="mt-5">homepage.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import Homepage from './homepage.component';  // import komponentu, który będziemy testować

it('should render Homepage component', () =&gt; {  // sprawdzenie czy Homepage renderuje się poprawnie
  expect(shallow(&lt;Homepage /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany Homepage jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- Header
		============================ -->
          <section id="idocs_header">
            <h2>header</h2>
            <div id="idocs_header_component">
              <h4>header.component.jsx</h4>
              <p>
                <strong>Header wyświetla się na każdej stronie na górze.</strong>
                Zawiera logo, nawigację i koszyk. <br />
                <!-- SHOP przekierowuje do:
                <a href="https://zadanie-na-uczelnie.pl/shop" target="_blank">https://zadanie-na-uczelnie.pl/shop</a>
                <br />
                SIGN IN przekierowuje do:
                <a href="https://zadanie-na-uczelnie.pl/signin"
                  target="_blank">https://zadanie-na-uczelnie.pl/signin</a>
                <br /> -->
                Jeżeli użytkownik jest zalogowany zamiast SIGN IN, jest opcja
                SIGN OUT.<br />
                Kliknięcie na ikonę koszyka spowoduje jego rozwinięcie. Z tego
                miejsca jest dostępny przycisk CHECKOUT. <!--, który przekierowuje
                do:
                <a href="https://zadanie-na-uczelnie.pl/checkout"
                  target="_blank">https://zadanie-na-uczelnie.pl/checkout</a>,--> Gdzie można obejrzeć produkty w koszyku.
              </p>
              <p>
                <a class="popup-img" href="assets/images/header.png"><img class="img-fluid border"
                    src="assets/images/header.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react'; // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux'; // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect'; // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import CartIcon from '../cart-icon/cart-icon.component'; // import innych komponentów
import CartDropdown from '../cart-dropdown/cart-dropdown.component'; // import innych komponentów
import { selectCartHidden } from '../../redux/cart/cart.selectors'; // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { selectCurrentUser } from '../../redux/user/user.selectors'; // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { signOutStart } from '../../redux/user/user.actions'; // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { ReactComponent as Logo } from '../../assets/logo.svg'; // import grafiki Logo.svg

import {
  HeaderContainer,
  BrandContainer,
  LogoContainer,
  OptionsContainer,
  OptionLink,
} from './header.styles'; // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const Header = (
  { currentUser, hidden, signOutStart } // deklaracja komponentu funkcyjnego, przekazanie propsów
) =&gt; (
  &lt;HeaderContainer&gt;
    &lt;BrandContainer to='/'&gt;  // ikona loga + nazwa aplikacji, po kliknięciu przekierowuje do '/'
      {' '}
      &lt;LogoContainer&gt;
        &lt;Logo /&gt;
      &lt;/LogoContainer&gt;
      Ingrid
    &lt;/BrandContainer&gt;
    &lt;OptionsContainer&gt;
      &lt;OptionLink to='/shop'&gt;SHOP&lt;/OptionLink&gt; // wyświetl w nawigacji SHOP
      {currentUser ? ( // jeżeli użytkownik jest zalogowany, wyświetl SIGN OUT, jeżeli nie jest zalogowany, wyświetl SIGN IN
        &lt;OptionLink as='div' onClick={signOutStart}&gt;
          SIGN OUT
        &lt;/OptionLink&gt;
      ) : (
        &lt;OptionLink to='/signin'&gt;SIGN IN&lt;/OptionLink&gt;
      )}
      &lt;CartIcon /&gt;
    &lt;/OptionsContainer&gt;
    {hidden ? null : &lt;CartDropdown /&gt;} // wyświetl koszyk, zależnie od parametru hidden jest on schowany lub widoczny
  &lt;/HeaderContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o aktualnym użytkowniku, i czy koszyk jest 'otwarty'
  currentUser: selectCurrentUser,
  hidden: selectCartHidden,
});

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik kliknie Sign Out, przekazuje do store informację, że użytkownik się wylogował
  signOutStart: () =&gt; dispatch(signOutStart()),
});

export default connect(mapStateToProps, mapDispatchToProps)(Header); // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_header_styles">
              <h4 class="mt-5">header.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components'; // import biblioteki styled components
import { Link } from 'react-router-dom';  // import komponentu Link z biblioteki react-router-dom (do nawigacji, opisane w oddzielnym dziale)

export const HeaderContainer = styled.header` // tworzy komponent HeaderContainer, który renderuje tag html header z określonymi stylami
  height: 70px;
  width: 100%;
  display: flex;
  justify-content: space-between;
  margin-bottom: 25px;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    height: 60px;
    padding: 10px;
    margin-bottom: 20px;
  }
`;

export const BrandContainer = styled(Link)` // tworzy komponent BrandContainer, który renderuje komponent Link z biblioteki react-router-dom z określonymi stylami
  height: 100%;
  display: flex;
  align-items: center;
  text-transform: uppercase;
  font-size: 24px;
  white-space: nowrap;
  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 50px;
    padding: 0;
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    font-size: 20px;
  }

  @media screen and (max-width: 350px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 350px
    font-size: 18px;
  }
`;

export const LogoContainer = styled.div`  // tworzy komponent LogoContainer,  który renderuje tag html div z określonymi stylami
  margin-right: 15px;
  display: flex;
  align-items: center;
  justify-content: center;

  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    display: none;
  }
`;

export const OptionsContainer = styled.div` // tworzy komponent OptionsContainer,  który renderuje tag html div z określonymi stylami
  width: 50%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  font-size: 22px;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 80%;
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    font-size: 18px;
    a {
      padding: 5px 8px;
    }
  }
  @media screen and (max-width: 350px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 350
    font-size: 16px;
    a {
      padding: 2px 4px;
    }
  }
`;

export const OptionLink = styled(Link)` // tworzy komponent OptionLink, który renderuje komponent Link z biblioteki react-router-dom z określonymi stylami
  padding: 10px 15px;
  cursor: pointer;
`;

OptionLink.displayName = 'OptionLink';  // po zrenderowaniu w DevTools komponent OptionLink wyświetlał by się jako styled.link, ale po zmianie parametru displayName wyświetli się jako OptionLink co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_header_test">
              <h4 class="mt-5">header.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { Header } from './header.component';  // import komponentu, który będziemy testować
import CartDropdown from '../cart-dropdown/cart-dropdown.component';  // import komponentu, który występuje w komponencie Header

describe('Header component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu Header
  let wrapper;  // tworzenie zmiennych do testów
  let mockSignOutStart;  // tworzenie zmiennych do testów

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockSignOutStart = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {   // mockowanie propsów przekazanych do Header
      hidden: true,
      currentUser: {
        uid: '123'
      },
      signOutStart: mockSignOutStart
    };

    wrapper = shallow(&lt;Header {...mockProps} /&gt;);  // wyrenderuj komponent Header z propsami wyżej
  });

  it('should render Header component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent Header
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany Header jest zgodny z snapshotem
  });

  describe('if currentUser is present', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć propsa currentUser
    it('should render sign out link', () =&gt; {  // komponent powinien wyrenderować w nawigacji przycisk SIGN OUT, bo podajemy zalogowanego użytkownika
      expect(wrapper.find('OptionLink').at(1).text()).toBe('SIGN OUT');  // znajdz w zmiennej wrapper (zawierającą komponent Header), tag html o nazwie OptionLink, drugi z kolei, text w środku powinien brzmieć 'SIGN OUT'
    });

    it('should call signOutStart method when link is clicked', () =&gt; {  // po kliknięciu SIGN OUT, sprawdź czy została wywołana funkcja signOutStart()
      wrapper.find('OptionLink').at(1).simulate('click');   // symulacja kliknięcia na SIGN OUT

      expect(mockSignOutStart).toHaveBeenCalled();  // oczekuj, że funkcja mockSignOutStart zostanie wywołana
    });
  });

  describe('if currentUser is null', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć pustej zmiennej currentUser
    it('should render sign in link', () =&gt; {  // użytkownik nie jest zalogowany, powinien mieć w nawigacji opcję SIGN IN
      const mockProps = {   // mockuj nowe propsy, adekwatne do sytuacji
        hidden: true,
        currentUser: null,
        signOutStart: mockSignOutStart,
      };

      const newWrapper = shallow(&lt;Header {...mockProps} /&gt;);  // nowa zmienna z nowymi propsami

      expect(newWrapper.find('OptionLink').at(1).text()).toBe('SIGN IN');  // znajdz w zmiennej wrapper (zawierającą komponent Header), tag html o nazwie OptionLink, drugi z kolei, text w środku powinien brzmieć 'SIGN IN' 
    });
  });

  describe('if hidden is true', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć zmiennej hidden odpowiedzialnej za wyświetlanie koszyka
    it('should not render CartDropdown', () =&gt; {  // nie renderuj CartDropdown (koszyka), bo props hidden == true
      expect(wrapper.exists(CartDropdown)).toBe(false);  // szuka w Headerze komponentu CartDropdown, jeżeli go nie znajdzie zwróci fałsz
    });
  });

  describe('if hidden is false', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć zmiennej hidden odpowiedzialnej za wyświetlanie koszyka
    it('should render CartDropdown', () =&gt; {  //  renderuj CartDropdown (koszyk), bo props hidden == false
      const mockProps = {
        hidden: false,
        currentUser: null,
        signOutStart: mockSignOutStart,
      };

      const newWrapper = shallow(&lt;Header {...mockProps} /&gt;);  // nowa zmienna z nowymi propsami

      expect(newWrapper.exists(CartDropdown)).toBe(true);  // szuka w Headerze komponentu CartDropdown, jeżeli go znajdzie zwróci prawdę
    });
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- cart-icon
		============================ -->
          <section id="idocs_cart_icon">
            <h2>cart-icon</h2>
            <div id="idocs_cart_icon_component">
              <h4>cart-icon.component.jsx</h4>
              <p>
                Jest to ikona przedstawiająca koszyk, występuje w środku
                komponentu header. Cyfra w ikonie odzwierciedla ilość
                przedmiotów w koszyku.<br />
                Po kliknięciu rozwija komponent cart-dropdown wyświetlający
                produkty w koszyku i ich szczegóły.<br />
                Z tego miejsca jest dostępny przycisk CHECKOUT,<!-- , który
                przekierowuje do:
                <a href="https://zadanie-na-uczelnie.pl/checkout"
                  target="_blank">https://zadanie-na-uczelnie.pl/checkout</a>,<br />-->
                gdzie po kliknięciu można obejrzeć produkty w koszyku i za nie zapłacić.
              </p>
              <p>
                <a class="popup-img" href="assets/images/cart.png"><img class="img-fluid border"
                    src="assets/images/cart.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { toggleCartHidden } from '../../redux/cart/cart.actions';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { selectCartItemsCount } from '../../redux/cart/cart.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CartContainer,
  ShoppingIcon,
  ItemCountContainer,
} from './cart-icon.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CartIcon = ({ toggleCartHidden, itemCount }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CartContainer onClick={toggleCartHidden}&gt;  // po kliknięciu na CartContainer zostanie wywołana funkcja toggleCartHidden, która została przekazana do tego komponentu za pomocą props
    &lt;ShoppingIcon /&gt;
    &lt;ItemCountContainer&gt;{itemCount}&lt;/ItemCountContainer&gt;  // ikona koszyka wyświetla liczbę odzwierciedlającą ilość produktów w koszyku, zmienna itemCount, została przekazana do tego komponentu za pomocą props
  &lt;/CartContainer&gt;
);

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik kliknie na ikonę koszyka, zmienna hidden w store zmieni się na przeciwną zmienną (albo true albo false)
  toggleCartHidden: () =&gt; dispatch(toggleCartHidden()),
});

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile produktów znajduje się w koszyku
  itemCount: selectCartItemsCount,
});

export default connect(mapStateToProps, mapDispatchToProps)(CartIcon);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_cart_icon_styles">
              <h4 class="mt-5">cart-icon.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components
import { ReactComponent as ShoppingIconSVG } from '../../assets/shopping-bag.svg';  // import grafiki shopping-bar (czyli ikony koszyka)

export const CartContainer = styled.header`  // tworzy komponent CartContainer, który renderuje tag html header z określonymi stylami
  width: 45px;
  height: 45px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
`;

CartContainer.displayName = 'CartContainer';  // po zrenderowaniu w DevTools komponent CartContainer wyświetlał by się jako styled.header, ale po zmianie parametru displayName wyświetli się jako CartContainer co ułatwi debugowanie

export const ShoppingIcon = styled(ShoppingIconSVG)`  // tworzy komponent ShoppingIcon, który renderuje plik shopping-bar.svg jako grafikę svg z określonymi stylami
  width: 24px;
  height: 24px;
`;

export const ItemCountContainer = styled.span`  // tworzy komponent ItemCountContainer, który renderuje tag html span z określonymi stylami
  position: absolute;
  font-size: 10px;
  font-weight: bold;
  bottom: 12px;
`;

ItemCountContainer.displayName = 'ItemCountContainer';  // po zrenderowaniu w DevTools komponent ItemCountContainer wyświetlał by się jako styled.header, ale po zmianie parametru displayName wyświetli się jako ItemCountContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_cart_icon_test">
              <h4 class="mt-5">cart-icon.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CartIcon } from './cart-icon.component';  // import komponentu, który będziemy testować

describe('CartIcon component', () => {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CartIcon
  let wrapper;  // tworzenie zmiennych do testów
  let mockToggleCartHidden;  // tworzenie zmiennych do testów

  beforeEach(() => {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockToggleCartHidden = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {  // mockowanie propsów przekazanych do CartIcon
      itemCount: 0,
      toggleCartHidden: mockToggleCartHidden,
    };

    wrapper = shallow(<CartIcon {...mockProps} />);  // wyrenderuj komponent CartIcon z propsami wyżej
  });

  it('should render CartIcon component', () => {  // tworzy indywidualny test, który powinien wyrenderować komponent CartIcon
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CartIcon jest zgodny z snapshotem
  });

  it('should call toggleCartHidden when icon is clicked', () => {  // jeżeli ikona koszyka zostanie kliknięta wartość zmiennej hidden powinna zmienić się na przeciwną (albo true albo false)
    wrapper.find('CartContainer').simulate('click');  // symuluj kliknięcie na koszyk
    expect(mockToggleCartHidden).toHaveBeenCalled();  // jeżeli koszyk został kliknięty funkcja mockToggleCartHidden powinna zostać wywołana
  });

  it('should render the itemCount as the text', () => {  // zmienna itemCount powinna wyrenderować się jako string
    const itemCount = parseInt(wrapper.find('ItemCountContainer').text());  // znajdz komponent o nazwie ItemCountContainer, i przekonwertuj string na int
    expect(itemCount).toBe(0);  // przekowertowany int powinien równać się 0 (brak przedmiotów w koszyku)
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- cart-dropdown
		============================ -->
          <section id="idocs_cart_dropdown">
            <h2>cart-dropdown</h2>
            <div id="idocs_cart_dropdown_component">
              <h4>cart-dropdown.component.jsx</h4>
              <p>
                Ten komponent rozwija się po kliknięciu na ikonę koszyka.
                Zawiera produkty dodane przez użytkownika, ich ilość i cenę.<br />
                Z tego miejsca jest dostępny przycisk CHECKOUT<!--, który
                przekierowuje do: https://zadanie-na-uczelnie.pl/checkout,-->
                gdzie po kliknięciu można obejrzeć produkty w koszyku i za nie zapłacić.
              </p>
              <p>
                <a class="popup-img" href="assets/images/cart-dropdown.png"><img class="img-fluid border"
                    src="assets/images/cart-dropdown.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { withRouter } from 'react-router-dom';  // funkcje do obsługi nawigacji (omówione w oddzielnym dziale)

import CartItem from '../cart-item/cart-item.component';  // import komponentu występującego w CartDropdown
import { selectCartItems } from '../../redux/cart/cart.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { toggleCartHidden } from '../../redux/cart/cart.actions.js';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CartDropdownContainer,
  CartDropdownButton,
  EmptyMessageContainer,
  CartItemsContainer,
} from './cart-dropdown.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CartDropdown = ({ cartItems, history, dispatch }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CartDropdownContainer&gt;
    &lt;CartItemsContainer&gt;
      {cartItems.length ? (  // jeżeli cartItems (tablica) ma długość większą niż 0 (ma w sobie jakieś obiekty)
        cartItems.map((cartItem) =&gt; (  // dla każdego obiektu w cartItems 
          &lt;CartItem key={cartItem.id} cartItem={cartItem} /&gt;  // wyrenderuj komponent CartItem z okreslonymi propsami
        ))
      ) : (
        &lt;EmptyMessageContainer&gt;Your cart is empty&lt;/EmptyMessageContainer&gt; // jeżeli cartItems jest puste wyświetl komunikat, że koszyk jest pusty
      )}
    &lt;/CartItemsContainer&gt;
    &lt;CartDropdownButton
      onClick={() =&gt; {  // jeżeli przycisk CHECKOUT został kliknięty
        history.push('/checkout');  // zmień url na /checkout
        dispatch(toggleCartHidden());  // schowaj koszyk, zmień wartość hidden na przeciwną (true albo false)
      }}
    &gt;
      CHECKOUT
    &lt;/CartDropdownButton&gt;
  &lt;/CartDropdownContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile produktów znajduje się w koszyku
  cartItems: selectCartItems,
});

export default withRouter(connect(mapStateToProps)(CartDropdown));  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_cart_dropdown_styles">
              <h4 class="mt-5">cart-dropdown.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w CartDropdown (przycisk CHECKOUT)

export const CartDropdownContainer = styled.aside`  // tworzy komponent CartDropdownContainer, który renderuje tag html aside z określonymi stylami
  position: absolute;
  width: 240px;
  height: 340px;
  display: flex;
  flex-direction: column;
  padding: 20px;
  border: 1px solid black;
  background-color: white;
  top: 60px;
  right: 10px;
  z-index: 5;
`;

export const CartDropdownButton = styled(CustomButton)`  // tworzy komponent CartDropdownButton, który renderuje komponent CustomButton z określonymi stylami
  margin-top: auto;
`;

CartDropdownButton.displayName = 'CartDropdownButton';  // po zrenderowaniu w DevTools komponent CartDropdownButton wyświetlał by się jako styled.button, ale po zmianie parametru displayName wyświetli się jako CartDropdownButton co ułatwi debugowanie

export const EmptyMessageContainer = styled.span`  // tworzy komponent EmptyMessageContainer, który renderuje tag html span z określonymi stylami
  font-size: 18px;
  margin: 50px auto;
`;

EmptyMessageContainer.displayName = 'EmptyMessageContainer';  // po zrenderowaniu w DevTools komponent EmptyMessageContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako EmptyMessageContainer co ułatwi debugowanie

export const CartItemsContainer = styled.div`  // tworzy komponent CartItemsContainer, który renderuje tag html div z określonymi stylami
  height: 240px;
  display: flex;
  flex-direction: column;
  overflow: auto;
`;</code></pre>
            </div>
            <div id="idocs_cart_dropdown_test">
              <h4 class="mt-5">cart-dropdown.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme'; // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CartDropdown } from './cart-dropdown.component';  // import komponentu, który będziemy testować
import CartItem from '../cart-item/cart-item.component';  // import komponentu, który występuje w CartDropdown

import { toggleCartHidden } from '../../redux/cart/cart.actions';  // import funkcji ze store Redux

describe('CartDropdown component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CartDropdown
  let wrapper;  // tworzenie zmiennych do testów
  let mockHistory;  // tworzenie zmiennych do testów
  let mockDispatch;  // tworzenie zmiennych do testów
  const mockCartItems = [{ id: 1 }, { id: 2 }, { id: 3 }];  // tworzenie zmiennych do testów

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockHistory = {   // tworzenie zmiennych do testów
      push: jest.fn(),  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
    };

    mockDispatch = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {  // mockowanie propsów przekazanych do CartDropdown
      cartItems: mockCartItems,
      history: mockHistory,
      dispatch: mockDispatch,
    };

    wrapper = shallow(&lt;CartDropdown {...mockProps} /&gt;);  // wyrenderuj komponent CartDropdown z propsami wyżej
  });

  it('should render CartDropdown component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CartDropdown
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CartDropdown jest zgodny z snapshotem
  });

  it('should call history.push when button is clicked', () =&gt; {  // po kliknięciu w CHECKOUT, url strony powinien się zmienić i przenieść użytkownika na /checkout
    wrapper.find('CartDropdownButton').simulate('click');  // symulacja kliknięcia w CHECKOUT
    expect(mockHistory.push).toHaveBeenCalled();  // funkcja mockHistory.push powinna zostać wywołana
    expect(mockDispatch).toHaveBeenCalledWith(toggleCartHidden());  // "zamknij" koszyk, poprzez zmianę zmiennej hidden na przeciwną (true albo false)
  });

  it('should render an equal number of CartItem components as the cartItems prop', () =&gt; {  //  komponent powinien wyrenderować taką samą ilość komponentów cartItem z jakiej składa sięprop cartItems
    expect(wrapper.find(CartItem).length).toEqual(mockCartItems.length); // porównanie długości obu obiektów
  });

  it('should render EmptyMessageContainer if cartItems is empty', () =&gt; {  // jeżeli nie ma produtków w koszyku wyświetl tekst, koszyk jest pusty
    const mockProps = {   // nowe propsy z pustym cartItems
      cartItems: [],
      history: mockHistory,
      dispatch: mockDispatch,
    };

    const newWrapper = shallow(&lt;CartDropdown {...mockProps} /&gt;);  // wyrenderuj komponent z nowymi propsami
    expect(newWrapper.exists('EmptyMessageContainer')).toBe(true);  // szuka w CartDropdown EmptyMessageContainer, jeżeli go znajdzie zwróci prawdę
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- cart-item
		============================ -->
          <section id="idocs_cart_item">
            <h2>cart-item</h2>
            <div id="idocs_cart_item_component">
              <h4>cart-item.component.jsx</h4>
              <p>
                Przedstawia pojedynczy produkt. Zawiera nazwę, zdjęcie, ilość i cenę produktu. <!--<br />
                <strong>Wyświetla się w koszyku i na stronie checkout:</strong>
                <a href="https://zadanie-na-uczelnie/checkout" target="_blank">https://zadanie-na-uczelnie/checkout</a>-->
              </p>
              <p>
                <a class="popup-img" href="assets/images/cart-item.png"><img class="img-fluid border"
                    src="assets/images/cart-item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { addItem, removeItem } from '../../redux/cart/cart.actions';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CartItemContainer,
  ItemDetailsContainer,
  CartItemImage,
} from './cart-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

import { QuantityContainer } from '../checkout-item/checkout-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js, w tym przypadku z innego komponentu

const CartItem = ({ cartItem, addItem, removeItem }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { imageUrl, price, name, quantity } = cartItem; // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych
  return (
    &lt;CartItemContainer&gt;
      &lt;CartItemImage src={imageUrl} alt=&quot;item&quot; /&gt; // zdjęcie produktu
      &lt;ItemDetailsContainer&gt;
        &lt;span&gt;{name}&lt;/span&gt;  // nazwa produktu 
        &lt;QuantityContainer&gt;
          &lt;div onClick={() =&gt; removeItem(cartItem)}&gt;&amp;#10094;&lt;/div&gt; // strzałka w lewo - o 1 sztukę zmniejsz
          &lt;span&gt;{quantity}&lt;/span&gt;
          &lt;div onClick={() =&gt; addItem(cartItem)}&gt;&amp;#10095;&lt;/div&gt; // strzałka w prawo - o 1 sztukę w prawo
        &lt;/QuantityContainer&gt;
        &lt;span&gt;
          {quantity} x ${price} // ilość x cena
        &lt;/span&gt;
      &lt;/ItemDetailsContainer&gt;
    &lt;/CartItemContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli któraś ze strzałek zmniejszająca lub zwiększająca ilość produktów zostanie kliknięta zaktualizuj stan w store Redux
  addItem: (item) =&gt; dispatch(addItem(item)),
  removeItem: (item) =&gt; dispatch(removeItem(item)),
});

export default React.memo(connect(null, mapDispatchToProps)(CartItem));  // łączy komponent React ze store Redux, Jeśli twój komponent przy takich samych właściwościach zawsze renderuje tę samą strukturę, możesz opakować go w React.memo w celu poprawy wydajności. Oznacza to, że React pominie renderowanie tego komponentu i użyje jego ostatnio wyrenderowanej wersji. </code></pre>
            </div>
            <div id="idocs_cart_item_styles">
              <h4 class="mt-5">cart-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CartItemContainer = styled.section`  // tworzy komponent CartItemContainer, który renderuje tag html section z określonymi stylami
  width: 100%;
  display: flex;
  height: 80px;
  margin-bottom: 15px;
`;

export const CartItemImage = styled.img`  // tworzy komponent CartItemImage, który renderuje tag html img z określonymi stylami
  width: 30%;
`;

export const ItemDetailsContainer = styled.div`  // tworzy komponent ItemDetailsContainer, który renderuje tag html div z określonymi stylami
  width: 70%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
  padding: 10px 20px;

  span {  // style dla span'a znajdującego się w ItemDetailsContainer
    font-size: 14px;
    line-height: 12px;
    margin-bottom: 10px;
  }
`;</code></pre>
            </div>
            <div id="idocs_cart_item_test">
              <h4 class="mt-5">cart-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import CartItem from './cart-item.component';  // import komponentu, który będziemy testować

it('should render CartItem component', () =&gt; {  // sprawdza czy CartItem wyrenderował się poprawnie
  const mockItem = {
    imageUrl: 'www.testImage.com',
    price: 10,
    name: 'hats',
    quantity: 2,
  };

  expect(shallow(&lt;CartItem item={mockItem} /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany CartIcon jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- menu-item
		============================ -->
          <section id="idocs_menu_item">
            <h2>menu-item</h2>
            <div id="idocs_menu_item_component">
              <h4>menu-item.component.jsx</h4>
              <p>
                Ten komponent odpowiada ze wyświetlenie kafelka z kategorią
                produktu. <br />
                Zawiera zdjęcie przedstawiające kategorię i przycisk
                pozwalający na przejście do indywidualnego URL każdej
                kategorii.<!--, <np.:<br />
                <a href="https://zadanie-na-uczelnie/shop/womens"
                  target="_blank">https://zadanie-na-uczelnie/shop/womens</a>-->
              </p>
              <p>
                <a class="popup-img" href="assets/images/menu-item.png"><img class="img-fluid border"
                    src="assets/images/menu-item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { withRouter } from 'react-router-dom';  // funkcja do obsługi nawigacji (omówione w oddzielnym dziale)

import {
  MenuItemContainer,
  BackgroundImageContainer,
  ContentContainer,
  ContentTitle,
} from './menu-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const MenuItem = ({ title, imageUrl, history, linkUrl, match }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;MenuItemContainer onClick={() =&gt; history.push(`${match.url}${linkUrl}`)}&gt;  // zmień url na /shop/{nazwa-kategorii-produktow}
    &lt;BackgroundImageContainer // kontener ze zdjęciem
      className=&quot;background-image&quot;
      imageUrl={imageUrl}
    /&gt;
    &lt;ContentContainer className=&quot;content&quot;&gt;  // kontener z przyciskiem z nazwą kategorii
      &lt;ContentTitle&gt;{title.toUpperCase()}&lt;/ContentTitle&gt;
    &lt;/ContentContainer&gt;
  &lt;/MenuItemContainer&gt;
);

export default withRouter(MenuItem);  // funkcja do obsługi nawigacji (omówione w oddzielnym dziale)</code></pre>
            </div>
            <div id="idocs_menu_item_styles">
              <h4 class="mt-5">menu-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const MenuItemContainer = styled.section`  // tworzy komponent MenuItemContainer, który renderuje tag html section z określonymi stylami
  height: 380px;
  min-width: 30%;
  overflow: hidden;
  flex: 1 1 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid black;
  margin: 0 7.5px 15px;
  overflow: hidden;

  &amp;:hover {   // style dla MenuItemContainer, gdy najeżdzamy na komponent myszką
    cursor: pointer;
    border: 1px solid #e08800;

    &amp; .background-image {   // zmiana styli dla .background-image gdy najeżdzamy myszką na MenuItemContainer
      transform: scale(1.1);
      transition: transform 6s cubic-bezier(0.25, 0.45, 0.45, 0.95);
    }

    &amp; .content {  // zmiana styli dla .content gdy najeżdzamy myszką na MenuItemContainer
      opacity: 0.8;
      border: 1px solid #e08800;
      color: #e08800;
    }
  }

  &amp;:first-child {   // style dla pierwszego dziecka MenuItemContainer 
    margin-right: 7.5px;
  }

  &amp;:last-child {  // style dla ostatniego dziecka MenuItemContainer 
    margin-left: 7.5px;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    height: 240px;
    min-width: 50vw;
  }
`;

MenuItemContainer.displayName = 'MenuItemContainer';  // po zrenderowaniu w DevTools komponent MenuItemContainer wyświetlał by się jako styled.section, ale po zmianie parametru displayName wyświetli się jako MenuItemContainer co ułatwi debugowanie

export const BackgroundImageContainer = styled.div`  // tworzy komponent BackgroundImageContainer, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  background-image: ${({ imageUrl }) =&gt; `url(${imageUrl})`};
`;

BackgroundImageContainer.displayName = 'BackgroundImageContainer';  // po zrenderowaniu w DevTools komponent BackgroundImageContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako BackgroundImageContainer co ułatwi debugowanie

export const ContentContainer = styled.div`  // tworzy komponent ContentContainer, który renderuje tag html div z określonymi stylami
  height: 90px;
  padding: 0 25px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: 1px solid black;
  background-color: white;
  opacity: 0.6;
  position: absolute;
  text-align: center;
  width: 165px;
`;

export const ContentTitle = styled.span`  // tworzy komponent ContentTitle, który renderuje tag html span z określonymi stylami
  font-weight: bold;
  margin-bottom: 6px;
  font-size: 22px;
`;</code></pre>
            </div>
            <div id="idocs_menu_item_test">
              <h4 class="mt-5">menu-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';

import { MenuItem } from './menu-item.component';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

describe('MenuItem component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu MenuItem
  let wrapper;  // tworzenie zmiennych do testów
  let mockMatch;
  let mockHistory;
  const linkUrl = '/hats';
  const size = 'large';
  const imageUrl = 'testimage';

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockMatch = {  // tworzenie zmiennych do testów
      url: '/shop',
    };

    mockHistory = {  // tworzenie zmiennych do testów
      push: jest.fn(),  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
    };

    const mockProps = {  // mockowanie propsów przekazanych do MenuItem
      match: mockMatch,
      history: mockHistory,
      linkUrl,
      size,
      title: 'hats',
      imageUrl,
    };

    wrapper = shallow(&lt;MenuItem {...mockProps} /&gt;);  // wyrenderuj komponent MenuItem z propsami wyżej
  });

  it('should render MenuItem component', () =&gt; {  // test sprawdza czy MenuItem wyrenderował się prawidłowo
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany MenuItem jest zgodny z snapshotem
  });

  it('should call history.push with the right string when MenuItemContainer clicked', () =&gt; {  // funkcja history.push powinna zostać wywołana, gdy kafelek z nazwą kategorii zostanie klinięty
    wrapper.find('MenuItemContainer').simulate('click');  // symuluj kliknięcie na MenuItemContainer

    expect(mockHistory.push).toHaveBeenCalledWith(`${mockMatch.url}${linkUrl}`);  // sprawdzenie czy użytkownik jest przekierowany do prawidłowo url
  });

  it('should pass size to MenuItemContainer as the prop size', () =&gt; {  // sprawdź czy prop size został przekazany to MenuItemContainer
    expect(wrapper.find('MenuItemContainer').prop('size')).toBe(size);
  });

  it('should pass imageUrl to BackgroundImageContainer as the prop imageUrl', () =&gt; {  // sprawdź czy prop imageURl został przekazany do BackgroundImageContainer
    expect(wrapper.find('BackgroundImageContainer').prop('imageUrl')).toBe(
      imageUrl
    );
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- directory
		============================ -->
          <section id="idocs_directory">
            <h2>directory</h2>
            <div id="idocs_directory_component">
              <h4>directory.component.jsx</h4>
              <p>
                Directory jest głównym konterem, który zawiera w sobie kafelki
                MenuItem poszczególnych kategorii produtków.
              </p>
              <p>
                <a class="popup-img" href="assets/images/directory.png"><img class="img-fluid border"
                    src="assets/images/directory.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { selectDirectorySections } from '../../redux/directory/directory.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import MenuItem from '../menu-item/menu-item.component';  // import komponentu występującego w Dropdown

import { DirectoryMenuContainer } from './directory.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const Directory = ({ sections }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;DirectoryMenuContainer&gt;
    {sections.map(({ id, ...otherSectionProps }) =&gt; (  // dla każdego obiektu w sections 
      &lt;MenuItem key={id} {...otherSectionProps} /&gt;  // wyrenderuj komponent MenuItem z okreslonymi propsami
    ))}
  &lt;/DirectoryMenuContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile sekcji komponent powinien wyrenderować i z jaką treścią
  sections: selectDirectorySections,
});

export default connect(mapStateToProps)(Directory);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_directory_styles">
              <h4 class="mt-5">directory.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const DirectoryMenuContainer = styled.article`  // tworzy komponent DirectoryMenuContainer, który renderuje tag html article z określonymi stylami
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
`;</code></pre>
            </div>
            <div id="idocs_directory_test">
              <h4 class="mt-5">directory.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { Directory } from './directory.component';  // import komponentu, który będziemy testować

it('should render Directory component', () => {  // sprawdzenie czy komponent Directory prawidłowo się renderuje
  expect(shallow(<Directory sections={[]} />)).toMatchSnapshot();  // sprawdź czy wyrenderowany Directory jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- footer
		============================ -->
          <section id="idocs_footer">
            <h2>footer</h2>
            <div id="idocs_footer_component">
              <h4>footer.component.jsx</h4>
              <p>
                <strong>Header wyświetla się na każdej stronie na górze.</strong>
                To prosty komponent wyświetlający autorów aplikacji.
              </p>
              <p>
                <a class="popup-img" href="assets/images/footer.png"><img class="img-fluid border"
                    src="assets/images/footer.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import { FooterContainer, AuthorContainer } from './footer.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const Footer = () =&gt; (  // deklaracja komponentu funkcyjnego
  &lt;FooterContainer&gt;
    &lt;AuthorContainer&gt;&amp;copy; Ingrid Pruszyńska&lt;/AuthorContainer&gt;  // wypisanie Autora
  &lt;/FooterContainer&gt;
);

export default Footer;  // wyeksportowanie komponentu (aby inny komponent mógł go użyć)</code></pre>
            </div>
            <div id="idocs_footer_styles">
              <h4 class="mt-5">footer.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const FooterContainer = styled.footer`  // tworzy komponent FooterContainer, który renderuje tag html footer z określonymi stylami  height: 50px;
  width: 100%;
  margin-top: 30px;
  text-align: center;
`;

export const AuthorContainer = styled.div`  // tworzy komponent AuthorContainer, który renderuje tag html div z określonymi stylami
  font-size: 22px;
  padding: 20px 0 5px 0;
  border-top: 2px solid black;
  position: absolute;
  bottom: 0;
  width: 100%;

  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    font-size: 18px;
    a {
      padding: 5px 8px;
    }
  }
  @media screen and (max-width: 350px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 350px
    font-size: 16px;
    a {
      padding: 2px 4px;
    }
  }
`;</code></pre>
            </div>
            <div id="idocs_footer_test">
              <h4 class="mt-5">footer.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { Footer } from './footer.component';  // import komponentu, który będziemy testować

it('should render Footer component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent Footer
  expect(shallow(&lt;Footer /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany Footer jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- shop-page
  ============================ -->
          <section id="idocs_shoppage">
            <h2>shop</h2>
            <div id="idocs_shop_component">
              <h4>shop.component.jsx</h4>
              <!-- <p class="lead mb-4">
                Strona "SHOP" znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/shop" target="_blank">https://zadanie-na-uczelnie.pl/shop</a>
              </p> -->
              <p>
                Shop page zawiera header i pierwsze 4 produkty wszystkich kategorii produktów oraz stopkę z autorem.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów
                odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">Shop page</strong>
                znajduje się
                <strong style="color: rgb(0, 0, 255)">CollectionsOverview</strong>, a w nim
                <strong style="color: rgb(255, 0, 255)">CollectionPreview</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/shoppage.png"><img class="img-fluid border"
                    src="assets/images/shoppage.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React, { useEffect, lazy, Suspense } from 'react';  // // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useEffect - pozwala na uruchomienie dodatkowego kodu po tym, jak React zaktualizuej drzewo DOM, lazy - pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty, suspense - komponent wyrenderowany poprzez lazy() powinien zostać wyrenderowany wewnątrz suspense(), dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. kręcące się kółko)
import { Route } from 'react-router-dom';  // funkcja do obsługi nawigacji (omówione w oddzielnym dziale)
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { fetchCollectionsStart } from '../../redux/shop/shop.actions';  // // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import Spinner from '../../components/spinner/spinner.component';  // komponent zastępczy (będzie wyświetlał kręcące się kółko, w trakcie ładowania komponentów)

import { ShopPageContainer } from './shop.styles';  // // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const CollectionsOverviewContainer = lazy(() =&gt;
  import('../../components/collections-overview/collections-overview.container')
);  // import CollectionsOverviewContainer poprzez funkcję lazy()

const CollectionPageContainer = lazy(() =&gt;  
  import('../collection/collection.container')
);  // import CollectionPageContainer poprzez funkcję lazy()

export const ShopPage = ({ fetchCollectionsStart, match }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  useEffect(() =&gt; {
    fetchCollectionsStart();
  }, [fetchCollectionsStart]);  // za pierwszym razem po zrenderowaniu DOMu wywołaj funkcję fetchCollectionsStart, jest tu użyta tablica optymalizacyjna, co znaczy, że komponent wyrenderuje się jeszcze raz jeżeli stan fetchCollectionsStart się zmieni

  return (
    &lt;ShopPageContainer&gt;
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;  // zanim fetchCollectionsStart zwróci zawartość kolekcji wyświetl obracający się spinner 
        &lt;Route
          exact
          path={`${match.path}`}
          component={CollectionsOverviewContainer}
        /&gt; // nawigacja zmieni url zgodnie z path
        &lt;Route
          path={`${match.path}/:collectionId`}  // collectionId to id kategorii produktów
          component={CollectionPageContainer}
        /&gt;
      &lt;/Suspense&gt;
    &lt;/ShopPageContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({
  fetchCollectionsStart: () =&gt; dispatch(fetchCollectionsStart()),
});  // aktualizuje stan store w Redux tym co zwróci fetchCollectionsStart

export default connect(null, mapDispatchToProps)(ShopPage);  // funkcja do obsługi Redux (omówione w oddzielnym dziale)</code></pre>
            </div>
            <div id="idocs_shop_styles">
              <h4 class="mt-5">shop.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components i animacji

const fadeIn = keyframes` // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
export const ShopPageContainer = styled.article`  // tworzy komponent ShopPageContainer, który renderuje tag html article z określonymi stylami
  width: 100%;
  animation: 0.2s ${fadeIn};
`;</code></pre>
            </div>
            <div id="idocs_shop_test">
              <h4 class="mt-5">shop.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { mount } from 'enzyme';  // metoda, która ponownie montuje komponent, jeśli nie jest on aktualnie zamontowany. Można to wykorzystać do symulacji komponentu przechodzącego przez cykl życia odmontowania/montowania.
import { combineReducers, createStore } from 'redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { BrowserRouter } from 'react-router-dom';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { Provider } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { ShopPage } from './shop.component';  // import komponentu, który będziemy testować

export const createMockStore = ({ state, reducers }) => {  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
  const store = createStore(combineReducers(reducers), state);
  return {
    ...store,
    persistor: {
      persist: () => null,
    },
  };
};

describe('ShopPage', () => {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu ShopPage
  let wrapper;  // tworzenie zmiennych do testów
  let mockFetchCollectionsStart;
  let store;

  beforeEach(() => {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    const mockReducer = (  // mockowanie propsów przekazanych do ShopPage
      state = {
        isFetching: true,
      },
      action
    ) => state;

    const mockState = {  // mockowanie propsów przekazanych do ShopPage
      shop: {
        isFetching: true,
      },
    };

    mockFetchCollectionsStart = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości

    store = createMockStore({  // zmokowany store
      state: mockState,
      reducers: { shop: mockReducer },
    });

    const mockMatch = {  // zmokowany path do nawigacji
      path: '',
    };

    const mockProps = {  // zmokowanePropsy
      match: mockMatch,
      fetchCollectionsStart: mockFetchCollectionsStart,
    };

    wrapper = mount(  // symuluj montowanie komponentu, montowanie to faza, w której nasz komponent React montuje się na DOM (tj. jest tworzony i wstawiany do DOM).  Ta faza pojawia się na scenie po zakończeniu fazy inicjalizacji. W tej fazie nasz komponent renderuje po raz pierwszy
      <BrowserRouter>  // do nawigacji
        <Provider store={store}>  // nasz store
          <ShopPage {...mockProps} />  // komponent ShopPage z mockowanymi propsami
        </Provider>
      </BrowserRouter>
    );
  });

  it('should render ShopPage component', () => {
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany ShopPage jest zgodny z snapshotem
  });

  it('should call mockFetchCollectionsStart on render', () => {
    expect(mockFetchCollectionsStart).toHaveBeenCalled();  // sprawdź czy funkcje mockFetchCollectionsStart uruchomiła się
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collections_overview
  ============================ -->
          <section id="idocs_collections_overview">
            <h2>collections-overview</h2>
            <div id="idocs_collections_overview_container">
              <h4>collections-overview.container.jsx</h4>
              <p>
                <strong style="color: rgb(0, 0, 255)">CollectionsOverview</strong> zawiera listę <strong
                  style="color: rgb(255, 0, 255)">CollectionPreview</strong>. Można powiedzieć, że jest pewnego rodzaju
                wrapperem.
              </p>
              <p>Dlaczego używamy .container i .component? Container określa dane, które powinien renderować .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu, takich jak
                connect() z Redux. Jest to tzw. Container Pattern. </p>
              <p>
                <a class="popup-img" href="assets/images/collections_overview.png"><img class="img-fluid border"
                    src="assets/images/collections_overview.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { compose } from 'redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { selectIsCollectionFetching } from '../../redux/shop/shop.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import WithSpinner from '../with-spinner/with-spinner.component';  // import komponentu występującego w collections-overview.container
import CollectionsOverview from './collections-overview.component';  // import komponentu występującego w collections-overview.container

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym czy lista produktów się "loadinguje"
  isLoading: selectIsCollectionFetching,
});

const CollectionsOverviewContainer = compose(  // deklaracje komponentu, jeżeli produkty się nie załadowały wyświetlaj obracające się kółko w miejsce komponentu
  connect(mapStateToProps),
  WithSpinner
)(CollectionsOverview);

export default CollectionsOverviewContainer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_collections_overview_component">
              <h4>collections-overview.component.jsx</h4>
              <p>Dlaczego używamy .container i .component? .container określa dane, które powinien renderować
                .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu, takich jak
                connect() z Redux. Jest to tzw. Container Pattern. </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import CollectionPreview from '../collection-preview/collection-preview.component';  // import komponentu występującego w collections-overview.component

import { selectCollectionsForPreview } from '../../redux/shop/shop.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { CollectionsOverviewContainer } from './collections-overview.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionsOverview = ({ collections }) => (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  <CollectionsOverviewContainer>
    {collections.map(({ id, ...otherCollectionProps }) => (  // iteruj po tablicy collections (kategorie produktów, np. womens, mens), dla każdego obiektu wyrenderuj CollectionPreview
      <CollectionPreview key={id} {...otherCollectionProps} />
    ))}
  </CollectionsOverviewContainer>
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o kolekcjach (kategoriach produktów)
  collections: selectCollectionsForPreview,
});

export default connect(mapStateToProps)(CollectionsOverview); // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_collections_overview_styles">
              <h4 class="mt-5">collections-overview.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CollectionsOverviewContainer = styled.article`  // tworzy komponent CollectionsOverviewContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
`;</code></pre>
            </div>
            <div id="idocs_collections_overview_test">
              <h4 class="mt-5">collections-overview.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { CollectionsOverview } from './collections-overview.component';  // import komponentu, który będziemy testować

it('should render CollectionsOverview component', () => {  // wyrenderuj komponent CollectionsOverview
  expect(shallow(<CollectionsOverview collections={[]} />)).toMatchSnapshot();  // sprawdź czy wyrenderowany CartIcon jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collection_preview
  ============================ -->
          <section id="idocs_collection_preview">
            <h2>collection-preview</h2>
            <div id="idocs_collection_preview_component">
              <h4>collection-preview.component.jsx</h4>
              <p><strong style="color: rgb(255, 0, 255)">CollectionPreview</strong> wyświetla tytuł oraz 4 pierwsze
                produkty z danej kolekcji, jaką otrzyma w propsach.
                Pojedynczy produkt jest wyrenderowany za pomocą komponentu <strong
                  style="color: rgb(0, 255, 0)">CollectionItem</strong>.
              </p>
              <p>
                <a class="popup-img" href="assets/images/collection_preview.png"><img class="img-fluid border"
                    src="assets/images/collection_preview.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { withRouter } from 'react-router-dom';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import CollectionItem from '../collection-item/collection-item.component';  // import komponentu występującego w CollectionPreview

import {
  CollectionPreviewContainer,
  TitleContainer,
  PreviewContainer,
} from './collection-preview.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionPreview = ({
  title,
  items,
  history,
  match,
  routeName,
}) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CollectionPreviewContainer&gt;
    &lt;TitleContainer onClick={() =&gt; history.push(`${match.path}/${routeName}`)}&gt;  // po kliknięciu na tytuł przekieruj użytkownika na oddzielną podstronę kolekcji
      {title.toUpperCase()}  // tytuł kolekcji np. womens
    &lt;/TitleContainer&gt;
    &lt;PreviewContainer&gt;
      {items  // items zawiera pojedyncze produkty kolekcji wyrenderuj komponent CollectionItem
        .filter((item, idx) =&gt; idx &lt; 4)  // wyświetl 4 pierwsze produkty
        .map((item) =&gt; (
          &lt;CollectionItem key={item.id} item={item} /&gt;  // dla 4 pierwszych produktów wyrenderuj komponent CollectionItem
        ))}
    &lt;/PreviewContainer&gt;
  &lt;/CollectionPreviewContainer&gt;
);

export default withRouter(CollectionPreview);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_collection_preview_styles">
              <h4 class="mt-5">collection-preview.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CollectionPreviewContainer = styled.article`  // tworzy komponent CollectionPreviewContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
  margin-bottom: 10px;

  @media screen and (max-width: 800px) {
    align-items: center;
  }
`;

export const TitleContainer = styled.h1`  // tworzy komponent TitleContainer, który renderuje tag html h1 z określonymi stylami
  font-size: 28px;
  margin-bottom: 25px;
  cursor: pointer;

  &amp;:hover {
    color: #e08800;
  }
`;

TitleContainer.displayName = 'TitleContainer';  // po zrenderowaniu w DevTools komponent TitleContainer wyświetlał by się jako styled.h1, ale po zmianie parametru displayName wyświetli się jako TitleContainer co ułatwi debugowanie

export const PreviewContainer = styled.div`  // tworzy komponent PreviewContainer, który renderuje tag html div z określonymi stylami
  display: flex;
  justify-content: space-between;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    display: grid;
    grid-template-columns: 250px 250px;
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    grid-template-columns: 250px;
  }
`;</code></pre>
            </div>
            <div id="idocs_collection_preview_test">
              <h4 class="mt-5">collection-preview.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CollectionPreview } from './collection-preview.component';  // import komponentu, który będziemy testować

describe('CollectionPreview component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CollectionPreview
let wrapper;  // tworzenie zmiennych do testów
let mockMatch;
let mockHistory;
const mockRouteName = 'hats';

beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
  mockMatch = {
    path: '/shop',
  };

  mockHistory = {
    push: jest.fn(),  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
  };

  const mockProps = {  // mockowanie propsów przekazanych do CollectionPreview
    match: mockMatch,
    history: mockHistory,
    routeName: mockRouteName,
    title: 'hats',
    items: [],
  };

  wrapper = shallow(&lt;CollectionPreview {...mockProps} /&gt;);  // wyrenderuj komponent CollectionPreview z propsami wyżej
});

it('should render CollectionPreview component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CollectionPreview
  expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CollectionPreview jest zgodny z snapshotem
});

it('should call history.push with the right string when TitleContainer clicked', () =&gt; {  // jeżeli tytuł kolekcji zostanie kliknięty, przekieruj użytkownika na stronę tej kolekcji
  wrapper.find('TitleContainer').simulate('click');  // symuluj kliknięcie

  expect(mockHistory.push).toHaveBeenCalledWith(
    `${mockMatch.path}/${mockRouteName}`  // sprawdz czy url się zmienił
  );
});
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collection_item
  ============================ -->
          <section id="idocs_collection_item">
            <h2>collection-item</h2>
            <div id="idocs_collection_item_component">
              <h4>collection-item.component.jsx</h4>
              <p>CollectionItem wyświetla zdjęcie produktu, nazwę i cenę na podstawie otrzymanych propsów. Używany jest
                w
                wielu komponentach.</p>
              <p>
                <a class="popup-img" href="assets/images/collection_item.png"><img class="img-fluid border"
                    src="assets/images/collection_item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
  
import { addItem } from '../../redux/cart/cart.actions';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CollectionItemContainer,
  CollectionFooterContainer,
  AddButton,
  BackgroundImage,
  NameContainer,
  PriceContainer,
} from './collection-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionItem = ({ item, addItem }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { name, price, imageUrl } = item;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

  return (
    &lt;CollectionItemContainer&gt;
      &lt;BackgroundImage className=&quot;image&quot; imageUrl={imageUrl} /&gt;  // zdjęcie produktu
      &lt;CollectionFooterContainer&gt;
        &lt;NameContainer&gt;{name}&lt;/NameContainer&gt;  // nazwa
        &lt;PriceContainer&gt;{price}&lt;/PriceContainer&gt;  // cena
      &lt;/CollectionFooterContainer&gt;
      &lt;AddButton onClick={() =&gt; addItem(item)} inverted&gt;  // po kliknięciu dodaje produkt do koszyka
        Add to cart
      &lt;/AddButton&gt;
    &lt;/CollectionItemContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik kliknie na przycisk Add to cart, w store zmieni się stan koszyka reprezentujący ilość produktów
  addItem: (item) =&gt; dispatch(addItem(item)),
});

export default connect(null, mapDispatchToProps)(CollectionItem);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_collection_item_styles">
              <h4 class="mt-5">collection-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w Collectionitem (przycisk Add to cart)

export const CollectionItemContainer = styled.article`  // tworzy komponent CollectionItemContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 400px;
  height: 550px;
  align-items: center;
  position: relative;
  margin-bottom: 20px;

  &amp;:hover {  // przy najechaniu myszką na komponent CollectionItemContainer, aktywują się style poniżej
    .image {
      opacity: 0.8;
    }

    button {
      opacity: 0.85;
      display: flex;
    }

    div {
      color: #e08800;
    }
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    max-width: 400px;
    &amp;:hover {
      .image {
        opacity: unset;
      }
      button {
        opacity: unset;
      }
    }
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    max-width: 500px;
  }
`;

export const AddButton = styled(CustomButton)`  // tworzy komponent AddButton, który renderuje się na podstawie komponentu CustomButton z określonymi stylami
  width: 80%;
  opacity: 0.7;
  position: absolute;
  top: 450px;
  display: none;
 
  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    display: block;
    opacity: 0.9;
    min-width: unset;
    padding: 0 10px;
  }
`;

AddButton.displayName = 'AddButton';  // po zrenderowaniu w DevTools komponent AddButton wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako AddButton co ułatwi debugowanie

export const BackgroundImage = styled.div`  // tworzy komponent BackgroundImage, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 95%;
  background-size: cover;
  background-position: center;
  margin-bottom: 5px;
  background-image: ${({ imageUrl }) =&gt; `url(${imageUrl})`};
`;

BackgroundImage.displayName = 'BackgroundImage';  // po zrenderowaniu w DevTools komponent BackgroundImage wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako BackgroundImage co ułatwi debugowanie

export const CollectionFooterContainer = styled.div`  // tworzy komponent CollectionFooterContainer, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 5%;
  display: flex;
  justify-content: space-between;
  font-size: 18px;
`;

CollectionFooterContainer.displayName = 'CollectionFooterContainer';  // po zrenderowaniu w DevTools komponent CollectionFooterContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako CollectionFooterContainer co ułatwi debugowanie

export const NameContainer = styled.span`  // tworzy komponent NameContainer, który renderuje tag html span z określonymi stylami
  width: 90%;
  margin-bottom: 15px;
`;

NameContainer.displayName = 'NameContainer';  // po zrenderowaniu w DevTools komponent NameContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako NameContainer co ułatwi debugowanie

export const PriceContainer = styled.span`  // tworzy komponent PriceContainer, który renderuje tag html span z określonymi stylami
  width: 10%;
  text-align: right;
`;

PriceContainer.displayName = 'PriceContainer';  // po zrenderowaniu w DevTools komponent PriceContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako PriceContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_collection_item_test">
              <h4 class="mt-5">collection-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CollectionItem } from './collection-item.component';  // import komponentu, który będziemy testować

describe('CollectionItem component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CollectionItem
  let wrapper;  // tworzenie zmiennych do testów
  let mockAddItem;
  const imageUrl = 'www.testImage.com';
  const mockName = 'black hat';
  const mockPrice = 10;
 
  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockAddItem = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {  // mockowanie propsów przekazanych do CollectionItem
      item: {
        imageUrl: imageUrl,
        price: mockPrice,
        name: mockName,
      },
      addItem: mockAddItem,
    };

    wrapper = shallow(&lt;CollectionItem {...mockProps} /&gt;);  // wyrenderuj komponent CollectionItem z propsami wyżej
  });

  it('should render CollectionItem component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CollectionItem
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CollectionItem jest zgodny z snapshotem
  });

  it('should call addItem when AddButton clicked', () =&gt; {  // po kliknięciu na Add to cart, wywołaj funkcję dodania produktu do stanu
    wrapper.find('AddButton').simulate('click');  // symuluj kliknięcie

    expect(mockAddItem).toHaveBeenCalled();  // jeżeli przycisk został kliknięty funkcja mockAddItem powinna zostać wywołana
  });

  it('should render imageUrl as a prop on BackgroundImage', () =&gt; {  // sprawdź czy zdjęcie produktu wyrenderowało się prawidłowo
    expect(wrapper.find('BackgroundImage').prop('imageUrl')).toBe(imageUrl);
  });

  it('should render name prop in NameContainer', () =&gt; {  // sprawdź czy nazwa produktu wyrenderowała się prawidłowo
    expect(wrapper.find('NameContainer').text()).toBe(mockName);
  });

  it('should render price prop in PriceContainer', () =&gt; {  // sprawdź czy cena produktu wyrenderowała się prawidłowo
    const price = parseInt(wrapper.find('PriceContainer').text());
    expect(price).toBe(mockPrice);
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- custom_button
  ============================ -->
          <section id="idocs_custom_button">
            <h2>custom-button</h2>
            <div id="idocs_custom_button_component">
              <h4>custom-button.component.jsx</h4>
              <p>CustomButton to komponent przedstawiający przycisk. Używany w wielu komponentach, aby nie powtarzać
                styli. Dzięki styled components można warunkowo zmieniać np. kolor tła przycisku, a za pomocą propsów
                tekst na przycisku.</p>
              <p>
                <a class="popup-img" href="assets/images/custom_button.png"><img class="img-fluid border"
                    src="assets/images/custom_button.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import { CustomButtonContainer } from './custom-button.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CustomButton = ({ children, ...props }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CustomButtonContainer {...props}&gt;{children}&lt;/CustomButtonContainer&gt;
);

export default CustomButton;  // funkcja do obsługi Redux (omówione w oddzielnym dziale)</code></pre>
            </div>
            <div id="idocs_custom_button_styles">
              <h4 class="mt-5">custom-button.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { css } from 'styled-components';  // import biblioteki styled components

const buttonStyles = css`  // określa grupę atrybutów css, nie renderuje tagu html sam w sobie
  background-color: #e08800;
  color: white;
  border: 1px solid transparent;

  &amp;:hover {
    background-color: white;
    color: #e08800;
    border: 1px solid #e08800;
  }
`;

const invertedButtonStyles = css`  // określa grupę atrybutów css, nie renderuje tagu html sam w sobie
  background-color: white;
  color: black;
  border: 1px solid black;

  &amp;:hover {
    background-color: #e08800;
    color: white;
    border: 1px solid transparent;
  }
`;


const getButtonStyles = (props) =&gt; {  // przycisk zostanie wyrenderowany z określonymi stylami
  return props.inverted ? invertedButtonStyles : buttonStyles;  // jeżeli do CustomButton przekażemy props inverted, przycisk zostanie wyrenderowany ze stylami z grupy invertedButtonStyles powyżej, jeżeli nie to użyje grupy buttonStyles
};

export const CustomButtonContainer = styled.button`  // tworzy komponent CustomButtonContainer, który renderuje tag html button z określonymi stylami
  min-width: 165px;
  width: auto;
  height: 50px;
  letter-spacing: 0.5px;
  line-height: 50px;
  padding: 0 35px 0 35px;
  font-size: 15px;
  text-transform: uppercase;
  font-weight: bolder;
  cursor: pointer;
  display: flex;
  justify-content: center;

  ${getButtonStyles}  // do cssa powyżej dodaj kod funkcję getButtonStyles, która na podstawie różnych warunków może dodać tutaj więcej cssa
`;</code></pre>
            </div>
            <div id="idocs_custom_button_test">
              <h4 class="mt-5">custom-button.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { CustomButton } from './custom-button.component';  // import komponentu, który będziemy testować

it('should render CustomButton component', () => {  // wyrenderuj komponent CustomButton
  expect(shallow(<CustomButton />)).toMatchSnapshot();  // sprawdź czy wyrenderowany CustomButton jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- with_spinner
  ============================ -->
          <section id="idocs_with_spinner">
            <h2>with-spinner</h2>
            <div id="idocs_with_spinner_component">
              <h4>with-spinner.component.jsx</h4>
              <p>WithSpinner generuje się "w miejscu" komponentu, który czeka na np. otrzymanie informacji z bazy
                danych. Przyjmuje formę obracającego się kółka. Ma to zapobiec wrażeniu, że strona nie działa prawidłowo
                i dać znać użytkownikowi, że coś się ładuje i trzeba poczekać.</p>
              <p>
                <a class="popup-img" href="assets/images/with_spinner.png"><img class="img-fluid border"
                    src="assets/images/with_spinner.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import Spinner from '../spinner/spinner.component';  // import komponentu występującego w WithSpinner

const WithSpinner =  
  (WrappedComponent) =&gt;  
  ({ isLoading, ...otherProps }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
    return isLoading ? &lt;Spinner /&gt; : &lt;WrappedComponent {...otherProps} /&gt;;  // jeżeli komponent się "ładuje" wyświetl kręcące się kółko
  };

export default WithSpinner;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_with_spinner_test">
              <h4 class="mt-5">with-spinner.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import WithSpinner from './with-spinner.component';  // import komponentu, który będziemy testować
import Spinner from '../spinner/spinner.component';  // import komponentu, występującego w WithSpinner

describe('WithSpinner HOC', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu WithSpinner
  const TestComponent = () =&gt; &lt;div className=&quot;test&quot; /&gt;;  // tworzenie zmiennych do testów
  const WrappedComponent = WithSpinner(TestComponent);  // komponent TestComponent jest "zawinięty" w komponent WithSpinner

  describe('if loading is true', () =&gt; {  // jeżeli komponent jest w trakcie ładowania
    it('should render Spinner component', () =&gt; {  // wyrenderuj kręcący się spinner
      const wrapper = shallow(&lt;WrappedComponent isLoading={true} /&gt;);

      expect(wrapper.exists(Spinner)).toBe(true);  // sprawdź czy w DOMie istnieje spinner
    });

    it('should not render component', () =&gt; {  // nie powinien wyrenderować komponentu
      const wrapper = shallow(&lt;WrappedComponent isLoading={true} /&gt;);  // komponent NIE powinien się wyrenderować

      expect(wrapper.exists(TestComponent)).toBe(false);  // sprawdź czy w DOMie istnieje komponent
    });
  });

  describe('if loading is false', () =&gt; {  // jeżeli komponent nie jest w trakcie ładowania
    it('should render component', () =&gt; {  // wyrenderuj komponent
      const wrapper = shallow(&lt;WrappedComponent isLoading={false} /&gt;);

      expect(wrapper.exists(TestComponent)).toBe(true);  // sprawdź czy w DOMie istnieje komponent
    });

    it('should not render Spinner', () =&gt; {  // nie powinien wyrenderować kręcącego się spinnera
      const wrapper = shallow(&lt;WrappedComponent isLoading={false} /&gt;);

      expect(wrapper.exists(Spinner)).toBe(false);  // sprawdź czy w DOMie istnieje spinner
    });
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- spinner
  ============================ -->
          <section id="idocs_spinner">
            <h2>spinner</h2>
            <div id="idocs_spinner_component">
              <h4>spinner.component.jsx</h4>
              <p>Spinner przedstawia kręcące się kółko.</p>
              <p>
                <a class="popup-img" href="assets/images/spinner.png"><img class="img-fluid border"
                    src="assets/images/spinner.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import { SpinnerContainer, SpinnerOverlay } from './spinner.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const Spinner = () =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;SpinnerOverlay&gt;
    &lt;SpinnerContainer /&gt;
  &lt;/SpinnerOverlay&gt;
);

export default Spinner;  // eksport komponentu, aby mógł być zaimportowany</code></pre>
            </div>
            <div id="idocs_spinner_styles">
              <h4 class="mt-5">spinner.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const SpinnerOverlay = styled.div`  // tworzy komponent SpinnerOverlay, który renderuje tag html div z określonymi stylami
  height: 60vh;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`;

export const SpinnerContainer = styled.div`  // tworzy komponent SpinnerContainer, który renderuje tag html div z określonymi stylami
  display: inline-block;
  width: 50px;
  height: 50px;
  border: 3px solid rgba(195, 195, 195, 0.6);
  border-radius: 50%;
  border-top-color: #636767;
  animation: spin 1s ease-in-out infinite;
  -webkit-animation: spin 1s ease-in-out infinite;

  @keyframes spin {  // animacja obracania się do spinnera
    to {
      -webkit-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spin {  // animacja obracania się do spinnera
    to {
      -webkit-transform: rotate(360deg);
    }
  }
`;</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collection
  ============================ -->
          <section id="idocs_collection">
            <h2>collection</h2>
            <div id="idocs_collection_container">
              <h4>collection.container.jsx</h4>
              <!--<p class="lead mb-4">
                Przykład strony collection:<br />
                <a href="https://zadanie-na-uczelnie.pl/shop/womens"
                  target="_blank">https://zadanie-na-uczelnie.pl/shop/womens</a>
              </p>-->
              <p>
                Komponent collection przedstawia produkty z wybranej kategorii np. womens. Zawiera logo, nawigację i
                kafelki z produktami i stopkę z autorem.
              </p>
              <p>
                Dlaczego używamy .container i .component? Container określa dane, które powinien renderować .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu, takich jak
                connect() z Redux. Jest to tzw. Container Pattern.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(255, 0, 255)">Collection</strong>
                znajdują się <strong style="color: rgb(0, 0, 255)">MenuItem</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/collection.png"><img class="img-fluid border"
                    src="assets/images/collection.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { compose } from 'redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { selectIsCollectionsLoaded } from '../../redux/shop/shop.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import WithSpinner from '../../components/with-spinner/with-spinner.component';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import CollectionPage from './collection.component';  // import komponentu występującego w collection.container

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym czy kolekcja się ładuje
  isLoading: (state) =&gt; !selectIsCollectionsLoaded(state),
});

const CollectionPageContainer = compose(   // deklaracje komponentu, jeżeli produkty się nie załadowały wyświetlaj obracające się kółko w miejsce komponentu
  connect(mapStateToProps),
  WithSpinner
)(CollectionPage);

export default CollectionPageContainer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_collection_component">
              <h4>collection.component.jsx</h4>
              <p>
                Dlaczego używamy .container i .component? Container określa dane, które powinien renderować .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu, takich jak
                connect() z Redux. Jest to tzw. Container Pattern.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import CollectionItem from '../../components/collection-item/collection-item.component';  // import komponentu występującego w CollectionItem
import { selectCollection } from '../../redux/shop/shop.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CollectionPageContainer,
  CollectionTitle,
  CollectionItemsContainer,
} from './collection.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionPage = ({ collection }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { title, items } = collection;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych
  return (
    &lt;CollectionPageContainer&gt;
      &lt;CollectionTitle&gt;{title}&lt;/CollectionTitle&gt;
      &lt;CollectionItemsContainer&gt;
        {items.map((item) =&gt; (  // iteruj przez zmienną items
          &lt;CollectionItem key={item.id} item={item} /&gt;  // dla każdej zmiennej w items wyrenderuj komponent CollectionItem
        ))}
      &lt;/CollectionItemsContainer&gt;
    &lt;/CollectionPageContainer&gt;
  );
};

const mapStateToProps = (state, ownProps) =&gt; ({  // przekazuje ze store do props informacje o tym, którą kolekcję wyrenderować (czy womens czy mens itd)
  collection: selectCollection(ownProps.match.params.collectionId)(state),
});

export default connect(mapStateToProps)(CollectionPage);  // łączy komponent React ze store Redux. </code></pre>
            </div>
            <div id="idocs_collection_styles">
              <h4 class="mt-5">collection.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>

              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

export const CollectionPageContainer = styled.article`  // tworzy komponent CollectionPageContainer, który renderuje tag html article z określonymi stylami
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
`;

export const CollectionTitle = styled.h2`  // tworzy komponent CollectionTitle, który renderuje tag html h2 z określonymi stylami
  font-size: 38px;
  margin: 0 auto 30px;
  text-transform: uppercase;
`;

export const CollectionItemsContainer = styled.div`  // tworzy komponent CollectionItemsContainer, który renderuje tag html div z określonymi stylami
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 10px;
  width: 1300px;

  & > div {  // style dla divów znajdujących się w CollectionItemsContainer
    margin-bottom: 30px;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    grid-template-columns: 1fr 1fr;
    grid-gap: 15px;
  }

  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    grid-template-columns: 1fr !important;
  }
`;

CollectionItemsContainer.displayName = 'CollectionItemsContainer';  // po zrenderowaniu w DevTools komponent CollectionItemsContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako CollectionItemsContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_collection_test">
              <h4 class="mt-5">collection.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CollectionPage } from './collection.component';  // import komponentu, który będziemy testować
import CollectionItem from '../../components/collection-item/collection-item.component';  // import komponentu, który występuje w CollectionPage

describe('CollectionPage', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CollectionPage
  let wrapper;  // tworzenie zmiennych do testów
  let mockItems = [{ id: 1 }, { id: 2 }, { id: 3 }];
  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    const mockCollection = {  // mockowanie propsów przekazanych do Collection
      items: mockItems,
      title: 'Test',
    };

    wrapper = shallow(&lt;CollectionPage collection={mockCollection} /&gt;);  // wyrenderuj komponent Collection z propsami wyżej
  });

  it('should render the Collectione component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent Collection
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany Collection jest zgodny z snapshotem
  });

  it('should render the same number of CollectionItems as collection array', () =&gt; {  // sprawdź czy komponent CollectionItems renderuje się prawidłowo
    expect(wrapper.find(CollectionItem).length).toBe(mockItems.length);
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- checkout
  ============================ -->
          <section id="idocs_checkout">
            <h2>checkout</h2>
            <div id="idocs_checkout_component">
              <h4>checkout.component.jsx</h4>
              <!--<p class="lead mb-4">
                Strona Checkout znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/checkout"
                  target="_blank">https://zadanie-na-uczelnie.pl/checkout</a>
              </p>-->
              <p>
                Komponent Checkout przedstawia podsumowanie tego co znajduje się w koszyku. Daje możliwość zmiany ilości
                sztuk produktów i złożenia zamówienia.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">Checkout</strong>
                znajdują się <strong style="color: rgb(255, 0, 255)">CheckoutItem</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/checkout.png"><img class="img-fluid border"
                    src="assets/images/checkout.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)
import { createStructuredSelector } from 'reselect';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import StripeCheckoutButton from '../../components/stripe-button/stripe-button.component';  // import komponentu występującego w Checkout
import CheckoutItem from '../../components/checkout-item/checkout-item.component';  // import komponentu występującego w Checkout

import {
  selectCartItems,
  selectCartTotal,
} from '../../redux/cart/cart.selectors';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CheckoutPageContainer,
  CheckoutHeaderContainer,
  HeaderBlockContainer,
  TotalContainer,
  WarningContainer,
} from './checkout.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CheckoutPage = ({ cartItems, total }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CheckoutPageContainer&gt;
    &lt;CheckoutHeaderContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Product&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Description&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Quantity&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Price&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Remove&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
    &lt;/CheckoutHeaderContainer&gt;
    {cartItems.map((cartItem) =&gt; (  // iteruj po zmiennej cartItems przechowującą informacje o produktach dodanych do koszyka
      &lt;CheckoutItem key={cartItem.id} cartItem={cartItem} /&gt;  // dla każdego produktu wyrenderuj kompontn CheckoutItem
    ))}
    &lt;TotalContainer&gt;TOTAL: ${total}&lt;/TotalContainer&gt;  // całkowity koszt wszystkich produktów w koszyku
    &lt;WarningContainer&gt;
      *Please use the following test credit card for payments*
      &lt;br /&gt;
      4242 4242 4242 4242 - Exp: 01/22 - CVV: 123
    &lt;/WarningContainer&gt;
    &lt;StripeCheckoutButton price={total} /&gt;  // przycisk Pay Now z zewnętrznej biblioteki Stripe
  &lt;/CheckoutPageContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile produktów znajduje się w koszyku oraz cenę za wszystkie produkty
  cartItems: selectCartItems,
  total: selectCartTotal,
});

export default connect(mapStateToProps)(CheckoutPage);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_checkout_styles">
              <h4 class="mt-5">checkout.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

export const CheckoutPageContainer = styled.article`  // tworzy komponent CheckoutPageContainer, który renderuje tag html article z określonymi stylami
  animation: 0.2s ${fadeIn};
  width: 55%;
  min-height: 90vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 50px auto 0;

  button {  // te style będą dotyczyć tylko buttonów w środku CheckoutPageContainer
    margin-left: auto;
    margin-top: 50px;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 90%;
  }
`;

export const CheckoutHeaderContainer = styled.div`  // tworzy komponent CheckoutHeaderContainer, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 40px;
  display: flex;
  justify-content: space-between;
  border-bottom: 1px solid darkgrey;
`;

export const HeaderBlockContainer = styled.div`  // tworzy komponent HeaderBlockContainer, który renderuje tag html div z określonymi stylami
  text-transform: capitalize;
  width: 23%;

  &amp;:last-child {  // te style będą dotyczyć ostatniego dziecka w HeaderBlockContainer
    width: 8%;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 22%;

    &amp;:last-child {  // te style będą dotyczyć ostatniego dziecka w HeaderBlockContainer
      width: 12%;
    }
  }
`;

export const TotalContainer = styled.div`  // tworzy komponent TotalContainer, który renderuje tag html div z określonymi stylami
  margin-top: 30px;
  margin-left: auto;
  font-size: 36px;
`;

export const WarningContainer = styled.div`  // tworzy komponent WarningContainer, który renderuje tag html div z określonymi stylami
  text-align: center;
  margin-top: 40px;
  font-size: 24px;
  color: #e08800;
`;</code></pre>
            </div>
            <div id="idocs_checkout_test">
              <h4 class="mt-5">checkout.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { CheckoutPage } from './checkout.component';  // import komponentu, który będziemy testować

let wrapper;  // tworzenie zmiennych do testów
beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
  const mockProps = {  // mockowanie propsów przekazanych do CheckoutPage
    cartItems: [],
    total: 100,
  };

  wrapper = shallow(&lt;CheckoutPage {...mockProps} /&gt;);  // wyrenderuj komponent CheckoutPage z propsami wyżej
});

it('should render CheckoutPage component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CheckoutPage
  expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CheckoutPage jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- checkout-item
  ============================ -->
          <section id="idocs_checkout_item">
            <h2>checkout-item</h2>
            <div id="idocs_checkout_item_component">
              <h4>checkout-item.component.jsx</h4>
              <p>CheckoutItem odzwierciedla pojedynczy produkt na stronie checkout. Wyświetla zdjęcie produktu, nazwę,
                cenę. Pozwala na zmianę ilości sztuk lub usunięcie produktu ze strony checkout i koszyka.</p>
              <p>
                <a class="popup-img" href="assets/images/checkout_item.png"><img class="img-fluid border"
                    src="assets/images/checkout_item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

import {
  clearItemFromCart,
  addItem,
  removeItem,
} from '../../redux/cart/cart.actions';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  CheckoutItemContainer,
  ImageContainer,
  TextContainer,
  QuantityContainer,
  RemoveButtonContainer,
} from './checkout-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CheckoutItem = ({ cartItem, clearItem, addItem, removeItem }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { name, imageUrl, price, quantity } = cartItem;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych
  return (
    &lt;CheckoutItemContainer&gt;
      &lt;ImageContainer&gt;
        &lt;img src={imageUrl} alt=&quot;item&quot; /&gt;  // zdjęcie produktu
      &lt;/ImageContainer&gt;
      &lt;TextContainer&gt;{name}&lt;/TextContainer&gt;
      &lt;QuantityContainer&gt;
        &lt;div onClick={() =&gt; removeItem(cartItem)}&gt;&amp;#10094;&lt;/div&gt;  // strzałka w lewo - zmień ilość sztuk produktu: -1
        &lt;span&gt;{quantity}&lt;/span&gt;   // ilość sztuk produktu
        &lt;div onClick={() =&gt; addItem(cartItem)}&gt;&amp;#10095;&lt;/div&gt;  // strzałka w prawo - zmień ilość sztuk produktu: +1
      &lt;/QuantityContainer&gt;
      &lt;TextContainer&gt;{price}&lt;/TextContainer&gt;
      &lt;RemoveButtonContainer onClick={() =&gt; clearItem(cartItem)}&gt;  // usuń z koszyka produkt
        &amp;#10005;
      &lt;/RemoveButtonContainer&gt;
    &lt;/CheckoutItemContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  
  clearItem: (item) =&gt; dispatch(clearItemFromCart(item)),  // usuń produkt ze stanu store, czyli usuń produkt z koszyka
  addItem: (item) =&gt; dispatch(addItem(item)),  // dodaj produkt ze stanu store, czyli zwiększ ilość sztuk produktu o 1
  removeItem: (item) =&gt; dispatch(removeItem(item)),  // zabierz produkt ze stanu store, czyli zmniejsz ilość sztuk produktu o 1
});

export default connect(null, mapDispatchToProps)(CheckoutItem);  // łączy komponent React ze store Redux. </code></pre>
            </div>
            <div id="idocs_checkout_item_styles">
              <h4 class="mt-5">checkout-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CheckoutItemContainer = styled.section`  // tworzy komponent CheckoutItemContainer, który renderuje tag html section z określonymi stylami
  width: 100%;
  display: flex;
  min-height: 100px;
  border-bottom: 1px solid darkgrey;
  padding: 15px 0;
  font-size: 20px;
  align-items: center;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    font-size: 18px;
  }
`;

export const ImageContainer = styled.div`  // tworzy komponent ImageContainer, który renderuje tag html div z określonymi stylami
  width: 23%;
  padding-right: 15px;

  img {  // style poniżej będą dotyczyć tagów img w komponencie ImageContainer
    width: 100%;
    height: 100%;
  }
`;

export const TextContainer = styled.span`  // tworzy komponent TextContainer, który renderuje tag html span z określonymi stylami
  width: 23%;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 22%;
  }
`;

export const QuantityContainer = styled(TextContainer)`  // tworzy komponent QuantityContainer, który renderuje komponent TextContainer z określonymi stylami
  display: flex;

  span {   // style poniżej będą dotyczyć tagów span w komponencie QuantityContainer
    margin: 0 10px;
    color: black;
  }

  div {  // style poniżej będą dotyczyć tagów div w komponencie QuantityContainer
    cursor: pointer;
  }

  &amp;:hover {  // style zadziałają przy najechaniu na myszą na komponent
    color: #e08800;
  }
`;

QuantityContainer.displayName = 'QuantityContainer';  // po zrenderowaniu w DevTools komponent QuantityContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako QuantityContainer co ułatwi debugowanie

export const RemoveButtonContainer = styled.div`  // tworzy komponent RemoveButtonContainer, który renderuje tag html div z określonymi stylami
  padding-left: 12px;
  cursor: pointer;

  &amp;:hover {  // style zadziałają przy najechaniu na myszą na komponent
    color: #e08800;
  }
`;

RemoveButtonContainer.displayName = 'RemoveButtonContainer';  // po zrenderowaniu w DevTools komponent RemoveButtonContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako RemoveButtonContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_checkout_item_test">
              <h4 class="mt-5">checkout-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CheckoutItem } from './checkout-item.component';  // import komponentu, który będziemy testować

describe('CheckoutItem component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CheckoutItem
  let wrapper;  // tworzenie zmiennych do testów
  let mockClearItem; 
  let mockAddItem;
  let mockRemoveItem;

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockClearItem = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
    mockAddItem = jest.fn();
    mockRemoveItem = jest.fn();

    const mockProps = {  // mockowanie propsów przekazanych do CheckoutItem
      cartItem: {
        imageUrl: 'www.testImage.com',
        price: 10,
        name: 'hats',
        quantity: 2,
      },
      clearItem: mockClearItem,
      addItem: mockAddItem,
      removeItem: mockRemoveItem,
    };

    wrapper = shallow(&lt;CheckoutItem {...mockProps} /&gt;);  // wyrenderuj komponent CheckoutItem z propsami wyżej
  });

  it('should render CheckoutItem component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CheckoutItem
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CheckoutItem jest zgodny z snapshotem
  });

  it('should call clearItem when remove button is clicked', () =&gt; {  // przy kliknięciu X usuń produkt z koszyka
    wrapper.find('RemoveButtonContainer').simulate('click');  // znajdz przycisk do usuwania
    expect(mockClearItem).toHaveBeenCalled();  // sprawdz czy funkcja do usuwania została wywołana
  });

  it('should call removeItem when left arrow is clicked', () =&gt; {  // przy kliknięciu &lt; zmniejsz ilość produktu z koszyka
    wrapper.find('QuantityContainer').childAt(0).simulate('click');

    expect(mockRemoveItem).toHaveBeenCalled();x
  });

  it('should call addItem when right arrow is clicked', () =&gt; {  // przy kliknięciu &gt; zmniejsz ilość produktu z koszyka
    wrapper.find('QuantityContainer').childAt(2).simulate('click');

    expect(mockAddItem).toHaveBeenCalled();
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- stripe-button
  ============================ -->
          <section id="idocs_stripe_button">
            <h2>stripe-button</h2>
            <div id="idocs_stripe_button_component">
              <h4>stripe-button.component.jsx</h4>
              <p><strong>StripeButton znajduje się na stronie Checkout.</strong> Po kliknięciu na Pay Now otwiera
                formularz z zewnętrznej
                biblioteki react-stripe-checkout.</p>
              <p>
                <a class="popup-img" href="assets/images/stripe_button.png"><img class="img-fluid border"
                    src="assets/images/stripe_button.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  
import StripeCheckout from 'react-stripe-checkout';
import axios from 'axios';

const StripeCheckoutButton = ({ price }) =&gt; {
  const priceForStripe = price * 100;
  const publishableKey =
    'pk_test_51HsBj7E1gngEBdOJAeecjW1trv6PA2Z3oHhxYuBOkpWxt0jBggVN23iXi7mSSaB7HduB4kypr4zg9JOoIwhwIaVc00cNXUeKBl';

  const onToken = (token) =&gt; {
    axios({
      url: 'payment',
      method: 'post',
      data: {
        amount: priceForStripe,
        token: token,
      },
    })
      .then((response) =&gt; {
        alert('succesful payment');
      })
      .catch((error) =&gt; {
        console.log('Payment Error: ', JSON.parse(error));
        alert(
          'There was an issue with your payment! Please make sure you use the provided credit card.'
        );
      });
  };

  return (
    &lt;StripeCheckout
      label=&quot;Pay Now&quot;
      name=&quot;Ingrid Ltd.&quot;
      billingAddress
      shippingAddress
      image=&quot;https://sendeyo.com/up/d/f3eb2117da&quot;
      description={`Your total is $${price}`}
      amount={priceForStripe}
      panelLabel=&quot;Pay Now&quot;
      token={onToken}
      stripeKey={publishableKey}
    /&gt;
  );
};

export default StripeCheckoutButton;</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- sign_in_and_sign_up_page
  ============================ -->
          <section id="idocs_sign_in_and_sign_up_page">
            <h2>sign-in-and-sign-up-page</h2>
            <div id="idocs_sign_in_and_sign_up_page_component">
              <h4>sign-in-and-sign-up-page.component.jsx</h4>
              <p>opis</p>
              <p>
                <a class="popup-img" href="assets/images/sign_in_and_sign_up_page.png"><img class="img-fluid border"
                    src="assets/images/sign_in_and_sign_up_page.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import SignIn from '../../components/sign-in/sign-in.component';  // import komponentu występującego w SignInAndSignUpPage
import SignUp from '../../components/sign-up/sign-up.component';  // import komponentu występującego w SignInAndSignUpPage

import { SignInAndSignUpContainer } from './sign-in-and-sign-up.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const SignInAndSignUpPage = () =&gt; (  // deklaracja komponentu funkcyjnego
  &lt;SignInAndSignUpContainer&gt;
    &lt;SignIn /&gt;
    &lt;SignUp /&gt;
  &lt;/SignInAndSignUpContainer&gt;
);

export default SignInAndSignUpPage;  // export funkcji, aby mogła być zaimportowana w innym komponencie</code></pre>
            </div>
            <div id="idocs_sign_in_and_sign_up_page_styles">
              <h4 class="mt-5">sign-in-and-sign-up-page.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
export const SignInAndSignUpContainer = styled.article`  // tworzy komponent SignInAndSignUpContainer, który renderuje tag html article z określonymi stylami
  width: 850px;
  display: flex;
  justify-content: space-between;
  margin: 30px auto;
  padding: 0 20px;
  animation: 0.2s ${fadeIn};

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    flex-direction: column;
    width: unset;
    align-items: center;

    &gt; *:first-child {  // te style dotyczą pierwszego dziecko w komponencie SignInAndSignUpContainer
      margin-bottom: 50px;
    }
  }

  @media screen and (max-width: 460px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 460px
    padding: 0 10px;
  }
`;</code></pre>
            </div>
            <div id="idocs_sign_in_and_sign_up_page_test">
              <h4 class="mt-5">sign-in-and-sign-up-page.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import SignInAndSignUpPage from './sign-in-and-sign-up.component';  // import komponentu, który będziemy testować

it('should render SignInAndSignUpPage component', () =&gt; {  // wyrenderuj komponent SignInAndSignUpPage
  expect(shallow(&lt;SignInAndSignUpPage /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany SignInAndSignUpPage jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- sign_in
  ============================ -->
          <section id="idocs_sign_in">
            <h2>sign-in</h2>
            <div id="idocs_sign_in_component">
              <h4>sign-in.component.jsx</h4>
              <p>opis</p>
              <p>
                <a class="popup-img" href="assets/images/sign_in.png"><img class="img-fluid border"
                    src="assets/images/sign_in.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React, { useState } from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useState to hook to Reacta pozwalający na używanie stanu w komponencie
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import FormInput from '../form-input/form-input.component';  // import komponentu występującego w SignIn
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w SignIn

import {
  emailSignInStart,
} from '../../redux/user/user.actions';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import {
  SignInContainer,
  SignInTitle,
  ButtonsBarContainer,
} from './sign-in.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const SignIn = ({ emailSignInStart }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const [userCredentials, setCredentials] = useState({  // w stanie komponentu będzie znajdować się email i password, użyjemy funkcji setUserCredentials to zmiany tych zmiennych
    email: '',
    password: '',
  });

  const { email, password } = userCredentials;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

  const handleSubmit = async (event) =&gt; {  //  funkcja wywoływana przy kliknięciu przycisku Submit w formularzu
    event.preventDefault();

    emailSignInStart(email, password);  // wywołuje funkcję emailSignInStart z wartościami email i password
  };

  const handleChange = (event) =&gt; {  // funkcja wywowała się, gdy użytkownik będzie edytować pola username lub password
    const { value, name } = event.target; // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

    setCredentials({ ...userCredentials, [name]: value });  // update stanu komponentu nowymi wartościami username i password
  };

  return (
    &lt;SignInContainer&gt;
      &lt;SignInTitle&gt;I already have an account&lt;/SignInTitle&gt;
      &lt;span&gt;Sign in with your email and password&lt;/span&gt;

      &lt;form onSubmit={handleSubmit}&gt;  // po kliknięciu submit wywołaj funkcję handleSubmit
        &lt;FormInput
          name=&quot;email&quot;
          type=&quot;email&quot;
          handleChange={handleChange}
          value={email}
          label=&quot;email&quot;
          required
        /&gt;
        &lt;FormInput
          name=&quot;password&quot;
          type=&quot;password&quot;
          value={password}
          handleChange={handleChange}  // przy zmianie zawartości pul formularza wywołaj funkcję handleChange
          label=&quot;password&quot;
          required
        /&gt;
        &lt;ButtonsBarContainer&gt;
          &lt;CustomButton type=&quot;submit&quot;&gt; Sign in &lt;/CustomButton&gt;
        &lt;/ButtonsBarContainer&gt;
      &lt;/form&gt;
    &lt;/SignInContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik zaloguje się którąś z metod, store zmieni użytkownika na zalogowanego 
  emailSignInStart: (email, password) =&gt;
    dispatch(emailSignInStart({ email, password })),
});

export default connect(null, mapDispatchToProps)(SignIn);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_sign_in_styles">
              <h4 class="mt-5">sign-in.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const SignInContainer = styled.article`  // tworzy komponent SignInContainer, który renderuje tag html article z określonymi stylami
  width: 380px;
  display: flex;
  flex-direction: column;
  @media screen and (max-width: 460px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 460px
    width: 260px;
  }
`;

export const SignInTitle = styled.h2`  // tworzy komponent SignInTitle, który renderuje tag html h2 z określonymi stylami
  margin: 10px 0;
`;

export const ButtonsBarContainer = styled.div`  // tworzy komponent ButtonsBarContainer, który renderuje tag html div z określonymi stylami
  display: flex;
  justify-content: space-between;
  @media screen and (max-width: 460px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 460px
    display: block;

    button {  // te style będą dotyczyć wszystkich tagów button znajdujących się w ButtonsBarContainer
      margin: 0 auto 10px auto;
    }
  }
`;</code></pre>
            </div>
            <div id="idocs_sign_in_test">
              <h4 class="mt-5">sign-in.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
            </div>
          </section>
          <hr class="divider" />

          <!-- form_input
  ============================ -->
          <section id="idocs_form_input">
            <h2>form-input</h2>
            <div id="idocs_form_input_component">
              <h4>form-input.component.jsx</h4>
              <p>opis</p>
              <p>
                <a class="popup-img" href="assets/images/form_input.png"><img class="img-fluid border"
                    src="assets/images/form_input.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import {
  GroupContainer,
  FormInputContainer,
  FormInputLabel,
} from './form-input.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const FormInput = ({ handleChange, label, ...props }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;GroupContainer&gt;
    &lt;FormInputContainer onChange={handleChange} {...props} /&gt;  // przy zmianie zawartości pola wywołaj funkcję handleChange
    {label ? (
      &lt;FormInputLabel className={props.value.length ? 'shrink' : ''}&gt;  // jeżeli w pole zostało coś wpisane, do komponentu zostanie dopisana klasa 'shrink'
        {label}
      &lt;/FormInputLabel&gt;
    ) : null}  // jeżeli label nie jest pusta wywołaj FormInputLabel
  &lt;/GroupContainer&gt;
);

export default FormInput;  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_form_input_styles">
              <h4 class="mt-5">form-input.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { css } from 'styled-components';  // import biblioteki styled components

const subColor = '#e08800';  // zmienne zawierające kolory
const mainColor = 'black';  // zmienne zawierające kolory

const shrinkLabelStyles = css`  // określa grupę atrybutów css, nie renderuje tagu html sam w sobie
  top: -14px;
  font-size: 12px;
  color: ${mainColor};
`;

export const GroupContainer = styled.div`  // tworzy komponent GroupContainer, który renderuje tag html div z określonymi stylami
  position: relative;
  margin: 45px 0;

  input[type='password'] {  // style dla inputów typu password znajdujących się w GroupContainer
    letter-spacing: 0.3em;
  }
`;

export const FormInputContainer = styled.input`  // tworzy komponent FormInputContainer, który renderuje tag html input z określonymi stylami
  background: none;
  background-color: white;
  color: ${subColor};
  font-size: 18px;
  padding: 10px 10px 10px 5px;
  display: block;
  width: 100%;
  border: none;
  border-radius: 0;
  border-bottom: 1px solid ${subColor};
  margin: 25px 0;

  &:focus {  // style gdy input jest kliknięty
    outline: none;
  }

  &:focus ~ label {  // style dla label gdy input jest kliknięty
    ${shrinkLabelStyles}
  }
`;

FormInputContainer.displayName = 'FormInputContainer';  // po zrenderowaniu w DevTools komponent FormInputContainer wyświetlał by się jako styled.input, ale po zmianie parametru displayName wyświetli się jako FormInputContainer co ułatwi debugowanie

export const FormInputLabel = styled.label`  // tworzy komponent FormInputLabel, który renderuje tag html label z określonymi stylami
  color: ${subColor};
  font-size: 16px;
  font-weight: normal;
  position: absolute;
  pointer-events: none;
  left: 5px;
  top: 10px;
  transition: 300ms ease all;

  &.shrink {  // style dla komponentów z FormInputLabel z klasą shrink
    ${shrinkLabelStyles}
  }
`;

FormInputLabel.displayName = 'FormInputLabel';  // po zrenderowaniu w DevTools komponent FormInputLabel wyświetlał by się jako styled.label, ale po zmianie parametru displayName wyświetli się jako FormInputLabel co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_form_input_test">
              <h4 class="mt-5">form-input.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import FormInput from './form-input.component';  // import komponentu, który będziemy testować

describe('FormInput component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu FormInput
  let wrapper;  // tworzenie zmiennych do testów
  let mockHandleChange;  // tworzenie zmiennych do testów

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockHandleChange = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości

    const mockProps = {  // mockowanie propsów przekazanych do FormInput
      label: 'email',
      value: 'test@gmail.com',
      handleChange: mockHandleChange,
    };

    wrapper = shallow(&lt;FormInput {...mockProps} /&gt;);  // wyrenderuj komponent FormInput z propsami wyżej
  });

  it('should render FormInput component', () =&gt; {
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany FormInput jest zgodny z snapshotem
  });

  it('should call handleChange method when input changes', () =&gt; {
    wrapper.find('FormInputContainer').simulate('change');  // simuluj zmianę pól formularza,

    expect(mockHandleChange).toHaveBeenCalled();  //  co powinno wywołać funkcję mockHandleChange
  });

  it('should render FormInputLabel if there is a label', () =&gt; {
    expect(wrapper.exists('FormInputLabel')).toBe(true);
  });

  it('should not render FormInputLabel if there is no label', () =&gt; {  // nie renderuj FormInputLabel, jeżeli nie ma zmiennej label
    const mockNewProps = {  // nowe propsy
      label: '',
      value: 'test@gmail.com',
      handleChange: mockHandleChange,
    };

    const newWrapper = shallow(&lt;FormInput {...mockNewProps} /&gt;);  // wyrenderuj komponent FormInput z propsami wyżej

    expect(newWrapper.exists('FormInputLabel')).toBe(false);  // oczekuj, że FormInputLabel nie istnieje w dom
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- sign_up
  ============================ -->
          <section id="idocs_sign_up">
            <h2>sign-up</h2>
            <div id="idocs_sign_up_component">
              <h4>sign-up.component.jsx</h4>
              <p>opis</p>
              <p>
                <a class="popup-img" href="assets/images/sign_up.png"><img class="img-fluid border"
                    src="assets/images/sign_up.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React, { useState } from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useState to hook to Reacta pozwalający na używanie stanu w komponencie
import { connect } from 'react-redux';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import FormInput from '../form-input/form-input.component';  // import komponentu występującego w SignUp
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w SignUp

import { signUpStart } from '../../redux/user/user.actions';  // funkcja do obsługi Redux (omówione w oddzielnym dziale)

import { SignUpContainer, SignUpTitle } from './sign-up.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const SignUp = ({ signUpStart }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const [userCredentials, setUserCredentials] = useState({  // w stanie komponentu będzie znajdować się displayName, email, password i confirmPassword, użyjemy funkcji setUserCredentials to zmiany tych zmiennych
    displayName: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  const { displayName, email, password, confirmPassword } = userCredentials;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

  const handleSubmit = async (event) =&gt; {
    event.preventDefault();

    if (password !== confirmPassword) {
      alert(&quot;passwords don't match&quot;);
      return;
    }

    signUpStart({ displayName, email, password });
  };

  const handleChange = (event) =&gt; {
    const { name, value } = event.target;

    setUserCredentials({ ...userCredentials, [name]: value });
  };

  return (
    &lt;SignUpContainer&gt;
      &lt;SignUpTitle&gt;I do not have a account&lt;/SignUpTitle&gt;
      &lt;span&gt;Sign up with your email and password&lt;/span&gt;
      &lt;form className=&quot;sign-up-form&quot; onSubmit={handleSubmit}&gt;  // po kliknięciu submit wywołaj funkcję handleSubmit
        &lt;FormInput
          type=&quot;text&quot;
          name=&quot;displayName&quot;
          value={displayName}
          onChange={handleChange}
          label=&quot;Display Name&quot;
          required
        /&gt;
        &lt;FormInput
          type=&quot;email&quot;
          name=&quot;email&quot;
          value={email}
          onChange={handleChange}
          label=&quot;Email&quot;
          required
        /&gt;
        &lt;FormInput
          type=&quot;password&quot;
          name=&quot;password&quot;
          value={password}
          onChange={handleChange}
          label=&quot;Password&quot;
          required
        /&gt;
        &lt;FormInput
          type=&quot;password&quot;
          name=&quot;confirmPassword&quot;
          value={confirmPassword}
          onChange={handleChange}
          label=&quot;Confirm Password&quot;
          required
        /&gt;
        &lt;CustomButton type=&quot;submit&quot;&gt;SIGN UP&lt;/CustomButton&gt;
      &lt;/form&gt;
    &lt;/SignUpContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  / jeżeli użytkownik zarejestruje się którąś z metod, store przekaże te zmienne i zmieni stan użytkownika na zalogowanego 
  signUpStart: (userCredentials) =&gt; dispatch(signUpStart(userCredentials)),
});

export default connect(null, mapDispatchToProps)(SignUp);  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_sign_up_styles">
              <h4 class="mt-5">sign-up.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const SignUpContainer = styled.article`  // tworzy komponent SignUpContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
  width: 380px;
  @media screen and (max-width: 460px) {
    width: 260px;
  }
`;

export const SignUpTitle = styled.h2`  // tworzy komponent SignUpTitle, który renderuje tag h2 article z określonymi stylami
  margin: 10px 0;
`;</code></pre>
            </div>
            <div id="idocs_sign_up_test">
              <h4 class="mt-5">sign-up.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
            </div>
          </section>
          <hr class="divider" />

          <!-- error_boundary
  ============================ -->
          <section id="idocs_error_boundary">
            <h2>error-boundary</h2>
            <div id="idocs_error_boundary_component">
              <h4>error-boundary.component.jsx</h4>
              <p>opis</p>
              <p>
                <a class="popup-img" href="assets/images/error_boundary.png"><img class="img-fluid border"
                    src="assets/images/error_boundary.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import {
  ErrorImageOverlay,
  ErrorImageContainer,
  ErrorImageText,
} from './error-boundary.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

class ErrorBoundary extends React.Component {  // deklaracja komponentu funkcyjnego komponentu klasowego
  constructor() {  // konstruktor klasy
    super();
    this.state = {  // stan klasy 
      hasErrored: false,
    };
  }

  static getDerivedStateFromError(error) { // obsłuż error
    return { hasErrored: true };
  }

  render() {
    if (this.state.hasErrored) {  // soft 404 dla stron z błędami
      return (
        &lt;ErrorImageOverlay&gt;
          &lt;ErrorImageContainer imageUrl=&quot;https://i.imgur.com/yW2W9SC.png&quot; /&gt;
          &lt;ErrorImageText&gt;Sorry this page is broken&lt;/ErrorImageText&gt;
        &lt;/ErrorImageOverlay&gt;
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;  // export funkcji aby mogła być zaimportowana w innym komponencie</code></pre>
            </div>
            <div id="idocs_error_boundary_styles">
              <h4 class="mt-5">error-boundary.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const ErrorImageOverlay = styled.div`  // tworzy komponent ErrorImageOverlay, który renderuje tag html div z określonymi stylami
  height: 60vh;
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

export const ErrorImageContainer = styled.div`  // tworzy komponent ErrorImageContainer, który renderuje tag html div z określonymi stylami
  display: inline-block;
  background-image: ${({ imageUrl }) => `url(${imageUrl})`};
  background-size: cover;
  background-position: center;
  width: 40vh;
  height: 40vh;
`;

export const ErrorImageText = styled.h2`  // tworzy komponent ErrorImageText, który renderuje tag html h2 z określonymi stylami
  font-size: 28px;
  color: #2f8e89;
`;</code></pre>
            </div>
            <div id="idocs_error_boundary_test">
              <h4 class="mt-5">error-boundary.test.js</h4>
              <p>
                <strong>Pliki {component}.test.js zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
            </div>
          </section>
          <hr class="divider" />

          <!-- utils
  ============================ -->
          <section id="idocs_scroll_to_top_component">
            <h2>scroll-to-top-component.js</h2>
            <p>opis</p>
            <p>
              <a class="popup-img" href="assets/images/scroll_to_top_component.png"><img class="img-fluid border"
                  src="assets/images/scroll_to_top_component.png" alt="" /></a>
            </p>
            <pre><code class="language-javascript">import React from 'react';
import { withRouter } from 'react-router-dom';

class ScrollToTop extends React.Component {
  componentDidUpdate(prevProps) {
    if (this.props.location.pathname !== prevProps.location.pathname) {
      window.scrollTo(0, 0);
    }
  }

  render() {
    return null;
  }
}

export default withRouter(ScrollToTop);</code></pre>
          </section>
          <hr class="divider" />

          <!-- Redux
            ============================ -->
          <section id="idocs_redux">
            <h2>Redux</h2>
            <p class="text-4">opis</p>
          </section>
          <hr class="divider" />

          <!-- store
  ============================ -->
          <section id="idocs_store">
            <h2>store.js</h2>
            <p>opis</p>
            <p>
              <a class="popup-img" href="assets/images/store.png"><img class="img-fluid border"
                  src="assets/images/store.png" alt="" /></a>
            </p>
            <pre><code class="language-javascript">import { combineReducers } from 'redux';
import { persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

import userReducer from './user/user.reducer';
import cartReducer from './cart/cart.reducer';
import directoryReducer from './directory/directory.reducer';
import shopReducer from './shop/shop.reducer';

const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['cart'],
};

const rootReducer = combineReducers({
  user: userReducer,
  cart: cartReducer,
  directory: directoryReducer,
  shop: shopReducer,
});

export default persistReducer(persistConfig, rootReducer);</code></pre>
          </section>
          <hr class="divider" />

          <!-- saga-testing
  ============================ -->
          <section id="idocs_saga_testing_utils">
            <h2>saga-testing.utils.js</h2>
            <p>opis</p>
            <p>
              <a class="popup-img" href="assets/images/saga_testing_utils.png"><img class="img-fluid border"
                  src="assets/images/saga_testing_utils.png" alt="" /></a>
            </p>
            <pre><code class="language-javascript">import { runSaga } from 'redux-saga';

export async function recordSaga(saga, initialAction) {
  const dispatched = [];

  await runSaga(
    {
      dispatch: (action) =&gt; dispatched.push(action),
    },
    saga,
    initialAction
  ).done;

  return dispatched;
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- root-saga
  ============================ -->
          <section id="idocs_root_saga">
            <h2>root-saga.js</h2>
            <p>opis</p>
            <p>
              <a class="popup-img" href="assets/images/root_saga.png"><img class="img-fluid border"
                  src="assets/images/root_saga.png" alt="" /></a>
            </p>
            <pre><code class="language-javascript">import { all, call } from 'redux-saga/effects';

import { shopSagas } from './shop/shop.sagas';
import { userSagas } from './user/user.sagas';
import { cartSagas } from './cart/cart.sagas';

export default function* rootSaga() {
  yield all([call(shopSagas), call(userSagas), call(cartSagas)]);
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- root-reducer
  ============================ -->
          <section id="idocs_root_reducer">
            <h2>root-reducer.js</h2>
            <p>opis</p>
            <p>
              <a class="popup-img" href="assets/images/root_reducer.png"><img class="img-fluid border"
                  src="assets/images/root_reducer.png" alt="" /></a>
            </p>
            <pre><code class="language-javascript">import { combineReducers } from 'redux';

import { persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

import userReducer from './user/user.reducer';
import cartReducer from './cart/cart.reducer';
import directoryReducer from './directory/directory.reducer';
import shopReducer from './shop/shop.reducer';

const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['cart'],
};

const rootReducer = combineReducers({
  user: userReducer,
  cart: cartReducer,
  directory: directoryReducer,
  shop: shopReducer,
});

export default persistReducer(persistConfig, rootReducer);</code></pre>
          </section>
          <hr class="divider" />


          <!-- Dodatkowe wyjaśnienia
		============================ -->
          <section id="idocs_dodatkowe_wyjasnienia">
            <h2>Dodatkowe wyjaśnienia</h2>
            <p class="text-4">Szybkie wytłumaczenie wybranych tematów.</p>
          </section>
          <hr class="divider" />

          <!-- Komponent
		============================ -->
          <section id="idocs_komponent">
            <h2>Komponent w React</h2>
            <p>
              Komponent to jeden z podstawowych elementów konstrukcyjnych
              Reacta. <br />
              <br />Innymi słowy, możemy powiedzieć, że każda aplikacja, którą
              stworzysz w React, będzie składała się z części zwanych
              komponentami. <br />
              <br />Możesz zobaczyć interfejs użytkownika podzielony na wiele
              pojedynczych elementów zwanych komponentami i pracować nad nimi
              niezależnie, a następnie scalić je wszystkie w komponencie
              nadrzędnym, który będzie twoim ostatecznym interfejsem
              użytkownika.
            </p>
            <h5>Przykład:</h5>
            <pre><code class="language-javascript">import React from 'react';
import { FooterContainer, AuthorContainer } from './footer.styles';

export const Footer = () =&gt; (
  &lt;FooterContainer&gt;
    &lt;AuthorContainer&gt;&amp;copy; Ingrid Pruszyńska&lt;/AuthorContainer&gt;
  &lt;/FooterContainer&gt;
);

export default Footer;</code></pre>
          </section>
          <hr class="divider" />

          <!-- Rozkład komponentów
		============================ -->
          <section id="idocs_rozklad_komponentow">
            <h2>Rozkład komponentów</h2>
            <p>
              Jak sprawdzić z jakich komponentów składa się strona? <br />
              <br />
              W każdej popularnej przeglądarce powinno być dostępne
              rozszerzenie/wtyczka o nazwie React Developer Tools.
              <br />Po otwarciu strony i otworzeniu inspektora będziecie mieć
              nową zakładkę Components, na której widać drzewko komponentów.
            </p>
            <h5>Przykład:</h5>
            <p>
              <a class="popup-img" href="assets/images/react-developer-tools.png"><img class="img-fluid border"
                  src="assets/images/react-developer-tools.png" alt="" /></a>
            </p>
          </section>
          <hr class="divider" />

          <!-- Props
		============================ -->
          <section id="idocs_props">
            <h2>Czym są props?</h2>
            <p>
              „Props” to specjalne słowo kluczowe w React, które oznacza
              właściwości i służy do przekazywania danych z jednego komponentu
              do drugiego.<br />
              Ale ważną częścią jest to, że dane z propami są przekazywane w
              jednokierunkowym przepływie. (w jedną stronę od rodzica do
              dziecka).<br />
              Ponadto dane props są tylko do odczytu, co oznacza, że ​​dane
              pochodzące od rodzica nie powinny być zmieniane przez komponenty
              potomne.
            </p>
            <h5>Przykład:</h5>
            <p>Kod poniżej renderuje napis „Cześć Sara”</p>
            <pre><code class="language-javascript">function Welcome(props) {
  return &lt;h1&gt;Cześć, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name='Sara' /&gt;;</code></pre>
          </section>
          <hr class="divider" />

          <!-- Styled Components
		============================ -->
          <section id="idocs_styled_components">
            <h2>Biblioteka Styled Components</h2>
            <p>
              Styled-components to biblioteka stworzona dla programistów React
              i React Native. <br />
              Pozwala na używanie w aplikacjach stylów na poziomie
              komponentów. Styled-components wykorzystują mieszankę JavaScript
              i CSS przy użyciu techniki zwanej CSS-in-JS.<br />
              Styled-components są oparte na otagowanych literałach szablonów,
              co oznacza, że ​​rzeczywisty kod CSS jest zapisywany między
              backtickami podczas stylizowania komponentów. Daje to
              programistom elastyczność w ponownym wykorzystywaniu kodu CSS z
              jednego projektu do drugiego.
            </p>
            <h5>Przykład:</h5>
            <p>
              Kod poniżej stworzy komponent Title, który wyrenderuje tag
              &lt;h1&gt; z określonymi stylami.
            </p>
            <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const Title = styled.h1`  
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
`;</code></pre>
          </section>
          <hr class="divider" />

          <!-- Jest
		============================ -->
          <section id="idocs_jest">
            <h2>Framework Jest</h2>
            <p>
              Framework do testowania JavaScriptu, który koncentruje się na
              prostocie. Działa z projektami wykorzystującymi: Babel,
              TypeScript, Node, React, Angular, Vue itd.<br />
              Testowanie jednostkowe to testowanie oprogramowania, podczas
              którego testowane są poszczególne komponenty oprogramowania.
              <br />
              Celem testów jednostkowych jest sprawdzenie, czy każda jednostka
              oprogramowania działa zgodnie z założeniami.<br /><br />

              Mockowanie to technika, w której części kodu są zastępowane
              fikcyjnymi implementacjami, które emulują prawdziwy kod. <br />
              Mocking pomaga osiągnąć izolację testów. Mocking jest używany
              głównie w testach jednostkowych.<br /><br />

              W naszych testach sprawdzamy, czy wartości spełniają określone
              warunki. <br />
              Funkcja expect daje nam szereg dopasowań, które pozwalają nam
              sprawdzać różne rzeczy, takie jak toBe, toBeFalsy lub toEqual.
            </p>
            <h5>Przykład:</h5>
            <p>Test poniżej sprawdza czy suma 1 + 2 jest równa 3.</p>
            <pre><code class="language-javascript">const sum = require('./sum');

test('adds 1 + 2 to equal 3', () =&gt; {
  expect(sum(1, 2)).toBe(3);
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- Mock
		============================ -->
          <section id="idocs_mock">
            <h2>Mock</h2>
            <p>
              Mockowanie to udawanie, symulowanie odpowiedzi jakiegoś serwisu,
              aby była zgodna z naszymi oczekiwaniami. <br />
              Czyli udawanie, że system, który działa, nie działa albo
              odwrotnie (np. testowanie obsługi błędów). <br />
              Można też symulować konkretne odpowiedzi, aby sprawdzić, czy
              zwracane wartości są przez naszą aplikację poprawnie obliczane.
              <br />
              <br />
              W testach jednostkowych, gdzie mamy większe pole do popisu,
              mockować można obiekty klas, z którymi wchodzimy w interakcję.
              <br />
            </p>
            <h5>Przykład:</h5>
            <p>
              Test poniżej sprawdza czy funkcja mock została poprawnie
              wywołana 3 razy.
            </p>
            <pre><code class="language-javascript">it('returns undefined and has been called correct number of times', () =&gt; {
  const mock = jest.fn();

  const result = mock();

  expect(result).toBeUndefined();
  expect(mock).toHaveBeenCalledTimes(1);
  expect(mock).toHaveBeenCalledWith();
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- Snapshot testing
		============================ -->
          <section id="idocs_snapshot_testing">
            <h2>Snapshot Testing</h2>
            <p>
              Snapshot testy są bardzo przydatnym narzędziem, gdy chcesz mieć
              pewność, że Twój interfejs użytkownika nie zmieni się
              nieoczekiwanie. <br />
              Typowy snapshot test renderuje składniki interfejsu użytkownika,
              wykonuje snapshot, a następnie porównuje go z referencyjnym
              plikiem snapshota przechowywanym wraz z testem. <br />
              Test zakończy się niepowodzeniem, jeśli dwie migawki nie będą
              pasować: zmiana jest nieoczekiwana lub migawka referencyjna musi
              zostać zaktualizowana do nowej wersji składnika interfejsu
              użytkownika.
            </p>
            <h5>Przykład:</h5>
            <p>
              Test poniżej sprawdza czy funkcja zrenderuje się tak samo jak
              zapisany snapshot.
            </p>
            <pre><code class="language-javascript">import React from 'react';  
import renderer from 'react-test-renderer';

import Items from './Items';

it('renders correctly when there are no items', () =&gt; {
  const tree = renderer.create(&lt;Items /&gt;).toJSON();
  expect(tree).toMatchSnapshot();
});</code></pre>
          </section>
          <hr class="divider" />
        </div>
      </div>
    </div>
    <!-- Content end -->

    <!-- Footer
  ============================ -->
    <footer id="footer" class="section bg-dark footer-text-light">
      <div class="container">
        <ul class="
              social-icons social-icons-lg social-icons-muted
              justify-content-center
              mb-3
            ">
          <li>
            <a data-toggle="tooltip" href="https://twitter.com/harnishdesign/" target="_blank" title=""
              data-original-title="Twitter"><i class="fab fa-twitter"></i></a>
          </li>
          <li>
            <a data-toggle="tooltip" href="http://www.facebook.com/harnishdesign/" target="_blank" title=""
              data-original-title="Facebook"><i class="fab fa-facebook-f"></i></a>
          </li>
          <li>
            <a data-toggle="tooltip" href="http://www.dribbble.com/harnishdesign/" target="_blank" title=""
              data-original-title="Dribbble"><i class="fab fa-dribbble"></i></a>
          </li>
          <li>
            <a data-toggle="tooltip" href="http://www.github.com/" target="_blank" title=""
              data-original-title="GitHub"><i class="fab fa-github"></i></a>
          </li>
        </ul>
        <p class="text-center">
          Copyright &copy; 2020
          <a href="http://www.harnishdesign.net/idocs-one-page-documentation-html-template/">iDocs</a>. All Rights
          Reserved.
        </p>
        <p class="text-2 text-center mb-0">
          Design &amp; Develop by
          <a class="btn-link" target="_blank" href="http://www.harnishdesign.net/">HarnishDesign</a>.
        </p>
      </div>
    </footer>
    <!-- Footer end -->
  </div>
  <!-- Document Wrapper end -->

  <!-- Back To Top -->
  <a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)"><i
      class="fa fa-chevron-up"></i></a>

  <!-- JavaScript
============================ -->
  <script src="assets/vendor/jquery/jquery.min.js"></script>
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- Highlight JS -->
  <script src="assets/vendor/highlight.js/highlight.min.js"></script>
  <!-- Easing -->
  <script src="assets/vendor/jquery.easing/jquery.easing.min.js"></script>
  <!-- Magnific Popup -->
  <script src="assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script>
  <!-- Custom Script -->
  <script src="assets/js/theme.js"></script>
</body>

</html>