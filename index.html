<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no" />
  <link href="assets/images/favicon.png" rel="icon" />
  <title>Dokumentacja | Projekt Specjalnościowy</title>
  <meta name="description" content="Dokumentacja na projekt specjalnościowy" />
  <meta name="author" content="Ingrid Pruszyńska 7051" />

  <!-- Stylesheet
  ============================== -->
  <!-- Bootstrap -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/bootstrap/css/bootstrap.min.css" />
  <!-- Font Awesome Icon -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/font-awesome/css/all.min.css" />
  <!-- Magnific Popup -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/magnific-popup/magnific-popup.min.css" />
  <!-- Highlight Syntax -->
  <link rel="stylesheet" type="text/css" href="assets/vendor/highlight.js/styles/github.css" />
  <!-- Custom Stylesheet -->
  <link rel="stylesheet" type="text/css" href="assets/css/stylesheet.css" />
  <link rel="stylesheet" type="text/css" href="assets/css/color-orange.css" />
  <link rel="stylesheet" type="text/css" href="assets/css/custom.css" />
</head>

<body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">
  <!-- Document Wrapper
=============================== -->
  <div id="main-wrapper">
    <!-- Header
  ============================ -->
    <header id="header" class="sticky-top">
      <!-- Navbar -->
      <nav class="primary-menu navbar navbar-expand-lg navbar-dropdown-light">
        <div class="container-fluid">
          <!-- Logo -->
          <a class="logo ml-md-3" href="index.html" title="Doc">
            Projekt Specjalnościowy
          </a>
          <!-- Logo End -->
        </div>
      </nav>
      <!-- Navbar End -->
    </header>
    <!-- Header End -->

    <!-- Content
  ============================ -->
    <div id="content" role="main">
      <!-- Sidebar Navigation
      ============================ -->
      <div class="idocs-navigation bg-light navbar-dropdown-light">
        <ul class="nav flex-column">
          <!-- Podstawowe informacje -->
          <li class="nav-item">
            <a class="nav-link active" href="#idocs_start">Podstawowe informacje</a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#idocs_repozytorium">Repozytorium</a>
              </li>
              <!--<li class="nav-item">
                <a class="nav-link" href="#idocs_wersja_live">Wersja Live</a>
              </li>-->
              <li class="nav-item">
                <a class="nav-link" href="#idocs_wykorzystane_technologie">Wykorzystane technologie</a>
              </li>

              <li class="nav-item">
                <a class="nav-link" href="#idocs_omowienie_kodu">Omówienie kodu</a>
              </li>
            </ul>
          </li>
          <!-- Analiza komponentów -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_analiza_komponentow">Analiza komponentów</a>
            <ul class="nav flex-column">
              <!-- homepage -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_homepage">homepage</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_homepage_component">
                      homepage.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_homepage_styles">
                      homepage.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_homepage_test">
                      homepage.test</a>
                  </li>
                </ul>
              </li>
              <!-- header -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_header">header</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_header_component">
                      header.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_header_styles">
                      header.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_header_test">
                      header.test</a>
                  </li>
                </ul>
              </li>
              <!-- cart-icon -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_cart_icon">cart-icon</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_icon_component">
                      cart-icon.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_icon_styles">
                      cart-icon.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_icon_test">
                      cart-icon.test</a>
                  </li>
                </ul>
              </li>
              <!-- cart-dropdown -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_cart_dropdown">cart-dropdown</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_dropdown_component">
                      cart-dropdown.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_dropdown_styles">
                      cart-dropdown.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_dropdown_test">
                      cart-dropdown.test</a>
                  </li>
                </ul>
              </li>
              <!-- cart-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_cart_item">cart-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_item_component">
                      cart-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_item_styles">
                      cart-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_cart_item_test">
                      cart-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- menu-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_menu_item">menu-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_menu_item_component">
                      menu-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_menu_item_styles">
                      menu-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_menu_item_test">
                      menu-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- directory -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_directory">directory</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_directory_component">
                      directory.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_directory_styles">
                      directory.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_directory_test">
                      directory.test</a>
                  </li>
                </ul>
              </li>
              <!-- footer -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_footer">footer</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_footer_component">
                      footer.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_footer_styles">
                      footer.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_footer_test">
                      footer.test</a>
                  </li>
                </ul>
              </li>
              <!-- shoppage -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_shoppage">shop</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_shop_component">
                      shop.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_shop_styles">
                      shop.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_shop_test"> shop.test</a>
                  </li>
                </ul>
              </li>
              <!-- collections-overview -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collections_overview">collections-overview</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_container">
                      collections-overview.container</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_component">
                      collections-overview.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_styles">
                      collections-overview.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collections_overview_test">
                      collections-overview.test</a>
                  </li>
                </ul>
              </li>
              <!-- collection-preview -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collection_preview">collection-preview</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_preview_component">
                      collection-preview.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_preview_styles">
                      collection-preview.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_preview_test">
                      collection-preview.test</a>
                  </li>
                </ul>
              </li>
              <!-- collection-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collection_item">collection-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_item_component">
                      collection-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_item_styles">
                      collection-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_item_test">
                      collection-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- custom-button -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_custom_button">custom-button</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_custom_button_component">
                      custom-button.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_custom_button_styles">
                      custom-button.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_custom_button_test">
                      custom-button.test</a>
                  </li>
                </ul>
              </li>
              <!-- with-spinner -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_with_spinner">with-spinner</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_with_spinner_component">
                      with-spinner.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_with_spinner_test">
                      with-spinner.test</a>
                  </li>
                </ul>
              </li>
              <!-- spinner -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_spinner">spinner</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_spinner_component">
                      spinner.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_spinner_styles">
                      spinner.styles</a>
                  </li>
                </ul>
              </li>
              <!-- collection -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_collection">collection</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_container">
                      collection.container</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_component">
                      collection.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_styles">
                      collection.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_collection_test">
                      collection.test</a>
                  </li>
                </ul>
              </li>
              <!-- checkout -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_checkout">checkout</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_component">
                      checkout.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_styles">
                      checkout.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_test">
                      checkout.test</a>
                  </li>
                </ul>
              </li>
              <!-- checkout-item -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_checkout_item">checkout-item</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_item_component">
                      checkout-item.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_item_styles">
                      checkout-item.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_checkout_item_test">
                      checkout-item.test</a>
                  </li>
                </ul>
              </li>
              <!-- sign-in-and-sign-up-page -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown"
                  href="#idocs_sign_in_and_sign_up_page">sign-in-and-sign-up-page</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_and_sign_up_page_component">
                      sign-in-and-sign-up-page.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_and_sign_up_page_styles">
                      sign-in-and-sign-up-page.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_and_sign_up_page_test">
                      sign-in-and-sign-up-page.test</a>
                  </li>
                </ul>
              </li>
              <!-- sign-in -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_sign_in">sign-in</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_component">
                      sign-in.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_styles">
                      sign-in.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_in_test">
                      sign-in.test</a>
                  </li>
                </ul>
              </li>
              <!-- form-input -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_form_input">form-input</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_form_input_component">
                      form-input.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_form_input_styles">
                      form-input.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_form_input_test">
                      form-input.test</a>
                  </li>
                </ul>
              </li>
              <!-- sign-up -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_sign_up">sign-up</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_up_component">
                      sign-up.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_up_styles">
                      sign-up.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_sign_up_test">
                      sign-up.test</a>
                  </li>
                </ul>
              </li>
              <!-- error-boundary -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_error_boundary_component">error-boundary</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_error_boundary_component">
                      error-boundary.component</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_error_boundary_styles">
                      error-boundary.styles</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_error_boundary_test">
                      error-boundary.test</a>
                  </li>
                </ul>
              </li>
              <!-- utils -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown"
                  href="#idocs_scroll_to_top_component">scroll-to-top.component.jsx</a>
              </li>
              <!-- App -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_app">app.js</a>
              </li>
              <!-- global.styles.js -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_global_styles">global.styles.js</a>
              </li>
              <!-- index.js -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_index">index.js</a>
              </li>
              <!-- service-worker.js -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_service_worker">service-worker.js</a>
              </li>
              <!-- setup-tests.js -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_setup_tests">setup-tests.js</a>
              </li>
            </ul>

            <!-- Redux -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_redux">Redux</a>
            <ul class="nav flex-column">
              <!-- store -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_store">store.js</a>
              </li>
              <!-- saga_testing_utils -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_saga_testing_utils">saga-testing.utils.js</a>
              </li>
              <!-- root_saga -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_root_saga">root-saga.js</a>
              </li>
              <!-- root_reducer -->
              <li class="nav-item">
                <a class="nav-link nav-sublink" href="#idocs_root_reducer">root-reducer.js</a>
              </li>
              <!-- cart -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_redux_cart_actions">cart</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_actions">
                      cart.actions.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_actions_test">
                      cart.actions.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_reducer">
                      cart.reducer.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_reducer_test">
                      cart.reducer.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_sagas">
                      cart.sagas.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_sagas_test">
                      cart.sagas.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_selectors">
                      cart.selectors.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_types">
                      cart.types.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_cart_utils">
                      cart.utils.js</a>
                  </li>
                </ul>
              </li>
              <!-- directory -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_redux_directory_reducer">directory</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_directory_reducer">
                      directory.reducer.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_directory_reducer_test">
                      directory.reducer.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_directory_selectors">
                      directory.selectors.js</a>
                  </li>
                </ul>
              </li>
              <!-- shop -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_redux_shop_actions">shop</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_actions">
                      shop.actions.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_actions_test">
                      shop.actions.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_reducer">
                      shop.reducer.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_reducer_test">
                      shop.reducer.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_sagas">
                      shop.sagas.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_sagas_test">
                      shop.sagas.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_selectors">
                      shop.selectors.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_shop_types">
                      shop.types.js</a>
                  </li>
                </ul>
              </li>
              <!-- user -->
              <li class="nav-item">
                <a class="nav-link nav-sublink dropdown" href="#idocs_redux_user_actions">user</a>
                <ul class="nav flex-column">
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_actions">
                      user.actions.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_reducer">
                      user.reducer.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_reducer_test">
                      user.reducer.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_sagas">
                      user.sagas.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_sagas_test">
                      user.sagas.test.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_selectors">
                      user.selectors.js</a>
                  </li>
                  <li class="nav-item dropdown-item">
                    <a class="nav-link" href="#idocs_redux_user_types">
                      user.types.js</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <!-- Dodatkowe wyjaśnienia -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_dodatkowe_wyjasnienia">Dodatkowe wyjaśnienia</a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#idocs_komponent">Komponent</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_rozklad_komponentow">Rozkład komponentów</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_props">Props</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_styled_components">Styled Components</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_jest">Jest</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_mock">Mock</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_snapshot_testing">Snapshot testing</a>
              </li>
            </ul>
          </li>
          <!-- Baza danych -->
          <li class="nav-item">
            <a class="nav-link" href="#idocs_baza_danych">Baza danych</a>
            <ul class="nav flex-column">
              <li class="nav-item">
                <a class="nav-link" href="#idocs_ogolne_informacje">Ogólne informacje</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#idocs_schemat">Schemat</a>
              </li>
            </ul>
          </li>
          </li>
        </ul>
      </div>

      <!-- Docs Content
      ============================ -->
      <div class="idocs-content">
        <div class="container">
          <!-- Podstawowe Informacje
              ============================ -->
          <section id="idocs_start">
            <h1>Dokumentacja</h1>
            <h2>Projekt Specjalnościowy</h2>
            <p class="lead">Szczegółowe omówienie kodu i narzędzi</p>
            <hr />
            <div class="row">
              <div class="col-sm-6 col-lg-4">
                <ul class="list-unstyled">
                  <li><strong>Indeksy:</strong> 7051, 6480</li>
                  <li><strong>Autorzy:</strong> Ingrid Pruszyńska, Przemysław Jadaś</li>
                </ul>
              </div>
              <div class="col-sm-6 col-lg-4">
                <ul class="list-unstyled">
                  <li><strong>Semestr:</strong> 6</li>
                  <li><strong>Kierunek:</strong> Informatyka</li>
                </ul>
              </div>
            </div>
          </section>
          <hr class="divider" />

          <!-- Repozytorium
              ============================ -->
          <section id="idocs_repozytorium">
            <h2>Repozytorium</h2>
            <p class="lead">
              Link do repozytorium: <br />
              <a href="https://github.com/ilshae/projekt-specjalnosciowy"
                target="_blank">https://github.com/ilshae/projekt-specjalnosciowy</a><br/>
              <a href="https://github.com/przemek-j/projekt-Specjalnosciowy-backend"
                target="_blank">https://github.com/przemek-j/projekt-Specjalnosciowy-backend</a>
            </p>
          </section>
          <hr class="divider" />

          <!-- Wersja live
              ============================ -->
          <!--<section id="idocs_wersja_live">
            <h2>Wersja live</h2>
            <p class="lead">
              Strona jest dostępna tutaj:<br /><a href="https://zadanie-na-uczelnie.pl/"
                target="_blank">https://zadanie-na-uczelnie.pl/</a>
            </p>

            <br />
          </section>
          <hr class="divider" />-->

          <!-- Wykorzystane technologie
              ============================ -->
          <section id="idocs_wykorzystane_technologie">
            <h2>Wykorzystane technologie</h2>
            <p>
              <b>Front end:</b> <br />HTML, CSS, Javascript, React,
              StyledComponents, Redux, Express, Jest
            </p>
          </section>
          <hr class="divider" />

          <!-- Omówienie kodu
              ============================ -->
          <section id="idocs_omowienie_kodu">
            <h2>Omówienie kodu</h2>
            <p class="lead">
              Zapoznamy się z aplikacją za pomocą screenshotów
              funkcjonalności. Następnie rozbijemy je na komponenty Reacta i
              wyjaśnimy kod. <br />
              W miejscach wymagających znajomości konkretnych bibliotek lub
              pojęć będą wstawione odnośniki z wyjaśnieniami. <br />
              Po obejrzeniu indywidualnych komponentów powiemy jak one
              oddziałują na siebie, np. jak działa nawigacja.
            </p>
          </section>
          <hr class="divider" />

          <!-- Analiza komponentów
              ============================ -->
          <section id="idocs_analiza_komponentow">
            <h2>Analiza komponentów</h2>
            <p class="lead mb-5">
              Komponenty będą przedstawiane od szczegółu do ogółu poprzez
              obejrzenie wszystkich podstron dostępnych dla użytkowników.
            </p>
          </section>
          <hr class="divider" />

          <!-- Homepage
              ============================ -->
          <section id="idocs_homepage">
            <h2>homepage</h2>
            <div id="idocs_homepage_component">
              <h4>homepage.component.jsx</h4>
              <!--<p class="lead mb-4">
                Strona główna znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/" target="_blank">https://zadanie-na-uczelnie.pl/</a>
              </p>-->
              <p>
                Strona homepage to strona główna sklepu. Zawiera logo, nawigację i kafelki z kategoriami
                produktów i
                stopkę z autorem.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów
                odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">Homepage</strong>
                znajduje się
                <strong style="color: rgb(0, 0, 255)">Directory</strong>, a w
                nim <strong style="color: rgb(255, 0, 255)">MenuItem</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/homepage.png"><img class="img-fluid border"
                    src="assets/images/homepage.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import Directory from '../../components/directory/directory.component';  // import komponentu występującego w Homepage
                  
import { HomePageContainer } from './homepage.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const HomePage = () =&gt; (  // deklaracja komponentu funkcyjnego
  &lt;HomePageContainer&gt;
    &lt;Directory /&gt;
  &lt;/HomePageContainer&gt;
);

export default HomePage; // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_homepage_styles">
              <h4 class="mt-5">homepage.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components i animacji

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
export const HomePageContainer = styled.main`  // tworzy komponent HomePageContainer, który renderuje tag html main z określonymi stylami
  display: flex;
  flex-direction: column;
  align-items: center;
  animation: 0.2s ${fadeIn};
`;</code></pre>
            </div>
            <div id="idocs_homepage_test">
              <h4 class="mt-5">homepage.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import Homepage from './homepage.component';  // import komponentu, który będziemy testować

it('should render Homepage component', () =&gt; {  // sprawdzenie czy Homepage renderuje się poprawnie
  expect(shallow(&lt;Homepage /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany Homepage jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- Header
              ============================ -->
          <section id="idocs_header">
            <h2>header</h2>
            <div id="idocs_header_component">
              <h4>header.component.jsx</h4>
              <p>
                <strong>Header wyświetla się na każdej stronie na górze.</strong>
                Zawiera logo, nawigację i koszyk. <br />
                <!--SHOP przekierowuje do:
                <a href="https://zadanie-na-uczelnie.pl/shop" target="_blank">https://zadanie-na-uczelnie.pl/shop</a>
                <br />
                SIGN IN przekierowuje do:
                <a href="https://zadanie-na-uczelnie.pl/signin"
                  target="_blank">https://zadanie-na-uczelnie.pl/signin</a>
                <br />
                Jeżeli użytkownik jest zalogowany zamiast SIGN IN, jest opcja
                SIGN OUT.<br />-->
                Kliknięcie na ikonę koszyka spowoduje jego rozwinięcie. Z tego
                miejsca jest dostępny przycisk CHECKOUT<!--, który przekierowuje
                do:
                <a href="https://zadanie-na-uczelnie.pl/checkout"
                  target="_blank">https://zadanie-na-uczelnie.pl/checkout</a>-->, gdzie można obejrzeć
                produkty w koszyku i
                za nie zapłacić.
              </p>
              <p>
                <a class="popup-img" href="assets/images/header.png"><img class="img-fluid border"
                    src="assets/images/header.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react'; // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import CartIcon from '../cart-icon/cart-icon.component';  // import innych komponentów
import CartDropdown from '../cart-dropdown/cart-dropdown.component';  // import innych komponentów
import { selectCartHidden } from '../../redux/cart/cart.selectors';  // selektor to getter dla store
import { selectCurrentUser } from '../../redux/user/user.selectors';  // selektor to getter dla store
import { signOutStart } from '../../redux/user/user.actions';    // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import { ReactComponent as Logo } from '../../assets/logo.svg'; // import grafiki Logo.svg

import {
  HeaderContainer,
  BrandContainer,
  LogoContainer,
  OptionsContainer,
  OptionLink,
} from './header.styles'; // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const Header = (
  { currentUser, hidden, signOutStart } // deklaracja komponentu funkcyjnego, przekazanie propsów
) =&gt; (
  &lt;HeaderContainer&gt;
    &lt;BrandContainer to='/'&gt;  // ikona loga + nazwa aplikacji, po kliknięciu przekierowuje do '/', czyli do /
      {' '}
      &lt;LogoContainer&gt;
        &lt;Logo /&gt;
      &lt;/LogoContainer&gt;
      Ingrid
    &lt;/BrandContainer&gt;
    &lt;OptionsContainer&gt;
      &lt;OptionLink to='/shop'&gt;SHOP&lt;/OptionLink&gt; // wyświetl w nawigacji SHOP
      {currentUser ? ( // jeżeli użytkownik jest zalogowany, wyświetl SIGN OUT, jeżeli nie jest zalogowany, wyświetl SIGN IN
        &lt;OptionLink as='div' onClick={signOutStart}&gt;
          SIGN OUT
        &lt;/OptionLink&gt;
      ) : (
        &lt;OptionLink to='/signin'&gt;SIGN IN&lt;/OptionLink&gt;
      )}
      &lt;CartIcon /&gt;
    &lt;/OptionsContainer&gt;
    {hidden ? null : &lt;CartDropdown /&gt;} // wyświetl koszyk, zależnie od parametru hidden jest on schowany lub widoczny
  &lt;/HeaderContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami
  currentUser: selectCurrentUser,
  hidden: selectCartHidden,
});

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik kliknie Sign Out, przekazuje do store informację, że użytkownik się wylogował
  signOutStart: () =&gt; dispatch(signOutStart()),
});

export default connect(mapStateToProps, mapDispatchToProps)(Header);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_header_styles">
              <h4 class="mt-5">header.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components'; // import biblioteki styled components
import { Link } from 'react-router-dom';  // link to komponent z biblioteki react-router-dom działający w spos&oacute;b podobny do &lt;a&gt;, jest odpowiedzialny za nawigację

export const HeaderContainer = styled.header` // tworzy komponent HeaderContainer, który renderuje tag html header z określonymi stylami
  height: 70px;
  width: 100%;
  display: flex;
  justify-content: space-between;
  margin-bottom: 25px;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    height: 60px;
    padding: 10px;
    margin-bottom: 20px;
  }
`;

export const BrandContainer = styled(Link)` // tworzy komponent BrandContainer, który renderuje komponent Link z biblioteki react-router-dom z określonymi stylami
  height: 100%;
  display: flex;
  align-items: center;
  text-transform: uppercase;
  font-size: 24px;
  white-space: nowrap;
  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 50px;
    padding: 0;
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    font-size: 20px;
  }

  @media screen and (max-width: 350px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 350px
    font-size: 18px;
  }
`;

export const LogoContainer = styled.div`  // tworzy komponent LogoContainer,  który renderuje tag html div z określonymi stylami
  margin-right: 15px;
  display: flex;
  align-items: center;
  justify-content: center;

  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    display: none;
  }
`;

export const OptionsContainer = styled.div` // tworzy komponent OptionsContainer,  który renderuje tag html div z określonymi stylami
  width: 50%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  font-size: 22px;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 80%;
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    font-size: 18px;
    a {
      padding: 5px 8px;
    }
  }
  @media screen and (max-width: 350px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 350
    font-size: 16px;
    a {
      padding: 2px 4px;
    }
  }
`;

export const OptionLink = styled(Link)` // tworzy komponent OptionLink, który renderuje komponent Link z biblioteki react-router-dom z określonymi stylami
  padding: 10px 15px;
  cursor: pointer;
`;

OptionLink.displayName = 'OptionLink';  // po zrenderowaniu w DevTools komponent OptionLink wyświetlał by się jako styled.link, ale po zmianie parametru displayName wyświetli się jako OptionLink co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_header_test">
              <h4 class="mt-5">header.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { Header } from './header.component';  // import komponentu, który będziemy testować
import CartDropdown from '../cart-dropdown/cart-dropdown.component';  // import komponentu, który występuje w komponencie Header

describe('Header component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu Header
  let wrapper;  // tworzenie zmiennych do testów
  let mockSignOutStart;  // tworzenie zmiennych do testów

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockSignOutStart = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {   // mockowanie propsów przekazanych do Header
      hidden: true,
      currentUser: {
        uid: '123'
      },
      signOutStart: mockSignOutStart
    };

    wrapper = shallow(&lt;Header {...mockProps} /&gt;);  // wyrenderuj komponent Header z propsami wyżej
  });

  it('should render Header component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent Header
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany Header jest zgodny z snapshotem
  });

  describe('if currentUser is present', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć propsa currentUser
    it('should render sign out link', () =&gt; {  // komponent powinien wyrenderować w nawigacji przycisk SIGN OUT, bo podajemy zalogowanego użytkownika
      expect(wrapper.find('OptionLink').at(1).text()).toBe('SIGN OUT');  // znajdz w zmiennej wrapper (zawierającą komponent Header), tag html o nazwie OptionLink, drugi z kolei, text w środku powinien brzmieć 'SIGN OUT'
    });

    it('should call signOutStart method when link is clicked', () =&gt; {  // po kliknięciu SIGN OUT, sprawdź czy została wywołana funkcja signOutStart()
      wrapper.find('OptionLink').at(1).simulate('click');   // symulacja kliknięcia na SIGN OUT

      expect(mockSignOutStart).toHaveBeenCalled();  // oczekuj, że funkcja mockSignOutStart zostanie wywołana
    });
  });

  describe('if currentUser is null', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć pustej zmiennej currentUser
    it('should render sign in link', () =&gt; {  // użytkownik nie jest zalogowany, powinien mieć w nawigacji opcję SIGN IN
      const mockProps = {   // mockuj nowe propsy, adekwatne do sytuacji
        hidden: true,
        currentUser: null,
        signOutStart: mockSignOutStart,
      };

      const newWrapper = shallow(&lt;Header {...mockProps} /&gt;);  // nowa zmienna z nowymi propsami

      expect(newWrapper.find('OptionLink').at(1).text()).toBe('SIGN IN');  // znajdz w zmiennej wrapper (zawierającą komponent Header), tag html o nazwie OptionLink, drugi z kolei, text w środku powinien brzmieć 'SIGN IN' 
    });
  });

  describe('if hidden is true', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć zmiennej hidden odpowiedzialnej za wyświetlanie koszyka
    it('should not render CartDropdown', () =&gt; {  // nie renderuj CartDropdown (koszyka), bo props hidden == true
      expect(wrapper.exists(CartDropdown)).toBe(false);  // szuka w Headerze komponentu CartDropdown, jeżeli go nie znajdzie zwróci fałsz
    });
  });

  describe('if hidden is false', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć zmiennej hidden odpowiedzialnej za wyświetlanie koszyka
    it('should render CartDropdown', () =&gt; {  //  renderuj CartDropdown (koszyk), bo props hidden == false
      const mockProps = {
        hidden: false,
        currentUser: null,
        signOutStart: mockSignOutStart,
      };

      const newWrapper = shallow(&lt;Header {...mockProps} /&gt;);  // nowa zmienna z nowymi propsami

      expect(newWrapper.exists(CartDropdown)).toBe(true);  // szuka w Headerze komponentu CartDropdown, jeżeli go znajdzie zwróci prawdę
    });
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- cart-icon
              ============================ -->
          <section id="idocs_cart_icon">
            <h2>cart-icon</h2>
            <div id="idocs_cart_icon_component">
              <h4>cart-icon.component.jsx</h4>
              <p>
                Jest to ikona przedstawiająca koszyk, występuje w środku
                komponentu header. Cyfra w ikonie odzwierciedla ilość
                przedmiotów w koszyku.<br />
                Po kliknięciu rozwija komponent cart-dropdown wyświetlający
                produkty w koszyku i ich szczegóły.<br />
                Z tego miejsca jest dostępny przycisk CHECKOUT,<!-- który
                przekierowuje do:
                <a href="https://zadanie-na-uczelnie.pl/checkout"
                  target="_blank">https://zadanie-na-uczelnie.pl/checkout</a>,<br />-->
                gdzie można obejrzeć produkty w koszyku i za nie zapłacić.
              </p>
              <p>
                <a class="popup-img" href="assets/images/cart.png"><img class="img-fluid border"
                    src="assets/images/cart.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import { toggleCartHidden } from '../../redux/cart/cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.
import { selectCartItemsCount } from '../../redux/cart/cart.selectors';  // selektor to getter dla store

import {
  CartContainer,
  ShoppingIcon,
  ItemCountContainer,
} from './cart-icon.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CartIcon = ({ toggleCartHidden, itemCount }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CartContainer onClick={toggleCartHidden}&gt;  // po kliknięciu na CartContainer zostanie wywołana funkcja toggleCartHidden, która została przekazana do tego komponentu za pomocą props
    &lt;ShoppingIcon /&gt;
    &lt;ItemCountContainer&gt;{itemCount}&lt;/ItemCountContainer&gt;  // ikona koszyka wyświetla liczbę odzwierciedlającą ilość produktów w koszyku, zmienna itemCount, została przekazana do tego komponentu za pomocą props
  &lt;/CartContainer&gt;
);

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik kliknie na ikonę koszyka, zmienna hidden w store zmieni się na przeciwną zmienną (albo true albo false)
  toggleCartHidden: () =&gt; dispatch(toggleCartHidden()),
});

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile produktów znajduje się w koszyku
  itemCount: selectCartItemsCount,
});

export default connect(mapStateToProps, mapDispatchToProps)(CartIcon);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_cart_icon_styles">
              <h4 class="mt-5">cart-icon.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components
import { ReactComponent as ShoppingIconSVG } from '../../assets/shopping-bag.svg';  // import grafiki shopping-bar (czyli ikony koszyka)

export const CartContainer = styled.header`  // tworzy komponent CartContainer, który renderuje tag html header z określonymi stylami
  width: 45px;
  height: 45px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
`;

CartContainer.displayName = 'CartContainer';  // po zrenderowaniu w DevTools komponent CartContainer wyświetlał by się jako styled.header, ale po zmianie parametru displayName wyświetli się jako CartContainer co ułatwi debugowanie

export const ShoppingIcon = styled(ShoppingIconSVG)`  // tworzy komponent ShoppingIcon, który renderuje plik shopping-bar.svg jako grafikę svg z określonymi stylami
  width: 24px;
  height: 24px;
`;

export const ItemCountContainer = styled.span`  // tworzy komponent ItemCountContainer, który renderuje tag html span z określonymi stylami
  position: absolute;
  font-size: 10px;
  font-weight: bold;
  bottom: 12px;
`;

ItemCountContainer.displayName = 'ItemCountContainer';  // po zrenderowaniu w DevTools komponent ItemCountContainer wyświetlał by się jako styled.header, ale po zmianie parametru displayName wyświetli się jako ItemCountContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_cart_icon_test">
              <h4 class="mt-5">cart-icon.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CartIcon } from './cart-icon.component';  // import komponentu, który będziemy testować

describe('CartIcon component', () => {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CartIcon
  let wrapper;  // tworzenie zmiennych do testów
  let mockToggleCartHidden;  // tworzenie zmiennych do testów

  beforeEach(() => {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockToggleCartHidden = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {  // mockowanie propsów przekazanych do CartIcon
      itemCount: 0,
      toggleCartHidden: mockToggleCartHidden,
    };

    wrapper = shallow(<CartIcon {...mockProps}/>);  // wyrenderuj komponent CartIcon z propsami wyżej
  });

  it('should render CartIcon component', () => {  // tworzy indywidualny test, który powinien wyrenderować komponent CartIcon
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CartIcon jest zgodny z snapshotem
  });

  it('should call toggleCartHidden when icon is clicked', () => {  // jeżeli ikona koszyka zostanie kliknięta wartość zmiennej hidden powinna zmienić się na przeciwną (albo true albo false)
    wrapper.find('CartContainer').simulate('click');  // symuluj kliknięcie na koszyk
    expect(mockToggleCartHidden).toHaveBeenCalled();  // jeżeli koszyk został kliknięty funkcja mockToggleCartHidden powinna zostać wywołana
  });

  it('should render the itemCount as the text', () => {  // zmienna itemCount powinna wyrenderować się jako string
    const itemCount = parseInt(wrapper.find('ItemCountContainer').text());  // znajdz komponent o nazwie ItemCountContainer, i przekonwertuj string na int
    expect(itemCount).toBe(0);  // przekowertowany int powinien równać się 0 (brak przedmiotów w koszyku)
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- cart-dropdown
              ============================ -->
          <section id="idocs_cart_dropdown">
            <h2>cart-dropdown</h2>
            <div id="idocs_cart_dropdown_component">
              <h4>cart-dropdown.component.jsx</h4>
              <p>
                Ten komponent rozwija się po kliknięciu na ikonę koszyka.
                Zawiera produkty dodane przez użytkownika, ich ilość i cenę.<br />
                Z tego miejsca jest dostępny przycisk CHECKOUT,<!-- który
                przekierowuje do: https://zadanie-na-uczelnie.pl/checkout,-->
                gdzie można obejrzeć produkty w koszyku i za nie zapłacić.
              </p>
              <p>
                <a class="popup-img" href="assets/images/cart-dropdown.png"><img class="img-fluid border"
                    src="assets/images/cart-dropdown.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami
import { withRouter } from 'react-router-dom';  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany.Selectors

import CartItem from '../cart-item/cart-item.component';  // import komponentu występującego w CartDropdown
import { selectCartItems } from '../../redux/cart/cart.selectors';  // selektor to getter dla store
import { toggleCartHidden } from '../../redux/cart/cart.actions.js';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import {
  CartDropdownContainer,
  CartDropdownButton,
  EmptyMessageContainer,
  CartItemsContainer,
} from './cart-dropdown.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CartDropdown = ({ cartItems, history, dispatch }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CartDropdownContainer&gt;
    &lt;CartItemsContainer&gt;
      {cartItems.length ? (  // jeżeli cartItems (tablica) ma długość większą niż 0 (ma w sobie jakieś obiekty)
        cartItems.map((cartItem) =&gt; (  // dla każdego obiektu w cartItems 
          &lt;CartItem key={cartItem.id} cartItem={cartItem} /&gt;  // wyrenderuj komponent CartItem z okreslonymi propsami
        ))
      ) : (
        &lt;EmptyMessageContainer&gt;Your cart is empty&lt;/EmptyMessageContainer&gt; // jeżeli cartItems jest puste wyświetl komunikat, że koszyk jest pusty
      )}
    &lt;/CartItemsContainer&gt;
    &lt;CartDropdownButton
      onClick={() =&gt; {  // jeżeli przycisk CHECKOUT został kliknięty
        history.push('/checkout');  // zmień url na /checkout
        dispatch(toggleCartHidden());  // schowaj koszyk, zmień wartość hidden na przeciwną (true albo false)
      }}
    &gt;
      CHECKOUT
    &lt;/CartDropdownButton&gt;
  &lt;/CartDropdownContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile produktów znajduje się w koszyku
  cartItems: selectCartItems,
});

export default withRouter(connect(mapStateToProps)(CartDropdown));  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany, connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_cart_dropdown_styles">
              <h4 class="mt-5">cart-dropdown.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w CartDropdown (przycisk CHECKOUT)

export const CartDropdownContainer = styled.aside`  // tworzy komponent CartDropdownContainer, który renderuje tag html aside z określonymi stylami
  position: absolute;
  width: 240px;
  height: 340px;
  display: flex;
  flex-direction: column;
  padding: 20px;
  border: 1px solid black;
  background-color: white;
  top: 60px;
  right: 10px;
  z-index: 5;
`;

export const CartDropdownButton = styled(CustomButton)`  // tworzy komponent CartDropdownButton, który renderuje komponent CustomButton z określonymi stylami
  margin-top: auto;
`;

CartDropdownButton.displayName = 'CartDropdownButton';  // po zrenderowaniu w DevTools komponent CartDropdownButton wyświetlał by się jako styled.button, ale po zmianie parametru displayName wyświetli się jako CartDropdownButton co ułatwi debugowanie

export const EmptyMessageContainer = styled.span`  // tworzy komponent EmptyMessageContainer, który renderuje tag html span z określonymi stylami
  font-size: 18px;
  margin: 50px auto;
`;

EmptyMessageContainer.displayName = 'EmptyMessageContainer';  // po zrenderowaniu w DevTools komponent EmptyMessageContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako EmptyMessageContainer co ułatwi debugowanie

export const CartItemsContainer = styled.div`  // tworzy komponent CartItemsContainer, który renderuje tag html div z określonymi stylami
  height: 240px;
  display: flex;
  flex-direction: column;
  overflow: auto;
`;</code></pre>
            </div>
            <div id="idocs_cart_dropdown_test">
              <h4 class="mt-5">cart-dropdown.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme'; // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CartDropdown } from './cart-dropdown.component';  // import komponentu, który będziemy testować
import CartItem from '../cart-item/cart-item.component';  // import komponentu, który występuje w CartDropdown

import { toggleCartHidden } from '../../redux/cart/cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

describe('CartDropdown component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CartDropdown
  let wrapper;  // tworzenie zmiennych do testów
  let mockHistory;  // tworzenie zmiennych do testów
  let mockDispatch;  // tworzenie zmiennych do testów
  const mockCartItems = [{ id: 1 }, { id: 2 }, { id: 3 }];  // tworzenie zmiennych do testów

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockHistory = {   // tworzenie zmiennych do testów
      push: jest.fn(),  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
    };

    mockDispatch = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {  // mockowanie propsów przekazanych do CartDropdown
      cartItems: mockCartItems,
      history: mockHistory,
      dispatch: mockDispatch,
    };

    wrapper = shallow(&lt;CartDropdown {...mockProps} /&gt;);  // wyrenderuj komponent CartDropdown z propsami wyżej
  });

  it('should render CartDropdown component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CartDropdown
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CartDropdown jest zgodny z snapshotem
  });

  it('should call history.push when button is clicked', () =&gt; {  // po kliknięciu w CHECKOUT, url strony powinien się zmienić i przenieść użytkownika na /checkout
    wrapper.find('CartDropdownButton').simulate('click');  // symulacja kliknięcia w CHECKOUT
    expect(mockHistory.push).toHaveBeenCalled();  // funkcja mockHistory.push powinna zostać wywołana
    expect(mockDispatch).toHaveBeenCalledWith(toggleCartHidden());  // "zamknij" koszyk, poprzez zmianę zmiennej hidden na przeciwną (true albo false)
  });

  it('should render an equal number of CartItem components as the cartItems prop', () =&gt; {  //  komponent powinien wyrenderować taką samą ilość komponentów cartItem z jakiej składa sięprop cartItems
    expect(wrapper.find(CartItem).length).toEqual(mockCartItems.length); // porównanie długości obu obiektów
  });

  it('should render EmptyMessageContainer if cartItems is empty', () =&gt; {  // jeżeli nie ma produtków w koszyku wyświetl tekst, koszyk jest pusty
    const mockProps = {   // nowe propsy z pustym cartItems
      cartItems: [],
      history: mockHistory,
      dispatch: mockDispatch,
    };

    const newWrapper = shallow(&lt;CartDropdown {...mockProps} /&gt;);  // wyrenderuj komponent z nowymi propsami
    expect(newWrapper.exists('EmptyMessageContainer')).toBe(true);  // szuka w CartDropdown EmptyMessageContainer, jeżeli go znajdzie zwróci prawdę
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- cart-item
              ============================ -->
          <section id="idocs_cart_item">
            <h2>cart-item</h2>
            <div id="idocs_cart_item_component">
              <h4>cart-item.component.jsx</h4>
              <p>
                Przedstawia pojedynczy produkt. Zawiera nazwę, zdjęcie, ilość i cenę produktu. <br />
                <strong>Wyświetla się w koszyku i na stronie checkout:</strong>
                <a href="https://zadanie-na-uczelnie/checkout" target="_blank">/checkout</a>
              </p>
              <p>
                <a class="popup-img" href="assets/images/cart-item.png"><img class="img-fluid border"
                    src="assets/images/cart-item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux

import { addItem, removeItem } from '../../redux/cart/cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import {
  CartItemContainer,
  ItemDetailsContainer,
  CartItemImage,
} from './cart-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

import { QuantityContainer } from '../checkout-item/checkout-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js, w tym przypadku z innego komponentu

const CartItem = ({ cartItem, addItem, removeItem }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { imageUrl, price, name, quantity } = cartItem; // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych
  return (
    &lt;CartItemContainer&gt;
      &lt;CartItemImage src={imageUrl} alt=&quot;item&quot; /&gt; // zdjęcie produktu
      &lt;ItemDetailsContainer&gt;
        &lt;span&gt;{name}&lt;/span&gt;  // nazwa produktu 
        &lt;QuantityContainer&gt;
          &lt;div onClick={() =&gt; removeItem(cartItem)}&gt;&amp;#10094;&lt;/div&gt; // strzałka w lewo - o 1 sztukę zmniejsz
          &lt;span&gt;{quantity}&lt;/span&gt;
          &lt;div onClick={() =&gt; addItem(cartItem)}&gt;&amp;#10095;&lt;/div&gt; // strzałka w prawo - o 1 sztukę w prawo
        &lt;/QuantityContainer&gt;
        &lt;span&gt;
          {quantity} x ${price} // ilość x cena
        &lt;/span&gt;
      &lt;/ItemDetailsContainer&gt;
    &lt;/CartItemContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli któraś ze strzałek zmniejszająca lub zwiększająca ilość produktów zostanie kliknięta zaktualizuj stan w store Redux
  addItem: (item) =&gt; dispatch(addItem(item)),
  removeItem: (item) =&gt; dispatch(removeItem(item)),
});

export default React.memo(connect(null, mapDispatchToProps)(CartItem));  // łączy komponent React ze store Redux, Jeśli twój komponent przy takich samych właściwościach zawsze renderuje tę samą strukturę, możesz opakować go w React.memo w celu poprawy wydajności. Oznacza to, że React pominie renderowanie tego komponentu i użyje jego ostatnio wyrenderowanej wersji, connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_cart_item_styles">
              <h4 class="mt-5">cart-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CartItemContainer = styled.section`  // tworzy komponent CartItemContainer, który renderuje tag html section z określonymi stylami
  width: 100%;
  display: flex;
  height: 80px;
  margin-bottom: 15px;
`;

export const CartItemImage = styled.img`  // tworzy komponent CartItemImage, który renderuje tag html img z określonymi stylami
  width: 30%;
`;

export const ItemDetailsContainer = styled.div`  // tworzy komponent ItemDetailsContainer, który renderuje tag html div z określonymi stylami
  width: 70%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
  padding: 10px 20px;

  span {  // style dla span'a znajdującego się w ItemDetailsContainer
    font-size: 14px;
    line-height: 12px;
    margin-bottom: 10px;
  }
`;</code></pre>
            </div>
            <div id="idocs_cart_item_test">
              <h4 class="mt-5">cart-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import CartItem from './cart-item.component';  // import komponentu, który będziemy testować

it('should render CartItem component', () =&gt; {  // sprawdza czy CartItem wyrenderował się poprawnie
  const mockItem = {
    imageUrl: 'www.testImage.com',
    price: 10,
    name: 'hats',
    quantity: 2,
  };

  expect(shallow(&lt;CartItem item={mockItem} /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany CartIcon jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- menu-item
              ============================ -->
          <section id="idocs_menu_item">
            <h2>menu-item</h2>
            <div id="idocs_menu_item_component">
              <h4>menu-item.component.jsx</h4>
              <p>
                Ten komponent odpowiada ze wyświetlenie kafelka z kategorią
                produktu. <br />
                Zawiera zdjęcie przedstawiające kategorię i przycisk
                pozwalający na przejście do indywidualnego URL każdej
                kategorii<!--, np.:<br />
                <a href="https://zadanie-na-uczelnie/shop/womens"
                  target="_blank">https://zadanie-na-uczelnie/shop/womens</a>-->
              </p>
              <p>
                <a class="popup-img" href="assets/images/menu-item.png"><img class="img-fluid border"
                    src="assets/images/menu-item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { withRouter } from 'react-router-dom';  // udostępnia obiekt historii i najbliższego dopasowania <Route> poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany

import {
  MenuItemContainer,
  BackgroundImageContainer,
  ContentContainer,
  ContentTitle,
} from './menu-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const MenuItem = ({ title, imageUrl, history, linkUrl, match }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;MenuItemContainer onClick={() =&gt; history.push(`${match.url}${linkUrl}`)}&gt;  // zmień url na /shop/{nazwa-kategorii-produktow}
    &lt;BackgroundImageContainer // kontener ze zdjęciem
      className=&quot;background-image&quot;
      imageUrl={imageUrl}
    /&gt;
    &lt;ContentContainer className=&quot;content&quot;&gt;  // kontener z przyciskiem z nazwą kategorii
      &lt;ContentTitle&gt;{title.toUpperCase()}&lt;/ContentTitle&gt;
    &lt;/ContentContainer&gt;
  &lt;/MenuItemContainer&gt;
);

export default withRouter(MenuItem);  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany.Selectors</code></pre>
            </div>
            <div id="idocs_menu_item_styles">
              <h4 class="mt-5">menu-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const MenuItemContainer = styled.section`  // tworzy komponent MenuItemContainer, który renderuje tag html section z określonymi stylami
  height: 380px;
  min-width: 30%;
  overflow: hidden;
  flex: 1 1 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid black;
  margin: 0 7.5px 15px;
  overflow: hidden;

  &amp;:hover {   // style dla MenuItemContainer, gdy najeżdzamy na komponent myszką
    cursor: pointer;
    border: 1px solid #e08800;

    &amp; .background-image {   // zmiana styli dla .background-image gdy najeżdzamy myszką na MenuItemContainer
      transform: scale(1.1);
      transition: transform 6s cubic-bezier(0.25, 0.45, 0.45, 0.95);
    }

    &amp; .content {  // zmiana styli dla .content gdy najeżdzamy myszką na MenuItemContainer
      opacity: 0.8;
      border: 1px solid #e08800;
      color: #e08800;
    }
  }

  &amp;:first-child {   // style dla pierwszego dziecka MenuItemContainer 
    margin-right: 7.5px;
  }

  &amp;:last-child {  // style dla ostatniego dziecka MenuItemContainer 
    margin-left: 7.5px;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    height: 240px;
    min-width: 50vw;
  }
`;

MenuItemContainer.displayName = 'MenuItemContainer';  // po zrenderowaniu w DevTools komponent MenuItemContainer wyświetlał by się jako styled.section, ale po zmianie parametru displayName wyświetli się jako MenuItemContainer co ułatwi debugowanie

export const BackgroundImageContainer = styled.div`  // tworzy komponent BackgroundImageContainer, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  background-image: ${({ imageUrl }) =&gt; `url(${imageUrl})`};
`;

BackgroundImageContainer.displayName = 'BackgroundImageContainer';  // po zrenderowaniu w DevTools komponent BackgroundImageContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako BackgroundImageContainer co ułatwi debugowanie

export const ContentContainer = styled.div`  // tworzy komponent ContentContainer, który renderuje tag html div z określonymi stylami
  height: 90px;
  padding: 0 25px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: 1px solid black;
  background-color: white;
  opacity: 0.6;
  position: absolute;
  text-align: center;
  width: 165px;
`;

export const ContentTitle = styled.span`  // tworzy komponent ContentTitle, który renderuje tag html span z określonymi stylami
  font-weight: bold;
  margin-bottom: 6px;
  font-size: 22px;
`;</code></pre>
            </div>
            <div id="idocs_menu_item_test">
              <h4 class="mt-5">menu-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';

import { MenuItem } from './menu-item.component';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

describe('MenuItem component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu MenuItem
  let wrapper;  // tworzenie zmiennych do testów
  let mockMatch;
  let mockHistory;
  const linkUrl = '/hats';
  const size = 'large';
  const imageUrl = 'testimage';

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockMatch = {  // tworzenie zmiennych do testów
      url: '/shop',
    };

    mockHistory = {  // tworzenie zmiennych do testów
      push: jest.fn(),  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
    };

    const mockProps = {  // mockowanie propsów przekazanych do MenuItem
      match: mockMatch,
      history: mockHistory,
      linkUrl,
      size,
      title: 'hats',
      imageUrl,
    };

    wrapper = shallow(&lt;MenuItem {...mockProps} /&gt;);  // wyrenderuj komponent MenuItem z propsami wyżej
  });

  it('should render MenuItem component', () =&gt; {  // test sprawdza czy MenuItem wyrenderował się prawidłowo
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany MenuItem jest zgodny z snapshotem
  });

  it('should call history.push with the right string when MenuItemContainer clicked', () =&gt; {  // funkcja history.push powinna zostać wywołana, gdy kafelek z nazwą kategorii zostanie klinięty
    wrapper.find('MenuItemContainer').simulate('click');  // symuluj kliknięcie na MenuItemContainer

    expect(mockHistory.push).toHaveBeenCalledWith(`${mockMatch.url}${linkUrl}`);  // sprawdzenie czy użytkownik jest przekierowany do prawidłowo url
  });

  it('should pass size to MenuItemContainer as the prop size', () =&gt; {  // sprawdź czy prop size został przekazany to MenuItemContainer
    expect(wrapper.find('MenuItemContainer').prop('size')).toBe(size);
  });

  it('should pass imageUrl to BackgroundImageContainer as the prop imageUrl', () =&gt; {  // sprawdź czy prop imageURl został przekazany do BackgroundImageContainer
    expect(wrapper.find('BackgroundImageContainer').prop('imageUrl')).toBe(
      imageUrl
    );
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- directory
              ============================ -->
          <section id="idocs_directory">
            <h2>directory</h2>
            <div id="idocs_directory_component">
              <h4>directory.component.jsx</h4>
              <p>
                Directory jest głównym konterem, który zawiera w sobie kafelki
                MenuItem poszczególnych kategorii produtków.
              </p>
              <p>
                <a class="popup-img" href="assets/images/directory.png"><img class="img-fluid border"
                    src="assets/images/directory.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import { selectDirectorySections } from '../../redux/directory/directory.selectors';  // selektor to getter dla store

import MenuItem from '../menu-item/menu-item.component';  // import komponentu występującego w Dropdown

import { DirectoryMenuContainer } from './directory.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const Directory = ({ sections }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;DirectoryMenuContainer&gt;
    {sections.map(({ id, ...otherSectionProps }) =&gt; (  // dla każdego obiektu w sections 
      &lt;MenuItem key={id} {...otherSectionProps} /&gt;  // wyrenderuj komponent MenuItem z okreslonymi propsami
    ))}
  &lt;/DirectoryMenuContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile sekcji komponent powinien wyrenderować i z jaką treścią
  sections: selectDirectorySections,
});

export default connect(mapStateToProps)(Directory);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_directory_styles">
              <h4 class="mt-5">directory.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const DirectoryMenuContainer = styled.article`  // tworzy komponent DirectoryMenuContainer, który renderuje tag html article z określonymi stylami
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
`;</code></pre>
            </div>
            <div id="idocs_directory_test">
              <h4 class="mt-5">directory.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { Directory } from './directory.component';  // import komponentu, który będziemy testować

it('should render Directory component', () => {  // sprawdzenie czy komponent Directory prawidłowo się renderuje
  expect(shallow(<Directory sections={[]}/>)).toMatchSnapshot();  // sprawdź czy wyrenderowany Directory jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- footer
              ============================ -->
          <section id="idocs_footer">
            <h2>footer</h2>
            <div id="idocs_footer_component">
              <h4>footer.component.jsx</h4>
              <p>
                <strong>Footer wyświetla się na każdej stronie na dole.</strong>
                To prosty komponent wyświetlający Autora aplikacji.
              </p>
              <p>
                <a class="popup-img" href="assets/images/footer.png"><img class="img-fluid border"
                    src="assets/images/footer.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import { FooterContainer, AuthorContainer } from './footer.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const Footer = () =&gt; (  // deklaracja komponentu funkcyjnego
  &lt;FooterContainer&gt;
    &lt;AuthorContainer&gt;&amp;copy; Ingrid Pruszyńska&lt;/AuthorContainer&gt;  // wypisanie Autora
  &lt;/FooterContainer&gt;
);

export default Footer;  // wyeksportowanie komponentu (aby inny komponent mógł go użyć)</code></pre>
            </div>
            <div id="idocs_footer_styles">
              <h4 class="mt-5">footer.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const FooterContainer = styled.footer`  // tworzy komponent FooterContainer, który renderuje tag html footer z określonymi stylami  height: 50px;
  width: 100%;
  margin-top: 30px;
  text-align: center;
`;

export const AuthorContainer = styled.div`  // tworzy komponent AuthorContainer, który renderuje tag html div z określonymi stylami
  font-size: 22px;
  padding: 20px 0 5px 0;
  border-top: 2px solid black;
  position: absolute;
  bottom: 0;
  width: 100%;

  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    font-size: 18px;
    a {
      padding: 5px 8px;
    }
  }
  @media screen and (max-width: 350px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 350px
    font-size: 16px;
    a {
      padding: 2px 4px;
    }
  }
`;</code></pre>
            </div>
            <div id="idocs_footer_test">
              <h4 class="mt-5">footer.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { Footer } from './footer.component';  // import komponentu, który będziemy testować

it('should render Footer component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent Footer
  expect(shallow(&lt;Footer /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany Footer jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- shop-page
        ============================ -->
          <section id="idocs_shoppage">
            <h2>shop</h2>
            <div id="idocs_shop_component">
              <h4>shop.component.jsx</h4>
              <!--<p class="lead mb-4">
                Strona "SHOP" znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/shop" target="_blank">https://zadanie-na-uczelnie.pl/shop</a>
              </p>-->
              <p>
                Shop page zawiera header i pierwsze 4 produkty wszystkich kategorii produktów oraz stopkę z
                autorem.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów
                odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">Shop page</strong>
                znajduje się
                <strong style="color: rgb(0, 0, 255)">CollectionsOverview</strong>, a w nim
                <strong style="color: rgb(255, 0, 255)">CollectionPreview</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/shoppage.png"><img class="img-fluid border"
                    src="assets/images/shoppage.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React, { useEffect, lazy, Suspense } from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useEffect - pozwala na uruchomienie dodatkowego kodu po tym, jak React zaktualizuej drzewo DOM, lazy - pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty, suspense - komponent wyrenderowany poprzez lazy() powinien zostać wyrenderowany wewnątrz suspense(), dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. kręcące się kółko)
import { Route } from 'react-router-dom';  // route renderuje interfejs użytkownika, gdy jego ścieżka pasuje do bieżącego adresu URL
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux

import { fetchCollectionsStart } from '../../redux/shop/shop.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import Spinner from '../../components/spinner/spinner.component';  // komponent zastępczy (będzie wyświetlał kręcące się kółko, w trakcie ładowania komponentów)

import { ShopPageContainer } from './shop.styles';  // // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const CollectionsOverviewContainer = lazy(() =&gt;
  import('../../components/collections-overview/collections-overview.container')
);  // import CollectionsOverviewContainer poprzez funkcję lazy()

const CollectionPageContainer = lazy(() =&gt;  
  import('../collection/collection.container')
);  // import CollectionPageContainer poprzez funkcję lazy()

export const ShopPage = ({ fetchCollectionsStart, match }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  useEffect(() =&gt; {
    fetchCollectionsStart();
  }, [fetchCollectionsStart]);  // za pierwszym razem po zrenderowaniu DOMu wywołaj funkcję fetchCollectionsStart, jest tu użyta tablica optymalizacyjna, co znaczy, że komponent wyrenderuje się jeszcze raz jeżeli stan fetchCollectionsStart się zmieni

  return (
    &lt;ShopPageContainer&gt;
      &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;  // zanim fetchCollectionsStart zwróci zawartość kolekcji wyświetl obracający się spinner 
        &lt;Route
          exact
          path={`${match.path}`}
          component={CollectionsOverviewContainer}
        /&gt; // nawigacja zmieni url zgodnie z path
        &lt;Route
          path={`${match.path}/:collectionId`}  // collectionId to id kategorii produktów
          component={CollectionPageContainer}
        /&gt;
      &lt;/Suspense&gt;
    &lt;/ShopPageContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({
  fetchCollectionsStart: () =&gt; dispatch(fetchCollectionsStart()),
});  // aktualizuje stan store w Redux tym co zwróci fetchCollectionsStart

export default connect(null, mapDispatchToProps)(ShopPage);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_shop_styles">
              <h4 class="mt-5">shop.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components i animacji

const fadeIn = keyframes` // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
export const ShopPageContainer = styled.article`  // tworzy komponent ShopPageContainer, który renderuje tag html article z określonymi stylami
  width: 100%;
  animation: 0.2s ${fadeIn};
`;</code></pre>
            </div>
            <div id="idocs_shop_test">
              <h4 class="mt-5">shop.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { mount } from 'enzyme';  // metoda, która ponownie montuje komponent, jeśli nie jest on aktualnie zamontowany. Można to wykorzystać do symulacji komponentu przechodzącego przez cykl życia odmontowania/montowania.
import { combineReducers, createStore } from 'redux';  // funkcja pomocnicza combineReducers() zamienia obiekt, którego wartości są różnymi funkcjami redukującymi, w pojedynczą funkcję redukującą, którą możesz przekazać do createStore. Wynikowy reducer wywołuje każdy reducer podrzędny i gromadzi ich wyniki w jednym obiekcie state. State wytworzony przez combineReducers() jest przestrzenią nazw stanów każdego reducera pod ich kluczami przekazanymi do combineReducers(), import funkcji createStore, która tworzy store Redux, który przechowuje pełne drzewo state
import { BrowserRouter } from 'react-router-dom';  // rozwinięcie &lt;Router&gt;, kt&oacute;re używa interfejsu API historii HTML5 (pushState, replaceState i zdarzenia popstate), aby synchronizować interfejs użytkownika z adresem URL
import { Provider } from 'react-redux';  // aby odczytać stan ze store i wysyłać action do store, musimy wyrenderować komponent Provider wokół aplikacji, przekazując store redux jako prop do Provider

import { ShopPage } from './shop.component';  // import komponentu, który będziemy testować

export const createMockStore = ({ state, reducers }) => {  // import funkcji createStore, która tworzy store Redux, który przechowuje pełne drzewo state i applyMiddleware, czyli oprogramowanie pośrednicząca między funkcją dispatch,a store
  const store = createStore(combineReducers(reducers), state);
  return {
    ...store,
    persistor: {
      persist: () => null,
    },
  };
};

describe('ShopPage', () => {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu ShopPage
  let wrapper;  // tworzenie zmiennych do testów
  let mockFetchCollectionsStart;
  let store;

  beforeEach(() => {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    const mockReducer = (  // mockowanie propsów przekazanych do ShopPage
      state = {
        isFetching: true,
      },
      action
    ) => state;

    const mockState = {  // mockowanie propsów przekazanych do ShopPage
      shop: {
        isFetching: true,
      },
    };

    mockFetchCollectionsStart = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości

    store = createMockStore({  // zmokowany store
      state: mockState,
      reducers: { shop: mockReducer },
    });

    const mockMatch = {  // zmokowany path do nawigacji
      path: '',
    };

    const mockProps = {  // zmokowanePropsy
      match: mockMatch,
      fetchCollectionsStart: mockFetchCollectionsStart,
    };

    wrapper = mount(  // symuluj montowanie komponentu, montowanie to faza, w której nasz komponent React montuje się na DOM (tj. jest tworzony i wstawiany do DOM).  Ta faza pojawia się na scenie po zakończeniu fazy inicjalizacji. W tej fazie nasz komponent renderuje po raz pierwszy
      <BrowserRouter>  // do nawigacji
        <Provider store={store}>  // nasz store
          <ShopPage {...mockProps}/>  // komponent ShopPage z mockowanymi propsami
        </Provider>
      </BrowserRouter>
    );
  });

  it('should render ShopPage component', () => {
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany ShopPage jest zgodny z snapshotem
  });

  it('should call mockFetchCollectionsStart on render', () => {
    expect(mockFetchCollectionsStart).toHaveBeenCalled();  // sprawdź czy funkcje mockFetchCollectionsStart uruchomiła się
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collections_overview
        ============================ -->
          <section id="idocs_collections_overview">
            <h2>collections-overview</h2>
            <div id="idocs_collections_overview_container">
              <h4>collections-overview.container.jsx</h4>
              <p>
                <strong style="color: rgb(0, 0, 255)">CollectionsOverview</strong> zawiera listę <strong
                  style="color: rgb(255, 0, 255)">CollectionPreview</strong>. Można powiedzieć, że jest
                pewnego rodzaju
                wrapperem.
              </p>
              <p>Dlaczego używamy .container i .component? Container określa dane, które powinien renderować
                .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu,
                takich jak
                connect() z Redux. Jest to tzw. Container Pattern. </p>
              <p>
                <a class="popup-img" href="assets/images/collections_overview.png"><img class="img-fluid border"
                    src="assets/images/collections_overview.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami
import { compose } from 'redux';  // komponuje funkcje od prawej do lewej. Służy do zastosowania kilku "ulepszaczy" store z rzędu.

import { selectIsCollectionFetching } from '../../redux/shop/shop.selectors';  // selektor to getter dla store
import WithSpinner from '../with-spinner/with-spinner.component';  // import komponentu występującego w collections-overview.container
import CollectionsOverview from './collections-overview.component';  // import komponentu występującego w collections-overview.container

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym czy lista produktów się "loadinguje"
  isLoading: selectIsCollectionFetching,
});

const CollectionsOverviewContainer = compose(  // deklaracje komponentu, jeżeli produkty się nie załadowały wyświetlaj obracające się kółko w miejsce komponentu
  connect(mapStateToProps),  // connect łączy komponent React ze store Redux
  WithSpinner
)(CollectionsOverview);

export default CollectionsOverviewContainer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_collections_overview_component">
              <h4>collections-overview.component.jsx</h4>
              <p>Dlaczego używamy .container i .component? .container określa dane, które powinien renderować
                .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu,
                takich jak
                connect() z Redux. Jest to tzw. Container Pattern. </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import CollectionPreview from '../collection-preview/collection-preview.component';  // import komponentu występującego w collections-overview.component

import { selectCollectionsForPreview } from '../../redux/shop/shop.selectors';  // selektor to getter dla store
import { CollectionsOverviewContainer } from './collections-overview.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionsOverview = ({ collections }) => (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  <CollectionsOverviewContainer>
    {collections.map(({ id, ...otherCollectionProps }) => (  // iteruj po tablicy collections (kategorie produktów, np. womens, mens), dla każdego obiektu wyrenderuj CollectionPreview
      <CollectionPreview key={id} {...otherCollectionProps}/>
    ))}
  </CollectionsOverviewContainer>
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o kolekcjach (kategoriach produktów)
  collections: selectCollectionsForPreview,
});

export default connect(mapStateToProps)(CollectionsOverview);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_collections_overview_styles">
              <h4 class="mt-5">collections-overview.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CollectionsOverviewContainer = styled.article`  // tworzy komponent CollectionsOverviewContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
`;</code></pre>
            </div>
            <div id="idocs_collections_overview_test">
              <h4 class="mt-5">collections-overview.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { CollectionsOverview } from './collections-overview.component';  // import komponentu, który będziemy testować

it('should render CollectionsOverview component', () => {  // wyrenderuj komponent CollectionsOverview
  expect(shallow(<CollectionsOverview collections={[]}/>)).toMatchSnapshot();  // sprawdź czy wyrenderowany CartIcon jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collection_preview
        ============================ -->
          <section id="idocs_collection_preview">
            <h2>collection-preview</h2>
            <div id="idocs_collection_preview_component">
              <h4>collection-preview.component.jsx</h4>
              <p><strong style="color: rgb(255, 0, 255)">CollectionPreview</strong> wyświetla tytuł oraz 4
                pierwsze
                produkty z danej kolekcji, jaką otrzyma w propsach.
                Pojedynczy produkt jest wyrenderowany za pomocą komponentu <strong
                  style="color: rgb(0, 255, 0)">CollectionItem</strong>.
              </p>
              <p>
                <a class="popup-img" href="assets/images/collection_preview.png"><img class="img-fluid border"
                    src="assets/images/collection_preview.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { withRouter } from 'react-router-dom';  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany.Selectors

import CollectionItem from '../collection-item/collection-item.component';  // import komponentu występującego w CollectionPreview

import {
  CollectionPreviewContainer,
  TitleContainer,
  PreviewContainer,
} from './collection-preview.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionPreview = ({
  title,
  items,
  history,
  match,
  routeName,
}) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CollectionPreviewContainer&gt;
    &lt;TitleContainer onClick={() =&gt; history.push(`${match.path}/${routeName}`)}&gt;  // po kliknięciu na tytuł przekieruj użytkownika na oddzielną podstronę kolekcji
      {title.toUpperCase()}  // tytuł kolekcji np. womens
    &lt;/TitleContainer&gt;
    &lt;PreviewContainer&gt;
      {items  // items zawiera pojedyncze produkty kolekcji wyrenderuj komponent CollectionItem
        .filter((item, idx) =&gt; idx &lt; 4)  // wyświetl 4 pierwsze produkty
        .map((item) =&gt; (
          &lt;CollectionItem key={item.id} item={item} /&gt;  // dla 4 pierwszych produktów wyrenderuj komponent CollectionItem
        ))}
    &lt;/PreviewContainer&gt;
  &lt;/CollectionPreviewContainer&gt;
);

export default withRouter(CollectionPreview);  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany.Selectors</code></pre>
            </div>
            <div id="idocs_collection_preview_styles">
              <h4 class="mt-5">collection-preview.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CollectionPreviewContainer = styled.article`  // tworzy komponent CollectionPreviewContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
  margin-bottom: 10px;

  @media screen and (max-width: 800px) {
    align-items: center;
  }
`;

export const TitleContainer = styled.h1`  // tworzy komponent TitleContainer, który renderuje tag html h1 z określonymi stylami
  font-size: 28px;
  margin-bottom: 25px;
  cursor: pointer;

  &amp;:hover {
    color: #e08800;
  }
`;

TitleContainer.displayName = 'TitleContainer';  // po zrenderowaniu w DevTools komponent TitleContainer wyświetlał by się jako styled.h1, ale po zmianie parametru displayName wyświetli się jako TitleContainer co ułatwi debugowanie

export const PreviewContainer = styled.div`  // tworzy komponent PreviewContainer, który renderuje tag html div z określonymi stylami
  display: flex;
  justify-content: space-between;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    display: grid;
    grid-template-columns: 250px 250px;
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    grid-template-columns: 250px;
  }
`;</code></pre>
            </div>
            <div id="idocs_collection_preview_test">
              <h4 class="mt-5">collection-preview.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CollectionPreview } from './collection-preview.component';  // import komponentu, który będziemy testować

describe('CollectionPreview component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CollectionPreview
let wrapper;  // tworzenie zmiennych do testów
let mockMatch;
let mockHistory;
const mockRouteName = 'hats';

beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
  mockMatch = {
    path: '/shop',
  };

  mockHistory = {
    push: jest.fn(),  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
  };

  const mockProps = {  // mockowanie propsów przekazanych do CollectionPreview
    match: mockMatch,
    history: mockHistory,
    routeName: mockRouteName,
    title: 'hats',
    items: [],
  };

  wrapper = shallow(&lt;CollectionPreview {...mockProps} /&gt;);  // wyrenderuj komponent CollectionPreview z propsami wyżej
});

it('should render CollectionPreview component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CollectionPreview
  expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CollectionPreview jest zgodny z snapshotem
});

it('should call history.push with the right string when TitleContainer clicked', () =&gt; {  // jeżeli tytuł kolekcji zostanie kliknięty, przekieruj użytkownika na stronę tej kolekcji
  wrapper.find('TitleContainer').simulate('click');  // symuluj kliknięcie

  expect(mockHistory.push).toHaveBeenCalledWith(
    `${mockMatch.path}/${mockRouteName}`  // sprawdz czy url się zmienił
  );
});
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collection_item
        ============================ -->
          <section id="idocs_collection_item">
            <h2>collection-item</h2>
            <div id="idocs_collection_item_component">
              <h4>collection-item.component.jsx</h4>
              <p>CollectionItem wyświetla zdjęcie produktu, nazwę i cenę na podstawie otrzymanych propsów.
                Używany jest
                w
                wielu komponentach.</p>
              <p>
                <a class="popup-img" href="assets/images/collection_item.png"><img class="img-fluid border"
                    src="assets/images/collection_item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
  
import { addItem } from '../../redux/cart/cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import {
  CollectionItemContainer,
  CollectionFooterContainer,
  AddButton,
  BackgroundImage,
  NameContainer,
  PriceContainer,
} from './collection-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionItem = ({ item, addItem }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { name, price, imageUrl } = item;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

  return (
    &lt;CollectionItemContainer&gt;
      &lt;BackgroundImage className=&quot;image&quot; imageUrl={imageUrl} /&gt;  // zdjęcie produktu
      &lt;CollectionFooterContainer&gt;
        &lt;NameContainer&gt;{name}&lt;/NameContainer&gt;  // nazwa
        &lt;PriceContainer&gt;{price}&lt;/PriceContainer&gt;  // cena
      &lt;/CollectionFooterContainer&gt;
      &lt;AddButton onClick={() =&gt; addItem(item)} inverted&gt;  // po kliknięciu dodaje produkt do koszyka
        Add to cart
      &lt;/AddButton&gt;
    &lt;/CollectionItemContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik kliknie na przycisk Add to cart, w store zmieni się stan koszyka reprezentujący ilość produktów
  addItem: (item) =&gt; dispatch(addItem(item)),
});

export default connect(null, mapDispatchToProps)(CollectionItem);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_collection_item_styles">
              <h4 class="mt-5">collection-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w Collectionitem (przycisk Add to cart)

export const CollectionItemContainer = styled.article`  // tworzy komponent CollectionItemContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 400px;
  height: 550px;
  align-items: center;
  position: relative;
  margin-bottom: 20px;

  &amp;:hover {  // przy najechaniu myszką na komponent CollectionItemContainer, aktywują się style poniżej
    .image {
      opacity: 0.8;
    }

    button {
      opacity: 0.85;
      display: flex;
    }

    div {
      color: #e08800;
    }
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    max-width: 400px;
    &amp;:hover {
      .image {
        opacity: unset;
      }
      button {
        opacity: unset;
      }
    }
  }
  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    max-width: 500px;
  }
`;

export const AddButton = styled(CustomButton)`  // tworzy komponent AddButton, który renderuje się na podstawie komponentu CustomButton z określonymi stylami
  width: 80%;
  opacity: 0.7;
  position: absolute;
  top: 450px;
  display: none;
 
  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    display: block;
    opacity: 0.9;
    min-width: unset;
    padding: 0 10px;
  }
`;

AddButton.displayName = 'AddButton';  // po zrenderowaniu w DevTools komponent AddButton wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako AddButton co ułatwi debugowanie

export const BackgroundImage = styled.div`  // tworzy komponent BackgroundImage, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 95%;
  background-size: cover;
  background-position: center;
  margin-bottom: 5px;
  background-image: ${({ imageUrl }) =&gt; `url(${imageUrl})`};
`;

BackgroundImage.displayName = 'BackgroundImage';  // po zrenderowaniu w DevTools komponent BackgroundImage wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako BackgroundImage co ułatwi debugowanie

export const CollectionFooterContainer = styled.div`  // tworzy komponent CollectionFooterContainer, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 5%;
  display: flex;
  justify-content: space-between;
  font-size: 18px;
`;

CollectionFooterContainer.displayName = 'CollectionFooterContainer';  // po zrenderowaniu w DevTools komponent CollectionFooterContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako CollectionFooterContainer co ułatwi debugowanie

export const NameContainer = styled.span`  // tworzy komponent NameContainer, który renderuje tag html span z określonymi stylami
  width: 90%;
  margin-bottom: 15px;
`;

NameContainer.displayName = 'NameContainer';  // po zrenderowaniu w DevTools komponent NameContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako NameContainer co ułatwi debugowanie

export const PriceContainer = styled.span`  // tworzy komponent PriceContainer, który renderuje tag html span z określonymi stylami
  width: 10%;
  text-align: right;
`;

PriceContainer.displayName = 'PriceContainer';  // po zrenderowaniu w DevTools komponent PriceContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako PriceContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_collection_item_test">
              <h4 class="mt-5">collection-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CollectionItem } from './collection-item.component';  // import komponentu, który będziemy testować

describe('CollectionItem component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CollectionItem
  let wrapper;  // tworzenie zmiennych do testów
  let mockAddItem;
  const imageUrl = 'www.testImage.com';
  const mockName = 'black hat';
  const mockPrice = 10;
 
  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockAddItem = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.

    const mockProps = {  // mockowanie propsów przekazanych do CollectionItem
      item: {
        imageUrl: imageUrl,
        price: mockPrice,
        name: mockName,
      },
      addItem: mockAddItem,
    };

    wrapper = shallow(&lt;CollectionItem {...mockProps} /&gt;);  // wyrenderuj komponent CollectionItem z propsami wyżej
  });

  it('should render CollectionItem component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CollectionItem
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CollectionItem jest zgodny z snapshotem
  });

  it('should call addItem when AddButton clicked', () =&gt; {  // po kliknięciu na Add to cart, wywołaj funkcję dodania produktu do stanu
    wrapper.find('AddButton').simulate('click');  // symuluj kliknięcie

    expect(mockAddItem).toHaveBeenCalled();  // jeżeli przycisk został kliknięty funkcja mockAddItem powinna zostać wywołana
  });

  it('should render imageUrl as a prop on BackgroundImage', () =&gt; {  // sprawdź czy zdjęcie produktu wyrenderowało się prawidłowo
    expect(wrapper.find('BackgroundImage').prop('imageUrl')).toBe(imageUrl);
  });

  it('should render name prop in NameContainer', () =&gt; {  // sprawdź czy nazwa produktu wyrenderowała się prawidłowo
    expect(wrapper.find('NameContainer').text()).toBe(mockName);
  });

  it('should render price prop in PriceContainer', () =&gt; {  // sprawdź czy cena produktu wyrenderowała się prawidłowo
    const price = parseInt(wrapper.find('PriceContainer').text());
    expect(price).toBe(mockPrice);
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- custom_button
        ============================ -->
          <section id="idocs_custom_button">
            <h2>custom-button</h2>
            <div id="idocs_custom_button_component">
              <h4>custom-button.component.jsx</h4>
              <p>CustomButton to komponent przedstawiający przycisk. Używany w wielu komponentach, aby nie
                powtarzać
                styli. Dzięki styled components można warunkowo zmieniać np. kolor tła przycisku, a za
                pomocą propsów
                tekst na przycisku.</p>
              <p>
                <a class="popup-img" href="assets/images/custom_button.png"><img class="img-fluid border"
                    src="assets/images/custom_button.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import { CustomButtonContainer } from './custom-button.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CustomButton = ({ children, ...props }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CustomButtonContainer {...props}&gt;{children}&lt;/CustomButtonContainer&gt;
);

export default CustomButton;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_custom_button_styles">
              <h4 class="mt-5">custom-button.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { css } from 'styled-components';  // import biblioteki styled components

const buttonStyles = css`  // określa grupę atrybutów css, nie renderuje tagu html sam w sobie
  background-color: #e08800;
  color: white;
  border: 1px solid transparent;

  &amp;:hover {
    background-color: white;
    color: #e08800;
    border: 1px solid #e08800;
  }
`;

const invertedButtonStyles = css`  // określa grupę atrybutów css, nie renderuje tagu html sam w sobie
  background-color: white;
  color: black;
  border: 1px solid black;

  &amp;:hover {
    background-color: #e08800;
    color: white;
    border: 1px solid transparent;
  }
`;

const getButtonStyles = (props) =&gt; {
  return props.inverted ? invertedButtonStyles : buttonStyles;  // jeżeli do CustomButton przekażemy props inverted, przycisk zostanie wyrenderowany ze stylami z grupy invertedButtonStyles powyżej, jeżeli nie to użyje grupy buttonStyles
};

export const CustomButtonContainer = styled.button`  // tworzy komponent CustomButtonContainer, który renderuje tag html button z określonymi stylami
  min-width: 165px;
  width: auto;
  height: 50px;
  letter-spacing: 0.5px;
  line-height: 50px;
  padding: 0 35px 0 35px;
  font-size: 15px;
  text-transform: uppercase;
  font-weight: bolder;
  cursor: pointer;
  display: flex;
  justify-content: center;

  ${getButtonStyles}  // do cssa powyżej dodaj kod funkcję getButtonStyles, która na podstawie różnych warunków może dodać tutaj więcej cssa
`;</code></pre>
            </div>
            <div id="idocs_custom_button_test">
              <h4 class="mt-5">custom-button.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { CustomButton } from './custom-button.component';  // import komponentu, który będziemy testować

it('should render CustomButton component', () => {  // wyrenderuj komponent CustomButton
  expect(shallow(<CustomButton/>)).toMatchSnapshot();  // sprawdź czy wyrenderowany CustomButton jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- with_spinner
        ============================ -->
          <section id="idocs_with_spinner">
            <h2>with-spinner</h2>
            <div id="idocs_with_spinner_component">
              <h4>with-spinner.component.jsx</h4>
              <p>WithSpinner generuje się "w miejscu" komponentu, który czeka na np. otrzymanie informacji z
                bazy
                danych. Przyjmuje formę obracającego się kółka. Ma to zapobiec wrażeniu, że strona nie
                działa prawidłowo
                i dać znać użytkownikowi, że coś się ładuje i trzeba poczekać.</p>
              <p>
                <a class="popup-img" href="assets/images/with_spinner.png"><img class="img-fluid border"
                    src="assets/images/with_spinner.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import Spinner from '../spinner/spinner.component';  // import komponentu występującego w WithSpinner

const WithSpinner =  
  (WrappedComponent) =&gt;  
  ({ isLoading, ...otherProps }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
    return isLoading ? &lt;Spinner /&gt; : &lt;WrappedComponent {...otherProps} /&gt;;  // jeżeli komponent się "ładuje" wyświetl kręcące się kółko
  };

export default WithSpinner;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_with_spinner_test">
              <h4 class="mt-5">with-spinner.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import WithSpinner from './with-spinner.component';  // import komponentu, który będziemy testować
import Spinner from '../spinner/spinner.component';  // import komponentu, występującego w WithSpinner

describe('WithSpinner HOC', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu WithSpinner
  const TestComponent = () =&gt; &lt;div className=&quot;test&quot; /&gt;;  // tworzenie zmiennych do testów
  const WrappedComponent = WithSpinner(TestComponent);  // komponent TestComponent jest "zawinięty" w komponent WithSpinner

  describe('if loading is true', () =&gt; {  // jeżeli komponent jest w trakcie ładowania
    it('should render Spinner component', () =&gt; {  // wyrenderuj kręcący się spinner
      const wrapper = shallow(&lt;WrappedComponent isLoading={true} /&gt;);

      expect(wrapper.exists(Spinner)).toBe(true);  // sprawdź czy w DOMie istnieje spinner
    });

    it('should not render component', () =&gt; {  // nie powinien wyrenderować komponentu
      const wrapper = shallow(&lt;WrappedComponent isLoading={true} /&gt;);  // komponent NIE powinien się wyrenderować

      expect(wrapper.exists(TestComponent)).toBe(false);  // sprawdź czy w DOMie istnieje komponent
    });
  });

  describe('if loading is false', () =&gt; {  // jeżeli komponent nie jest w trakcie ładowania
    it('should render component', () =&gt; {  // wyrenderuj komponent
      const wrapper = shallow(&lt;WrappedComponent isLoading={false} /&gt;);

      expect(wrapper.exists(TestComponent)).toBe(true);  // sprawdź czy w DOMie istnieje komponent
    });

    it('should not render Spinner', () =&gt; {  // nie powinien wyrenderować kręcącego się spinnera
      const wrapper = shallow(&lt;WrappedComponent isLoading={false} /&gt;);

      expect(wrapper.exists(Spinner)).toBe(false);  // sprawdź czy w DOMie istnieje spinner
    });
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- spinner
        ============================ -->
          <section id="idocs_spinner">
            <h2>spinner</h2>
            <div id="idocs_spinner_component">
              <h4>spinner.component.jsx</h4>
              <p>Spinner przedstawia kręcące się kółko.</p>
              <p>
                <a class="popup-img" href="assets/images/spinner.png"><img class="img-fluid border"
                    src="assets/images/spinner.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import { SpinnerContainer, SpinnerOverlay } from './spinner.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const Spinner = () =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;SpinnerOverlay&gt;
    &lt;SpinnerContainer /&gt;
  &lt;/SpinnerOverlay&gt;
);

export default Spinner;  // eksport komponentu, aby mógł być zaimportowany</code></pre>
            </div>
            <div id="idocs_spinner_styles">
              <h4 class="mt-5">spinner.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const SpinnerOverlay = styled.div`  // tworzy komponent SpinnerOverlay, który renderuje tag html div z określonymi stylami
  height: 60vh;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`;

export const SpinnerContainer = styled.div`  // tworzy komponent SpinnerContainer, który renderuje tag html div z określonymi stylami
  display: inline-block;
  width: 50px;
  height: 50px;
  border: 3px solid rgba(195, 195, 195, 0.6);
  border-radius: 50%;
  border-top-color: #636767;
  animation: spin 1s ease-in-out infinite;
  -webkit-animation: spin 1s ease-in-out infinite;

  @keyframes spin {  // animacja obracania się do spinnera
    to {
      -webkit-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spin {  // animacja obracania się do spinnera
    to {
      -webkit-transform: rotate(360deg);
    }
  }
`;</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- collection
        ============================ -->
          <section id="idocs_collection">
            <h2>collection</h2>
            <div id="idocs_collection_container">
              <h4>collection.container.jsx</h4>
              <!--<p class="lead mb-4">
                Przykład strony collection:<br />
                <a href="https://zadanie-na-uczelnie.pl/shop/womens"
                  target="_blank">https://zadanie-na-uczelnie.pl/shop/womens</a>
              </p>-->
              <p>
                Komponent collection przedstawia produkty z wybranej kategorii np. womens. Zawiera logo,
                nawigację i
                kafelki z produktami i stopkę z autorem.
              </p>
              <p>
                Dlaczego używamy .container i .component? Container określa dane, które powinien renderować
                .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu,
                takich jak
                connect() z Redux. Jest to tzw. Container Pattern.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów odpowiedzialnych między innymi za nawigację,
                dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(255, 0, 255)">Collection</strong>
                znajdują się <strong style="color: rgb(0, 0, 255)">MenuItem</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/collection.png"><img class="img-fluid border"
                    src="assets/images/collection.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { compose } from 'redux';  // komponuje funkcje od prawej do lewej. Służy do zastosowania kilku "ulepszaczy" store z rzędu.
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import { selectIsCollectionsLoaded } from '../../redux/shop/shop.selectors';  // selektor to getter dla store
import WithSpinner from '../../components/with-spinner/with-spinner.component';  // import komponentu występującego w collections-overview.container
import CollectionPage from './collection.component';  // import komponentu występującego w collection.container

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym czy kolekcja się ładuje
  isLoading: (state) =&gt; !selectIsCollectionsLoaded(state),
});

const CollectionPageContainer = compose( // deklaracje komponentu, jeżeli produkty się nie załadowały wyświetlaj obracające się kółko w miejsce komponentu
  connect(mapStateToProps),  // connect łączy komponent React ze store Redux
  WithSpinner
)(CollectionPage);

export default CollectionPageContainer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
            </div>
            <div id="idocs_collection_component">
              <h4>collection.component.jsx</h4>
              <p>
                Dlaczego używamy .container i .component? Container określa dane, które powinien renderować
                .component.
                Instancje komponentów container mogą być generowane przy użyciu komponentów wyższego rzędu,
                takich jak
                connect() z Redux. Jest to tzw. Container Pattern.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux

import CollectionItem from '../../components/collection-item/collection-item.component';  // import komponentu występującego w CollectionItem
import { selectCollection } from '../../redux/shop/shop.selectors';  // selektor to getter dla store

import {
  CollectionPageContainer,
  CollectionTitle,
  CollectionItemsContainer,
} from './collection.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CollectionPage = ({ collection }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { title, items } = collection;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych
  return (
    &lt;CollectionPageContainer&gt;
      &lt;CollectionTitle&gt;{title}&lt;/CollectionTitle&gt;
      &lt;CollectionItemsContainer&gt;
        {items.map((item) =&gt; (  // iteruj przez zmienną items
          &lt;CollectionItem key={item.id} item={item} /&gt;  // dla każdej zmiennej w items wyrenderuj komponent CollectionItem
        ))}
      &lt;/CollectionItemsContainer&gt;
    &lt;/CollectionPageContainer&gt;
  );
};

const mapStateToProps = (state, ownProps) =&gt; ({  // przekazuje ze store do props informacje o tym, którą kolekcję wyrenderować (czy womens czy mens itd)
  collection: selectCollection(ownProps.match.params.collectionId)(state),
});

export default connect(mapStateToProps)(CollectionPage);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_collection_styles">
              <h4 class="mt-5">collection.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>

              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

export const CollectionPageContainer = styled.article`  // tworzy komponent CollectionPageContainer, który renderuje tag html article z określonymi stylami
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
`;

export const CollectionTitle = styled.h2`  // tworzy komponent CollectionTitle, który renderuje tag html h2 z określonymi stylami
  font-size: 38px;
  margin: 0 auto 30px;
  text-transform: uppercase;
`;

export const CollectionItemsContainer = styled.div`  // tworzy komponent CollectionItemsContainer, który renderuje tag html div z określonymi stylami
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 10px;
  width: 1300px;

  & > div {  // style dla divów znajdujących się w CollectionItemsContainer
    margin-bottom: 30px;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    grid-template-columns: 1fr 1fr;
    grid-gap: 15px;
  }

  @media screen and (max-width: 500px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 500px
    grid-template-columns: 1fr !important;
  }
`;

CollectionItemsContainer.displayName = 'CollectionItemsContainer';  // po zrenderowaniu w DevTools komponent CollectionItemsContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako CollectionItemsContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_collection_test">
              <h4 class="mt-5">collection.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CollectionPage } from './collection.component';  // import komponentu, który będziemy testować
import CollectionItem from '../../components/collection-item/collection-item.component';  // import komponentu, który występuje w CollectionPage

describe('CollectionPage', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CollectionPage
  let wrapper;  // tworzenie zmiennych do testów
  let mockItems = [{ id: 1 }, { id: 2 }, { id: 3 }];
  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    const mockCollection = {  // mockowanie propsów przekazanych do Collection
      items: mockItems,
      title: 'Test',
    };

    wrapper = shallow(&lt;CollectionPage collection={mockCollection} /&gt;);  // wyrenderuj komponent Collection z propsami wyżej
  });

  it('should render the Collectione component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent Collection
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany Collection jest zgodny z snapshotem
  });

  it('should render the same number of CollectionItems as collection array', () =&gt; {  // sprawdź czy komponent CollectionItems renderuje się prawidłowo
    expect(wrapper.find(CollectionItem).length).toBe(mockItems.length);
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- checkout
        ============================ -->
          <section id="idocs_checkout">
            <h2>checkout</h2>
            <div id="idocs_checkout_component">
              <h4>checkout.component.jsx</h4>
              <!--<p class="lead mb-4">
                Strona Checkout znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/checkout"
                  target="_blank">https://zadanie-na-uczelnie.pl/checkout</a>
              </p>-->
              <p>
                Komponent Checkout przedstawia podsumowanie tego co znajduje się w koszyku. Daje możliwość
                zmiany ilości
                sztuk produktów i złożenia zamówienia.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów odpowiedzialnych między innymi za nawigację,
                dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">Checkout</strong>
                znajdują się <strong style="color: rgb(255, 0, 255)">CheckoutItem</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/checkout.png"><img class="img-fluid border"
                    src="assets/images/checkout.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import CheckoutItem from '../../components/checkout-item/checkout-item.component';  // import komponentu występującego w Checkout

import {
  selectCartItems,
  selectCartTotal,
} from '../../redux/cart/cart.selectors';  // selektor to getter dla store

import {
  CheckoutPageContainer,
  CheckoutHeaderContainer,
  HeaderBlockContainer,
  TotalContainer,
} from './checkout.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CheckoutPage = ({ cartItems, total }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;CheckoutPageContainer&gt;
    &lt;CheckoutHeaderContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Product&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Description&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Quantity&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Price&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
      &lt;HeaderBlockContainer&gt;
        &lt;span&gt;Remove&lt;/span&gt;
      &lt;/HeaderBlockContainer&gt;
    &lt;/CheckoutHeaderContainer&gt;
    {cartItems.map((cartItem) =&gt; (  // iteruj po zmiennej cartItems przechowującą informacje o produktach dodanych do koszyka
      &lt;CheckoutItem key={cartItem.id} cartItem={cartItem} /&gt;  // dla każdego produktu wyrenderuj kompontn CheckoutItem
    ))}
    &lt;TotalContainer&gt;TOTAL: ${total}&lt;/TotalContainer&gt;  // całkowity koszt wszystkich produktów w koszyku
  &lt;/CheckoutPageContainer&gt;
);

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o tym ile produktów znajduje się w koszyku oraz cenę za wszystkie produkty
  cartItems: selectCartItems,
  total: selectCartTotal,
});

export default connect(mapStateToProps)(CheckoutPage);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_checkout_styles">
              <h4 class="mt-5">checkout.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

export const CheckoutPageContainer = styled.article`  // tworzy komponent CheckoutPageContainer, który renderuje tag html article z określonymi stylami
  animation: 0.2s ${fadeIn};
  width: 55%;
  min-height: 90vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 50px auto 0;

  button {  // te style będą dotyczyć tylko buttonów w środku CheckoutPageContainer
    margin-left: auto;
    margin-top: 50px;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 90%;
  }
`;

export const CheckoutHeaderContainer = styled.div`  // tworzy komponent CheckoutHeaderContainer, który renderuje tag html div z określonymi stylami
  width: 100%;
  height: 40px;
  display: flex;
  justify-content: space-between;
  border-bottom: 1px solid darkgrey;
`;

export const HeaderBlockContainer = styled.div`  // tworzy komponent HeaderBlockContainer, który renderuje tag html div z określonymi stylami
  text-transform: capitalize;
  width: 23%;

  &amp;:last-child {  // te style będą dotyczyć ostatniego dziecka w HeaderBlockContainer
    width: 8%;
  }

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 22%;

    &amp;:last-child {  // te style będą dotyczyć ostatniego dziecka w HeaderBlockContainer
      width: 12%;
    }
  }
`;

export const TotalContainer = styled.div`  // tworzy komponent TotalContainer, który renderuje tag html div z określonymi stylami
  margin-top: 30px;
  margin-left: auto;
  font-size: 36px;
`;
</code></pre>
            </div>
            <div id="idocs_checkout_test">
              <h4 class="mt-5">checkout.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import { CheckoutPage } from './checkout.component';  // import komponentu, który będziemy testować

let wrapper;  // tworzenie zmiennych do testów
beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
  const mockProps = {  // mockowanie propsów przekazanych do CheckoutPage
    cartItems: [],
    total: 100,
  };

  wrapper = shallow(&lt;CheckoutPage {...mockProps} /&gt;);  // wyrenderuj komponent CheckoutPage z propsami wyżej
});

it('should render CheckoutPage component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CheckoutPage
  expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CheckoutPage jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- checkout-item
        ============================ -->
          <section id="idocs_checkout_item">
            <h2>checkout-item</h2>
            <div id="idocs_checkout_item_component">
              <h4>checkout-item.component.jsx</h4>
              <p>CheckoutItem odzwierciedla pojedynczy produkt na stronie checkout. Wyświetla zdjęcie
                produktu, nazwę,
                cenę. Pozwala na zmianę ilości sztuk lub usunięcie produktu ze strony checkout i
                koszyka.</p>
              <p>
                <a class="popup-img" href="assets/images/checkout_item.png"><img class="img-fluid border"
                    src="assets/images/checkout_item.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux

import {
  clearItemFromCart,
  addItem,
  removeItem,
} from '../../redux/cart/cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import {
  CheckoutItemContainer,
  ImageContainer,
  TextContainer,
  QuantityContainer,
  RemoveButtonContainer,
} from './checkout-item.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

export const CheckoutItem = ({ cartItem, clearItem, addItem, removeItem }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const { name, imageUrl, price, quantity } = cartItem;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych
  return (
    &lt;CheckoutItemContainer&gt;
      &lt;ImageContainer&gt;
        &lt;img src={imageUrl} alt=&quot;item&quot; /&gt;  // zdjęcie produktu
      &lt;/ImageContainer&gt;
      &lt;TextContainer&gt;{name}&lt;/TextContainer&gt;
      &lt;QuantityContainer&gt;
        &lt;div onClick={() =&gt; removeItem(cartItem)}&gt;&amp;#10094;&lt;/div&gt;  // strzałka w lewo - zmień ilość sztuk produktu: -1
        &lt;span&gt;{quantity}&lt;/span&gt;   // ilość sztuk produktu
        &lt;div onClick={() =&gt; addItem(cartItem)}&gt;&amp;#10095;&lt;/div&gt;  // strzałka w prawo - zmień ilość sztuk produktu: +1
      &lt;/QuantityContainer&gt;
      &lt;TextContainer&gt;{price}&lt;/TextContainer&gt;
      &lt;RemoveButtonContainer onClick={() =&gt; clearItem(cartItem)}&gt;  // usuń z koszyka produkt
        &amp;#10005;
      &lt;/RemoveButtonContainer&gt;
    &lt;/CheckoutItemContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  
  clearItem: (item) =&gt; dispatch(clearItemFromCart(item)),  // usuń produkt ze stanu store, czyli usuń produkt z koszyka
  addItem: (item) =&gt; dispatch(addItem(item)),  // dodaj produkt ze stanu store, czyli zwiększ ilość sztuk produktu o 1
  removeItem: (item) =&gt; dispatch(removeItem(item)),  // zabierz produkt ze stanu store, czyli zmniejsz ilość sztuk produktu o 1
});

export default connect(null, mapDispatchToProps)(CheckoutItem);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_checkout_item_styles">
              <h4 class="mt-5">checkout-item.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const CheckoutItemContainer = styled.section`  // tworzy komponent CheckoutItemContainer, który renderuje tag html section z określonymi stylami
  width: 100%;
  display: flex;
  min-height: 100px;
  border-bottom: 1px solid darkgrey;
  padding: 15px 0;
  font-size: 20px;
  align-items: center;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    font-size: 18px;
  }
`;

export const ImageContainer = styled.div`  // tworzy komponent ImageContainer, który renderuje tag html div z określonymi stylami
  width: 23%;
  padding-right: 15px;

  img {  // style poniżej będą dotyczyć tagów img w komponencie ImageContainer
    width: 100%;
    height: 100%;
  }
`;

export const TextContainer = styled.span`  // tworzy komponent TextContainer, który renderuje tag html span z określonymi stylami
  width: 23%;

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    width: 22%;
  }
`;

export const QuantityContainer = styled(TextContainer)`  // tworzy komponent QuantityContainer, który renderuje komponent TextContainer z określonymi stylami
  display: flex;

  span {   // style poniżej będą dotyczyć tagów span w komponencie QuantityContainer
    margin: 0 10px;
    color: black;
  }

  div {  // style poniżej będą dotyczyć tagów div w komponencie QuantityContainer
    cursor: pointer;
  }

  &amp;:hover {  // style zadziałają przy najechaniu na myszą na komponent
    color: #e08800;
  }
`;

QuantityContainer.displayName = 'QuantityContainer';  // po zrenderowaniu w DevTools komponent QuantityContainer wyświetlał by się jako styled.span, ale po zmianie parametru displayName wyświetli się jako QuantityContainer co ułatwi debugowanie

export const RemoveButtonContainer = styled.div`  // tworzy komponent RemoveButtonContainer, który renderuje tag html div z określonymi stylami
  padding-left: 12px;
  cursor: pointer;

  &amp;:hover {  // style zadziałają przy najechaniu na myszą na komponent
    color: #e08800;
  }
`;

RemoveButtonContainer.displayName = 'RemoveButtonContainer';  // po zrenderowaniu w DevTools komponent RemoveButtonContainer wyświetlał by się jako styled.div, ale po zmianie parametru displayName wyświetli się jako RemoveButtonContainer co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_checkout_item_test">
              <h4 class="mt-5">checkout-item.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import { CheckoutItem } from './checkout-item.component';  // import komponentu, który będziemy testować

describe('CheckoutItem component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu CheckoutItem
  let wrapper;  // tworzenie zmiennych do testów
  let mockClearItem; 
  let mockAddItem;
  let mockRemoveItem;

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockClearItem = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości.
    mockAddItem = jest.fn();
    mockRemoveItem = jest.fn();

    const mockProps = {  // mockowanie propsów przekazanych do CheckoutItem
      cartItem: {
        imageUrl: 'www.testImage.com',
        price: 10,
        name: 'hats',
        quantity: 2,
      },
      clearItem: mockClearItem,
      addItem: mockAddItem,
      removeItem: mockRemoveItem,
    };

    wrapper = shallow(&lt;CheckoutItem {...mockProps} /&gt;);  // wyrenderuj komponent CheckoutItem z propsami wyżej
  });

  it('should render CheckoutItem component', () =&gt; {  // tworzy indywidualny test, który powinien wyrenderować komponent CheckoutItem
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany CheckoutItem jest zgodny z snapshotem
  });

  it('should call clearItem when remove button is clicked', () =&gt; {  // przy kliknięciu X usuń produkt z koszyka
    wrapper.find('RemoveButtonContainer').simulate('click');  // znajdz przycisk do usuwania
    expect(mockClearItem).toHaveBeenCalled();  // sprawdz czy funkcja do usuwania została wywołana
  });

  it('should call removeItem when left arrow is clicked', () =&gt; {  // przy kliknięciu &lt; zmniejsz ilość produktu z koszyka
    wrapper.find('QuantityContainer').childAt(0).simulate('click');

    expect(mockRemoveItem).toHaveBeenCalled();x
  });

  it('should call addItem when right arrow is clicked', () =&gt; {  // przy kliknięciu &gt; zmniejsz ilość produktu z koszyka
    wrapper.find('QuantityContainer').childAt(2).simulate('click');

    expect(mockAddItem).toHaveBeenCalled();
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- sign_in_and_sign_up_page
        ============================ -->
          <section id="idocs_sign_in_and_sign_up_page">
            <h2>sign-in-and-sign-up-page</h2>
            <div id="idocs_sign_in_and_sign_up_page_component">
              <h4>sign-in-and-sign-up-page.component.jsx</h4>
              <p class="lead mb-4">
                Strona główna do rejestracji i logowania <!--znajduje się tutaj:<br />
                <a href="https://zadanie-na-uczelnie.pl/signin"
                  target="_blank">https://zadanie-na-uczelnie.pl/signin</a>-->
              </p>
              <p>
                Strona signin and signup to służy do zarejestrowania lub zalogowania już istniejącego
                użytkownika.
                Zawiera logo, nawigację i komponenty SignIn i SignUp stopkę z autorem.
              </p>
              <p>
                Aplikacja jest „zawinięta” w wiele komponentów
                odpowiedzialnych między innymi za nawigację, dostarczenie
                stanu do reduxa itd. O nich powiemy później
              </p>
              <p>
                Uznajmy, że głównym komponentem jest
                <strong style="color: rgb(255, 0, 0)">App</strong>, który
                zawiera całą naszą stronę. <br />
                Następny jest
                <strong style="color: rgb(0, 255, 0)">Header</strong>
                zawierający logo i nawigację.<br />
                W
                <strong style="color: rgb(0, 0, 255)">SignInAndSignUpPage</strong>
                znajduje się
                <strong style="color: rgb(255, 0, 255)">SignIn</strong> oraz <strong
                  style="color: rgb(0, 255, 255)">SignUp</strong>.
                <br />
                <strong style="color: rgb(207, 207, 65)">Footer</strong>
                nie zawiera w sobie podkomponentów.
              </p>
              <p>
                <a class="popup-img" href="assets/images/sign_in_and_sign_up_page.png"><img class="img-fluid border"
                    src="assets/images/sign_in_and_sign_up_page.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import SignIn from '../../components/sign-in/sign-in.component';  // import komponentu występującego w SignInAndSignUpPage
import SignUp from '../../components/sign-up/sign-up.component';  // import komponentu występującego w SignInAndSignUpPage

import { SignInAndSignUpContainer } from './sign-in-and-sign-up.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const SignInAndSignUpPage = () =&gt; (  // deklaracja komponentu funkcyjnego
  &lt;SignInAndSignUpContainer&gt;
    &lt;SignIn /&gt;
    &lt;SignUp /&gt;
  &lt;/SignInAndSignUpContainer&gt;
);

export default SignInAndSignUpPage;  // export funkcji, aby mogła być zaimportowana w innym komponencie</code></pre>
            </div>
            <div id="idocs_sign_in_and_sign_up_page_styles">
              <h4 class="mt-5">sign-in-and-sign-up-page.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { keyframes } from 'styled-components';  // import biblioteki styled components

const fadeIn = keyframes`  // reguła @keyframes określa kod animacji. Animacja jest tworzona przez stopniową zmianę z jednego zestawu stylów CSS na inny.
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;
export const SignInAndSignUpContainer = styled.article`  // tworzy komponent SignInAndSignUpContainer, który renderuje tag html article z określonymi stylami
  width: 850px;
  display: flex;
  justify-content: space-between;
  margin: 30px auto;
  padding: 0 20px;
  animation: 0.2s ${fadeIn};

  @media screen and (max-width: 800px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 800px
    flex-direction: column;
    width: unset;
    align-items: center;

    &gt; *:first-child {  // te style dotyczą pierwszego dziecko w komponencie SignInAndSignUpContainer
      margin-bottom: 50px;
    }
  }

  @media screen and (max-width: 460px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 460px
    padding: 0 10px;
  }
`;</code></pre>
            </div>
            <div id="idocs_sign_in_and_sign_up_page_test">
              <h4 class="mt-5">sign-in-and-sign-up-page.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import SignInAndSignUpPage from './sign-in-and-sign-up.component';  // import komponentu, który będziemy testować

it('should render SignInAndSignUpPage component', () =&gt; {  // wyrenderuj komponent SignInAndSignUpPage
  expect(shallow(&lt;SignInAndSignUpPage /&gt;)).toMatchSnapshot();  // sprawdź czy wyrenderowany SignInAndSignUpPage jest zgodny z snapshotem
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- sign_in
        ============================ -->
          <section id="idocs_sign_in">
            <h2>sign-in</h2>
            <div id="idocs_sign_in_component">
              <h4>sign-in.component.jsx</h4>
              <p>Komponent SignIn zawiera formularz, dzieki któremu można się zalogować za pomocą e-mail i
                hasła.</p>
              <p>
                <a class="popup-img" href="assets/images/sign_in.png"><img class="img-fluid border"
                    src="assets/images/sign_in.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React, { useState } from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useState to hook to Reacta pozwalający na używanie stanu w komponencie
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux

import FormInput from '../form-input/form-input.component';  // import komponentu występującego w SignIn
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w SignIn

import {
  emailSignInStart,
} from '../../redux/user/user.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import {
  SignInContainer,
  SignInTitle,
  ButtonsBarContainer,
} from './sign-in.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const SignIn = ({ emailSignInStart }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const [userCredentials, setCredentials] = useState({  // w stanie komponentu będzie znajdować się email i password, użyjemy funkcji setUserCredentials to zmiany tych zmiennych
    email: '',
    password: '',
  });

  const { email, password } = userCredentials;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

  const handleSubmit = async (event) =&gt; {  //  funkcja wywoływana przy kliknięciu przycisku Submit w formularzu
    event.preventDefault();

    emailSignInStart(email, password);  // wywołuje funkcję emailSignInStart z wartościami email i password
  };

  const handleChange = (event) =&gt; {  // funkcja wywowała się, gdy użytkownik będzie edytować pola username lub password
    const { value, name } = event.target; // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

    setCredentials({ ...userCredentials, [name]: value });  // update stanu komponentu nowymi wartościami username i password
  };

  return (
    &lt;SignInContainer&gt;
      &lt;SignInTitle&gt;I already have an account&lt;/SignInTitle&gt;
      &lt;span&gt;Sign in with your email and password&lt;/span&gt;

      &lt;form onSubmit={handleSubmit}&gt;  // po kliknięciu submit wywołaj funkcję handleSubmit
        &lt;FormInput
          name=&quot;email&quot;
          type=&quot;email&quot;
          handleChange={handleChange}
          value={email}
          label=&quot;email&quot;
          required
        /&gt;
        &lt;FormInput
          name=&quot;password&quot;
          type=&quot;password&quot;
          value={password}
          handleChange={handleChange}  // przy zmianie zawartości pul formularza wywołaj funkcję handleChange
          label=&quot;password&quot;
          required
        /&gt;
        &lt;ButtonsBarContainer&gt;
          &lt;CustomButton type=&quot;submit&quot;&gt; Sign in &lt;/CustomButton&gt;
        &lt;/ButtonsBarContainer&gt;
      &lt;/form&gt;
    &lt;/SignInContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik zaloguje się którąś z metod, store zmieni użytkownika na zalogowanego 
  emailSignInStart: (email, password) =&gt;
    dispatch(emailSignInStart({ email, password })),
});

export default connect(null, mapDispatchToProps)(SignIn);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_sign_in_styles">
              <h4 class="mt-5">sign-in.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const SignInContainer = styled.article`  // tworzy komponent SignInContainer, który renderuje tag html article z określonymi stylami
  width: 380px;
  display: flex;
  flex-direction: column;
  @media screen and (max-width: 460px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 460px
    width: 260px;
  }
`;

export const SignInTitle = styled.h2`  // tworzy komponent SignInTitle, który renderuje tag html h2 z określonymi stylami
  margin: 10px 0;
`;

export const ButtonsBarContainer = styled.div`  // tworzy komponent ButtonsBarContainer, który renderuje tag html div z określonymi stylami
  display: flex;
  justify-content: space-between;
  @media screen and (max-width: 460px) {  // style będą inne, jeżeli strona zostanie wyświetlona na urzadzeniu o szerokości mniejszej niż 460px
    display: block;

    button {  // te style będą dotyczyć wszystkich tagów button znajdujących się w ButtonsBarContainer
      margin: 0 auto 10px auto;
    }
  }
`;</code></pre>
            </div>
            <div id="idocs_sign_in_test">
              <h4 class="mt-5">sign-in.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
            </div>
          </section>
          <pre><code class="language-javascript">import React from "react"; // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from "enzyme"; // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import SignIn from "./sign-in.component"; // import komponentu, który będziemy testować

it("should render SignIn component", () => { // wyrenderuj komponent SignIn
  expect(shallow(<SignIn/>)).toMatchSnapshot(); // sprawdź czy wyrenderowany SignIn jest zgodny z snapshotem
});</code></pre>
          <hr class="divider" />

          <!-- form_input
        ============================ -->
          <section id="idocs_form_input">
            <h2>form-input</h2>
            <div id="idocs_form_input_component">
              <h4>form-input.component.jsx</h4>
              <p>FormInput to komponent ubierający inputy formularza w "ładny" styl i strukturę z lablami.</p>
              <p>
                <a class="popup-img" href="assets/images/form_input.png"><img class="img-fluid border"
                    src="assets/images/form_input.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import {
  GroupContainer,
  FormInputContainer,
  FormInputLabel,
} from './form-input.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const FormInput = ({ handleChange, label, ...props }) =&gt; (  // deklaracja komponentu funkcyjnego, przekazanie propsów
  &lt;GroupContainer&gt;
    &lt;FormInputContainer onChange={handleChange} {...props} /&gt;  // przy zmianie zawartości pola wywołaj funkcję handleChange
    {label ? (
      &lt;FormInputLabel className={props.value.length ? 'shrink' : ''}&gt;  // jeżeli w pole zostało coś wpisane, do komponentu zostanie dopisana klasa 'shrink'
        {label}
      &lt;/FormInputLabel&gt;
    ) : null}  // jeżeli label nie jest pusta wywołaj FormInputLabel
  &lt;/GroupContainer&gt;
);

export default FormInput;  // łączy komponent React ze store Redux.</code></pre>
            </div>
            <div id="idocs_form_input_styles">
              <h4 class="mt-5">form-input.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled, { css } from 'styled-components';  // import biblioteki styled components

const subColor = '#e08800';  // zmienne zawierające kolory
const mainColor = 'black';  // zmienne zawierające kolory

const shrinkLabelStyles = css`  // określa grupę atrybutów css, nie renderuje tagu html sam w sobie
  top: -14px;
  font-size: 12px;
  color: ${mainColor};
`;

export const GroupContainer = styled.div`  // tworzy komponent GroupContainer, który renderuje tag html div z określonymi stylami
  position: relative;
  margin: 45px 0;

  input[type='password'] {  // style dla inputów typu password znajdujących się w GroupContainer
    letter-spacing: 0.3em;
  }
`;

export const FormInputContainer = styled.input`  // tworzy komponent FormInputContainer, który renderuje tag html input z określonymi stylami
  background: none;
  background-color: white;
  color: ${subColor};
  font-size: 18px;
  padding: 10px 10px 10px 5px;
  display: block;
  width: 100%;
  border: none;
  border-radius: 0;
  border-bottom: 1px solid ${subColor};
  margin: 25px 0;

  &:focus {  // style gdy input jest kliknięty
    outline: none;
  }

  &:focus ~ label {  // style dla label gdy input jest kliknięty
    ${shrinkLabelStyles}
  }
`;

FormInputContainer.displayName = 'FormInputContainer';  // po zrenderowaniu w DevTools komponent FormInputContainer wyświetlał by się jako styled.input, ale po zmianie parametru displayName wyświetli się jako FormInputContainer co ułatwi debugowanie

export const FormInputLabel = styled.label`  // tworzy komponent FormInputLabel, który renderuje tag html label z określonymi stylami
  color: ${subColor};
  font-size: 16px;
  font-weight: normal;
  position: absolute;
  pointer-events: none;
  left: 5px;
  top: 10px;
  transition: 300ms ease all;

  &.shrink {  // style dla komponentów z FormInputLabel z klasą shrink
    ${shrinkLabelStyles}
  }
`;

FormInputLabel.displayName = 'FormInputLabel';  // po zrenderowaniu w DevTools komponent FormInputLabel wyświetlał by się jako styled.label, ale po zmianie parametru displayName wyświetli się jako FormInputLabel co ułatwi debugowanie</code></pre>
            </div>
            <div id="idocs_form_input_test">
              <h4 class="mt-5">form-input.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
              <pre><code class="language-javascript">import React from 'react';  // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from 'enzyme';  // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render

import FormInput from './form-input.component';  // import komponentu, który będziemy testować

describe('FormInput component', () =&gt; {  // describe pozwala na tworzenie zestawów testów, te będą dotyczyć komponentu FormInput
  let wrapper;  // tworzenie zmiennych do testów
  let mockHandleChange;  // tworzenie zmiennych do testów

  beforeEach(() =&gt; {  // beforeEach jest wywoływany przed każdym indywidualnym testem
    mockHandleChange = jest.fn();  // jest.fn() to mock funkcji, umożliwia testowanie powiązań między kodem poprzez wymazanie rzeczywistej implementacji funkcji, przechwytywanie wywołań funkcji (i parametrów przekazywanych w tych wywołaniach), przechwytywanie wystąpień funkcji konstruktora po utworzeniu instancji z nowym i umożliwienie konfiguracji w czasie testu zwracanych wartości

    const mockProps = {  // mockowanie propsów przekazanych do FormInput
      label: 'email',
      value: 'test@gmail.com',
      handleChange: mockHandleChange,
    };

    wrapper = shallow(&lt;FormInput {...mockProps} /&gt;);  // wyrenderuj komponent FormInput z propsami wyżej
  });

  it('should render FormInput component', () =&gt; {
    expect(wrapper).toMatchSnapshot();  // sprawdź czy wyrenderowany FormInput jest zgodny z snapshotem
  });

  it('should call handleChange method when input changes', () =&gt; {
    wrapper.find('FormInputContainer').simulate('change');  // simuluj zmianę pól formularza,

    expect(mockHandleChange).toHaveBeenCalled();  //  co powinno wywołać funkcję mockHandleChange
  });

  it('should render FormInputLabel if there is a label', () =&gt; {
    expect(wrapper.exists('FormInputLabel')).toBe(true);
  });

  it('should not render FormInputLabel if there is no label', () =&gt; {  // nie renderuj FormInputLabel, jeżeli nie ma zmiennej label
    const mockNewProps = {  // nowe propsy
      label: '',
      value: 'test@gmail.com',
      handleChange: mockHandleChange,
    };

    const newWrapper = shallow(&lt;FormInput {...mockNewProps} /&gt;);  // wyrenderuj komponent FormInput z propsami wyżej

    expect(newWrapper.exists('FormInputLabel')).toBe(false);  // oczekuj, że FormInputLabel nie istnieje w dom
  });
});</code></pre>
            </div>
          </section>
          <hr class="divider" />

          <!-- sign_up
        ============================ -->
          <section id="idocs_sign_up">
            <h2>sign-up</h2>
            <div id="idocs_sign_up_component">
              <h4>sign-up.component.jsx</h4>
              <p>Komponent SignUp zawiera formularz, dzieki któremu można się zarejestrować za pomocą loginu,
                e-mail i hasła.</p>
              <p>
                <a class="popup-img" href="assets/images/sign_up.png"><img class="img-fluid border"
                    src="assets/images/sign_up.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React, { useState } from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useState to hook to Reacta pozwalający na używanie stanu w komponencie
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux

import FormInput from '../form-input/form-input.component';  // import komponentu występującego w SignUp
import CustomButton from '../custom-button/custom-button.component';  // import komponentu występującego w SignUp

import { signUpStart } from '../../redux/user/user.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import { SignUpContainer, SignUpTitle } from './sign-up.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

const SignUp = ({ signUpStart }) =&gt; {  // deklaracja komponentu funkcyjnego, przekazanie propsów
  const [userCredentials, setUserCredentials] = useState({  // w stanie komponentu będzie znajdować się displayName, email, password i confirmPassword, użyjemy funkcji setUserCredentials to zmiany tych zmiennych
    displayName: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  const { displayName, email, password, confirmPassword } = userCredentials;  // W ES6 wprowadzono destrukturyzację. Jest to funkcja JavaScript, która pozwala nam wyodrębnić wiele fragmentów danych z tablicy lub obiektu i przypisać je do własnych zmiennych

  const handleSubmit = async (event) =&gt; {
    event.preventDefault();

    if (password !== confirmPassword) {
      alert(&quot;passwords don't match&quot;);
      return;
    }

    signUpStart({ displayName, email, password });
  };

  const handleChange = (event) =&gt; {
    const { name, value } = event.target;

    setUserCredentials({ ...userCredentials, [name]: value });
  };

  return (
    &lt;SignUpContainer&gt;
      &lt;SignUpTitle&gt;I do not have a account&lt;/SignUpTitle&gt;
      &lt;span&gt;Sign up with your email and password&lt;/span&gt;
      &lt;form className=&quot;sign-up-form&quot; onSubmit={handleSubmit}&gt;  // po kliknięciu submit wywołaj funkcję handleSubmit
        &lt;FormInput
          type=&quot;text&quot;
          name=&quot;displayName&quot;
          value={displayName}
          onChange={handleChange}
          label=&quot;Display Name&quot;
          required
        /&gt;
        &lt;FormInput
          type=&quot;email&quot;
          name=&quot;email&quot;
          value={email}
          onChange={handleChange}
          label=&quot;Email&quot;
          required
        /&gt;
        &lt;FormInput
          type=&quot;password&quot;
          name=&quot;password&quot;
          value={password}
          onChange={handleChange}
          label=&quot;Password&quot;
          required
        /&gt;
        &lt;FormInput
          type=&quot;password&quot;
          name=&quot;confirmPassword&quot;
          value={confirmPassword}
          onChange={handleChange}
          label=&quot;Confirm Password&quot;
          required
        /&gt;
        &lt;CustomButton type=&quot;submit&quot;&gt;SIGN UP&lt;/CustomButton&gt;
      &lt;/form&gt;
    &lt;/SignUpContainer&gt;
  );
};

const mapDispatchToProps = (dispatch) =&gt; ({  // jeżeli użytkownik zarejestruje się którąś z metod, store przekaże te zmienne i zmieni stan użytkownika na zalogowanego
  signUpStart: (userCredentials) =&gt; dispatch(signUpStart(userCredentials)),
});

export default connect(null, mapDispatchToProps)(SignUp);  // connect łączy komponent React ze store Redux</code></pre>
            </div>
            <div id="idocs_sign_up_styles">
              <h4 class="mt-5">sign-up.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const SignUpContainer = styled.article`  // tworzy komponent SignUpContainer, który renderuje tag html article z określonymi stylami
  display: flex;
  flex-direction: column;
  width: 380px;
  @media screen and (max-width: 460px) {
    width: 260px;
  }
`;

export const SignUpTitle = styled.h2`  // tworzy komponent SignUpTitle, który renderuje tag h2 article z określonymi stylami
  margin: 10px 0;
`;</code></pre>
            </div>
            <div id="idocs_sign_up_test">
              <h4 class="mt-5">sign-up.test.js</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
            </div>
          </section>
          <pre><code class="language-javascript">import React from "react"; // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from "enzyme"; // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import SignUp from "./sign-up.component"; // import komponentu, który będziemy testować

it("should render SignUp component", () => { // wyrenderuj komponent SignUp
  expect(shallow(<SignUp/>)).toMatchSnapshot(); // sprawdź czy wyrenderowany SignUp jest zgodny z snapshotem
});</code></pre>
          <hr class="divider" />
          <!-- error_boundary
        ============================ -->
          <section id="idocs_error_boundary">
            <h2>error-boundary</h2>
            <div id="idocs_error_boundary_component">
              <h4>error-boundary.component.jsx</h4>
              <p>W przypadku, gdy np. użytkownik spróbuje wejść na podstronę, która nie istnieje dojdzie do
                erroru 404. W przypadku takich errorów wyrenderuje się komponent ErrorBoundary informujący o
                wystąpieniu problemu.</p>
              <p>
                <a class="popup-img" href="assets/images/error_boundary.png"><img class="img-fluid border"
                    src="assets/images/error_boundary.png" alt="" /></a>
              </p>
              <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;

import {
  ErrorImageOverlay,
  ErrorImageContainer,
  ErrorImageText,
} from './error-boundary.styles';  // import styli StyledComponents, jest to biblioteka tworząca komponenty i załączająca do nich css w formie js

class ErrorBoundary extends React.Component {  // deklaracja komponentu funkcyjnego komponentu klasowego
  constructor() {  // konstruktor klasy
    super();
    this.state = {  // stan klasy 
      hasErrored: false,
    };
  }

  static getDerivedStateFromError(error) { // obsłuż error
    return { hasErrored: true };
  }

  render() {
    if (this.state.hasErrored) {  // soft 404 dla stron z błędami
      return (
        &lt;ErrorImageOverlay&gt;
          &lt;ErrorImageContainer imageUrl=&quot;https://i.imgur.com/yW2W9SC.png&quot; /&gt;
          &lt;ErrorImageText&gt;Sorry this page is broken&lt;/ErrorImageText&gt;
        &lt;/ErrorImageOverlay&gt;
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;  // export funkcji aby mogła być zaimportowana w innym komponencie</code></pre>
            </div>
            <div id="idocs_error_boundary_styles">
              <h4 class="mt-5">error-boundary.styles.jsx</h4>
              <p>
                <strong>Pliki {component}.styles.jsx są odpowiedzialne za wygląd
                  komponentu.</strong>
                Stworzone za pomocą biblioteki Styled-components.
                <br />
                Wykorzystują mieszankę Javascript i CSS przy użyciu techniki
                zwanej CSS-in-JS.
              </p>
              <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const ErrorImageOverlay = styled.div`  // tworzy komponent ErrorImageOverlay, który renderuje tag html div z określonymi stylami
  height: 60vh;
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

export const ErrorImageContainer = styled.div`  // tworzy komponent ErrorImageContainer, który renderuje tag html div z określonymi stylami
  display: inline-block;
  background-image: ${({ imageUrl }) => `url(${imageUrl})`};
  background-size: cover;
  background-position: center;
  width: 40vh;
  height: 40vh;
`;

export const ErrorImageText = styled.h2`  // tworzy komponent ErrorImageText, który renderuje tag html h2 z określonymi stylami
  font-size: 28px;
  color: #2f8e89;
`;</code></pre>
            </div>
            <div id="idocs_error_boundary_test">
              <h4 class="mt-5">error-boundary.test.jsx</h4>
              <p>
                <strong>Pliki {component}.test.jsx zawierają testy napisane w
                  frameworku Jest.</strong>
                Testy mają na celu sprawdzenie czy strona działa bez błędow.
              </p>
            </div>
          </section>
          <pre><code class="language-javascript">import React from "react"; // będziemy testować komponenty Reacta, więc trzeba go zaimportować
import { shallow } from "enzyme"; // import funkcji do tzw shallow rendering, pozwala renderować komponent i sprawdzić co zwraca jego metoda render
import ErroBoundary from "./error-boundary.component"; // import komponentu, który będziemy testować

it("should render ErroBoundary component", () => { // wyrenderuj komponent ErroBoundary
  expect(shallow(<ErroBoundary/>)).toMatchSnapshot(); // sprawdź czy wyrenderowany ErroBoundary jest zgodny z snapshotem
});</code></pre>
          <hr class="divider" />

          <!-- utils
        ============================ -->
          <section id="idocs_scroll_to_top_component">
            <h2>scroll-to-top-component.jsx</h2>
            <p>ScrollToTop to komponent, który powoduje, że jeżeli zescrolujemy nisko w dół i przejdziemy na
              inną podstronę, to ta podstrona wyświetli się "na górze".</p>
            <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import { withRouter } from 'react-router-dom';  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany.Selectors

class ScrollToTop extends React.Component {  // deklaracja komponentu
  componentDidUpdate(prevProps) {  // po zrenderowaniu komponentu
    if (this.props.location.pathname !== prevProps.location.pathname) {  // jeżeli nowo zrenderowany komponent znajduje się w innym urlu niż poprzednio renderowany komponent
      window.scrollTo(0, 0);  // przewiń okno na samą górę
    }
  }
  render() {
    return null;
  }
}
export default withRouter(ScrollToTop);  // udostępnia obiekt historii i najbliższego dopasowania &lt;Route&gt; poprzez komponent wyższego rzędu withRouter. withRouter przekaże zaktualizowane właściwości dopasowania, lokalizacji i historii do opakowanego komponentu za każdym razem, gdy zostanie wyrenderowany.Selectors</code></pre>
          </section>
          <hr class="divider" />

          <!-- app
        ============================ -->
          <section id="idocs_app">
            <h2>app.js</h2>
            <p>W app.js definiujemy ścieżki i komponenty jakie mają wyświetlać oraz komponenty występujące w całej aplikacji jak header i footer.</p>
            <pre><code class="language-javascript">import React, { useEffect, lazy, Suspense } from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;, useEffect - pozwala na uruchomienie dodatkowego kodu po tym, jak React zaktualizuej drzewo DOM, lazy - pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty, suspense - komponent wyrenderowany poprzez lazy() powinien zostać wyrenderowany wewnątrz suspense(), dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. kręcące się kółko)
import { Switch, Route, Redirect } from 'react-router-dom';  // switch wyrenderuje tylko pierwszą trasę, która pasuje/zawiera ścieżkę. Po znalezieniu pierwszej trasy, która pasuje do ścieżki, nie będzie szukać żadnych innych dopasowań, route renderuje interfejs użytkownika, gdy jego ścieżka pasuje do bieżącego adresu URL, redirect spowoduje przejście do nowej lokalizacji. Nowa lokalizacja zastąpi bieżącą lokalizację w stosie historii, tak jak robią to przekierowania po stronie serwera (HTTP 3xx)
import { connect } from 'react-redux';  // connect łączy komponent React ze store Redux
import { createStructuredSelector } from 'reselect';  // createStructuredSelector pobiera obiekt, którego właściwości są selectorami danych wejściowych, i zwraca selector strukturalny. elector strukturalny zwraca obiekt z tymi samymi kluczami, co selectorami danych wejściowych, ale z selectorami zastąpionymi ich wartościami

import Header from './components/header/header.component';  // import komponentu występującego w App
import Footer from './components/footer/footer.c omponent';  // import komponentu występującego w App
import Spinner from './components/spinner/spinner.component';  // import komponentu występującego w App
import ErrorBoundary from './components/error-boundary/error-boundary.component';  // import komponentu występującego w App

import { PageWrapper, GlobalStyle } from './global.styles';  // import styli globalnych, czyli aplikowanych do całej aplikacji

import { selectCurrentUser } from './redux/user/user.selectors';  // selektor to getter dla store
import { checkUserSession } from './redux/user/user.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

const HomePage = lazy(() =&gt; import('./pages/homepage/homepage.component'));  // react.lazy pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty. React.lazy jako argument przyjmuje funkcję, która wywołuje dynamiczny import(). Musi ona zwrócić obiekt (Promise) (pol. obietnicę), która rozwiązuje się do modułu z eksportem domyślnym (default) zawierającym komponent reactowy. “Leniwy” komponent powinien zostać wyrenderowany wewnątrz Suspense, dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. wskaźnik ładowania).
const ShopPage = lazy(() =&gt; import('./pages/shop/shop.component'));  // react.lazy pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty. React.lazy jako argument przyjmuje funkcję, która wywołuje dynamiczny import(). Musi ona zwrócić obiekt (Promise) (pol. obietnicę), która rozwiązuje się do modułu z eksportem domyślnym (default) zawierającym komponent reactowy. “Leniwy” komponent powinien zostać wyrenderowany wewnątrz Suspense, dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. wskaźnik ładowania).
const SignInAndSignUpPage = lazy(() =&gt;  // react.lazy pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty. React.lazy jako argument przyjmuje funkcję, która wywołuje dynamiczny import(). Musi ona zwrócić obiekt (Promise) (pol. obietnicę), która rozwiązuje się do modułu z eksportem domyślnym (default) zawierającym komponent reactowy. “Leniwy” komponent powinien zostać wyrenderowany wewnątrz Suspense, dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. wskaźnik ładowania).
  import('./pages/sign-in-and-sign-up/sign-in-and-sign-up.component')
);
const CheckoutPage = lazy(() =&gt; import('./pages/checkout/checkout.component'));  // react.lazy pozwala renderować dynamicznie importowane komponenty jak zwykłe komponenty. React.lazy jako argument przyjmuje funkcję, która wywołuje dynamiczny import(). Musi ona zwrócić obiekt (Promise) (pol. obietnicę), która rozwiązuje się do modułu z eksportem domyślnym (default) zawierającym komponent reactowy. “Leniwy” komponent powinien zostać wyrenderowany wewnątrz Suspense, dzięki któremu na czas ładowania możemy wyświetlić komponent zastępczy (np. wskaźnik ładowania).

const App = ({ checkUserSession, currentUser }) =&gt; {  // deklaracja, przekazanie propsów
  useEffect(() =&gt; {
    checkUserSession();
  }, [checkUserSession]);  // za pierwszym razem po zrenderowaniu DOMu wywołaj funkcję checkUserSession, jest tu użyta tablica optymalizacyjna, co znaczy, że komponent wyrenderuje się jeszcze raz jeżeli stan checkUserSession się zmieni

  return (
    &lt;PageWrapper&gt;  // wrapper styli dla wszystkiego znajdującego się w app
      &lt;GlobalStyle /&gt;  // style globalne dla całej aplikacji
      &lt;Header /&gt;
      &lt;Switch&gt;  // switch sprawia, że tylko pierwsza znaleziona, pasująca ścieżka url zostanie wyświetlona
        &lt;ErrorBoundary&gt;  // w przypadku wystąpienia jakiegoś błędu wyświetal stronę 404
          &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;  // w przypadku czekania na wgranie komponentu wyświetla kręcące się kółko
            &lt;Route exact path=&quot;/&quot; component={HomePage} /&gt;  // przy danej ścieżce url, wyświetl dany komponent
            &lt;Route path=&quot;/shop&quot; component={ShopPage} /&gt;  // przy danej ścieżce url, wyświetl dany komponent
            &lt;Route exact path=&quot;/checkout&quot; component={CheckoutPage} /&gt;  // przy danej ścieżce url, wyświetl dany komponent
            &lt;Route
              exact
              path=&quot;/signin&quot;
              render={() =&gt;
                currentUser ? &lt;Redirect to=&quot;/&quot; /&gt; : &lt;SignInAndSignUpPage /&gt;  // jeżeli użytkownik jest zalogowany przekierun ze strony /signin na /
              }
            /&gt;  // przy danej ścieżce url, wyświetl dany komponent
          &lt;/Suspense&gt;
        &lt;/ErrorBoundary&gt;
      &lt;/Switch&gt;
      &lt;Footer /&gt;
    &lt;/PageWrapper&gt;
  );
};

const mapStateToProps = createStructuredSelector({  // przekazuje ze store do props informacje o zalogowanym użytkowniku
  currentUser: selectCurrentUser,
});

const mapDispatchToProps = (dispatch) =&gt; ({  // sprawdź sesję użytkownika (czy jest zalogowany)
  checkUserSession: () =&gt; dispatch(checkUserSession()),
});

export default connect(mapStateToProps, mapDispatchToProps)(App);  // connect łączy komponent React ze store Redux</code></pre>
          </section>
          <hr class="divider" />

          <!-- global-styles
        ============================ -->
          <section id="idocs_global_styles">
            <h2>global-styles.js</h2>
            <p>Global-styles to plik zawierający style aplikowane do całej aplikacji globalnie. Używamy tutaj biblioteki styled-components.</p>
            <pre><code class="language-javascript">import { createGlobalStyle } from 'styled-components';  // funkcja pomocnicza do generowania specjalnego StyledComponent, który obsługuje style globalne
import styled from 'styled-components';  // import biblioteki styled components

export const GlobalStyle = createGlobalStyle`  // globalne style aplikowane do wszystkich komponentów
	body {
		font-family: 'Cairo', sans-serif;
		font-size: 16px;
		padding: 20px 40px;
		background-color: white;
		color: black;

		@media screen and (max-width: 800px) {
			padding: 10px;
		}
	}

	a {
		text-decoration: none;
		color: black;
		&amp;:hover {
    color: #e08800;
  }
	}

	* {
		box-sizing: border-box;
	}
`;

export const PageWrapper = styled.div`  // tworzy komponent PageWrapper, który renderuje tag html div z określonymi stylami
  position: relative;
  min-height: 95vh;
  max-width: 1300px;
  margin: 0 auto;
`;</code></pre>
          </section>
          <hr class="divider" />

          <!-- index_js
        ============================ -->
          <section id="idocs_index">
            <h2>index.js</h2>
            <p>W index.js znajduje się kod, który jest wstawiany w miejsce diva root w pliku index.html. Stanowi początek i "najwyższy" komponent w aplikacji.</p>
            <pre><code class="language-javascript">import React from 'react';  // potrzebne do interpretacji JS na JSX, gdy w Reakcie piszemy js, tak naprawdę w procesesie buildu zostanie to przekonwertowane na JSX i wywołane zostaną funkcje jak np. React.createElement(p), dla &lt;p&gt;&lt;/p&gt;
import ReactDOM from 'react-dom';  // biblioteka do obsługi DOM
import { BrowserRouter } from 'react-router-dom';  // rozwinięcie &lt;Router&gt;, kt&oacute;re używa interfejsu API historii HTML5 (pushState, replaceState i zdarzenia popstate), aby synchronizować interfejs użytkownika z adresem URL
import { Provider } from 'react-redux';  // aby odczytać stan ze store i wysyłać action do store, musimy wyrenderować komponent Provider wokół aplikacji, przekazując store redux jako prop do Provider
import { PersistGate } from 'redux-persist/integration/react';  // persistGate opóźnia renderowanie interfejsu użytkownika, dopóki stan nie zostanie pobrany i zapisany do ponownego wykorzystania

import { store, persistor } from './redux/store';  // import obiektów wymaganych do przekazania do provider i persistGate
import * as serviceWorker from './serviceWorker';

import ScrollToTop from './utils/scroll-to-top.component';  // service-worker to skrypt uruchamiany przez przeglądarkę w tle, niezależnie od strony internetowej, otwierający drzwi do funkcji, które nie wymagają strony internetowej ani interakcji użytkownika. Obecnie zawierają już takie funkcje, jak powiadomienia push i synchronizacja w tle, a także mają możliwość przechwytywania i obsługi żądań sieciowych, w tym programowego zarządzania pamięcią podręczną odpowiedzi.
import App from './App';  // import komponentu występującego w index.js

ReactDOM.render(
  &lt;Provider store={store}&gt; // obsługa store
    &lt;BrowserRouter&gt;  // obsługa nawigacji
      &lt;ScrollToTop /&gt;  // przewijanie na górę okna po nawigowaniu na nową stronę
      &lt;PersistGate persistor={persistor}&gt;  // "zapamiętywanie" store
        &lt;App /&gt;  // główny komponent aplikacji
      &lt;/PersistGate&gt;
    &lt;/BrowserRouter&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')  // zastąp element z id "root" w index.html
);

serviceWorker.register();  // włączenie service-workera</code></pre>
          </section>
          <hr class="divider" />

          <!-- service_worker
        ============================ -->
          <section id="idocs_service_worker">
            <h2>service-worker.js</h2>
            <p>Service worker to skrypt uruchamiany przez przeglądarkę w tle, niezależnie od strony internetowej, otwierający drzwi do funkcji, które nie wymagają strony internetowej ani interakcji użytkownika. Plik pozostawiam w stanie oryginalnym, ponieważ został wygenerowany automatycznie.</p>
            <pre><code class="language-javascript">/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) =&gt; {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) =&gt;
    url.origin === self.location.origin &amp;&amp; url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) =&gt; {
  if (event.data &amp;&amp; event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.</code></pre>
          </section>
          <hr class="divider" />

          <!-- setup-tests
        ============================ -->
          <section id="idocs_setup_tests">
            <h2>setup-tests.js</h2>
            <p>Plik pomocniczy do enzyme.</p>
            <pre><code class="language-javascript">import { configure } from 'enzyme';  // enzyme to biblioteka do testowanie javascript
import Adapter from 'enzyme-adapter-react-16';  // potrzebne do zainstalowania enzyme

configure({ adapter: new Adapter() }); // inicjalizacja enzyme</code></pre>
          </section>
          <hr class="divider" />

          <!-- Redux
                  ============================ -->
          <section id="idocs_redux">
            <h2>Redux</h2>
            <p>Jednym z założeń React jest jednokierunkowy przepływ danych w aplikacji - wszelkie dane wpływają
              do naszego komponentu, który nie powinien ich mutować - jeżeli potrzebuje je zaktualizować,
              wykonuje to poprzez wywołanie this.setState lub callbacku przekazanego przez rodzica.</p>
            <p>Idea Redux opiera się o założenie, że stan aplikacji (dane) są wynikiem poprzedniego (w tym
              początkowego) stanu zmodyfikowanego przez akcje - dzięki temu założeniu możliwe jest łatwe
              testowanie, zapisywanie i wznawianie a także "podróż w czasie" (czyli nic innego jak undo i redo
              na poziomie całej aplikacji). Z technicznego punktu widzenia, Redux jest implementacją wzorca
              publisher-subscriber.</p>
            <p>
              <a class="popup-img" href="assets/images/redux.png"><img class="img-fluid border"
                  src="assets/images/redux.png" alt="" /></a>
            </p>
          </section>
          <hr class="divider" />

          <!-- store
        ============================ -->
          <section id="idocs_store">
            <h2>store.js</h2>
            <p>Store jest kluczowym elementem Reduxa, jednym z niewielu, jakie tworzy API Reduxa. To w store
              przechowywane są dane, to "do" store emitowane są akcje i to store obsługuje bardziej złożone
              mechanizmy jak middleware i enhancery. Store tworzone jest poprzez wywołanie funkcji createStore
              i przekazanie do niej naszego reducera.</p>
            <pre><code class="language-javascript">import { createStore, applyMiddleware } from 'redux';  // import funkcji createStore, która tworzy store Redux, który przechowuje pełne drzewo state i applyMiddleware, czyli oprogramowanie pośrednicząca między funkcją dispatch,a store
import { persistStore } from 'redux-persist';  // aby używać persistReducerów pamiętających ostatnio istniejący stan, należy używac persistStore
import logger from 'redux-logger';  // middleware pozwalające na wyświetlanie logów operacji redux, np. przesłane action
import createSagaMiddleware from 'redux-saga';  // middleware saga pozwalające na tworzenie "efektów ubocznych" do dispatchowanych akcji

import rootReducer from './root-reducer';  // reducer zawierający wszystkie inne reducery
import rootSaga from './root-saga';  // saga zawierająca wszystkie inne sagi

const sagaMiddleware = createSagaMiddleware();  // deklaracja middleware

const middlewares = [sagaMiddleware];   // tablica z middleware'ami

if (process.env.NODE_ENV === 'development') {  // jeżeli kod zostanie uruchomiony w trybie development do tablicy z middlewarami dodaj logger
  middlewares.push(logger);
}

export const store = createStore(rootReducer, applyMiddleware(...middlewares));  // stwórz store z rootReducerem i middlewarami do store

sagaMiddleware.run(rootSaga);  // rozpocznij middleware saga

export const persistor = persistStore(store);  // persistuj store

export default { store, persistStore };  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />

          <!-- saga-testing
        ============================ -->
          <section id="idocs_saga_testing_utils">
            <h2>saga-testing.utils.js</h2>
            <p>Pomocnicza funkcja do testowania czy sagi działają prawidłowo.</p>
            <pre><code class="language-javascript">import { runSaga } from 'redux-saga';  // runSaga umożliwia uruchamianie sag poza środowiskiem oprogramowania pośredniego Redux

export async function recordSaga(saga, initialAction) {  // symuluj wywołanie sagi przy dispatchu akcji
  const dispatched = [];

  await runSaga(
    {
      dispatch: (action) =&gt; dispatched.push(action),
    },
    saga,
    initialAction
  ).done;

  return dispatched;
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- root-saga
        ============================ -->
          <section id="idocs_root_saga">
            <h2>root-saga.js</h2>
            <p>RootSaga to główna saga zbierająca wszystkie inne sagi. Sagi pozwalają na wstawienie dodatkowego
              kodu pomiędzy dispatchem akcji, a dotarciem tej akcji do store.</p>
            <pre><code class="language-javascript">import { all, call } from 'redux-saga/effects';  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję, all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie

import { shopSagas } from './shop/shop.sagas';  // saga pozwala na stworzenie "skutków ubocznych" w trakcie dispatchowania akcji
import { userSagas } from './user/user.sagas';  // saga pozwala na stworzenie "skutków ubocznych" w trakcie dispatchowania akcji
import { cartSagas } from './cart/cart.sagas';  // saga pozwala na stworzenie "skutków ubocznych" w trakcie dispatchowania akcji

export default function* rootSaga() {
  yield all([call(shopSagas), call(userSagas), call(cartSagas)]);  // all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie ,yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- root-reducer
        ============================ -->
          <section id="idocs_redux_root_reducer">
            <h2>root-reducer.js</h2>
            <p>RootReducer to reducer zbierający wszystkie inne reducery. Reducer to funkcja, które przyjmuje
              bieżący state i action jako argumenty i zwracają wynik nowego state</p>
            <pre><code class="language-javascript">import { combineReducers } from 'redux';  // Funkcja pomocnicza combineReducers() zamienia obiekt, którego wartości są różnymi funkcjami redukującymi, w pojedynczą funkcję redukującą, którą możesz przekazać do createStore. Wynikowy reducer wywołuje każdy reducer podrzędny i gromadzi ich wyniki w jednym obiekcie state. State wytworzony przez combineReducers() jest przestrzenią nazw stanów każdego reducera pod ich kluczami przekazanymi do combineReducers().

import { persistReducer } from 'redux-persist';  // persistReducer zwraca ulepszony reducer, który otacza przekazany rootReducer i będzie utrzymywał stan tego reducera zgodnie z wcześniej przekazaną konfiguracją.
import storage from 'redux-persist/lib/storage';  // storage w Redux Persist obsługuje wiele różnych zapleczy pamięci masowej w zależności od środowiska. W przypadku korzystania z apliakcji webowych obsługiwane są zarówno interfejsy API localStorage i sessionStorage, jak i podstawowe pliki cookie.

import userReducer from './user/user.reducer';  // reducers to funkcje, które przyjmują bieżący state i action jako argumenty i zwracają wynik nowego state
import cartReducer from './cart/cart.reducer';  // reducers to funkcje, które przyjmują bieżący state i action jako argumenty i zwracają wynik nowego state
import directoryReducer from './directory/directory.reducer';  // reducers to funkcje, które przyjmują bieżący state i action jako argumenty i zwracają wynik nowego state
import shopReducer from './shop/shop.reducer';  // reducers to funkcje, które przyjmują bieżący state i action jako argumenty i zwracają wynik nowego state

const persistConfig = {  // konfiguracja do persistent redux
  key: 'root',
  storage,
  whitelist: ['cart'],  // nie "persistuj" stanu koszyka
};

const rootReducer = combineReducers({  // połączenie wszystkich reducerów w jeden rootReducer
  user: userReducer,
  cart: cartReducer,
  directory: directoryReducer,
  shop: shopReducer,
});

export default persistReducer(persistConfig, rootReducer);  // łączy w persistReducer, konfigurację + rootReducer</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.actions
        ============================ -->
          <section id="idocs_redux_cart_actions">
            <h2>cart.actions.js</h2>
            <p>CartActions to zwykłe obiekty JavaScript, które mają pole typu. Akcja opisuje coś, co wydarzyło
              się w aplikacji.</p>
            <pre><code class="language-javascript">import CartActionTypes from &quot;./cart.types&quot;;  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
// zmienne poniżej definiują akcje, czyli obiekt zawierający typ lub/i payload
export const toggleCartHidden = () =&gt; ({
  type: CartActionTypes.TOGGLE_CART_HIDDEN,
});

export const addItem = (item) =&gt; ({
  type: CartActionTypes.ADD_ITEM,
  payload: item,
});

export const removeItem = (item) =&gt; ({
  type: CartActionTypes.REMOVE_ITEM,
  payload: item,
});

export const clearItemFromCart = (item) =&gt; ({
  type: CartActionTypes.CLEAR_ITEM_FROM_CART,
  payload: item,
});

export const clearCart = () =&gt; ({
  type: CartActionTypes.CLEAR_CART,
});
</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.actions.test
============================ -->
          <section id="idocs_redux_cart_actions_test">
            <h2>cart.actions.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import CartActionTypes from './cart.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import {
  toggleCartHidden,
  addItem,
  removeItem,
  clearItemFromCart,
  clearCart,
} from './cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

describe('toggleCartHidden action', () =&gt; {
  it('should create the toggleHidden action', () =&gt; {  // sprawdź czy action toggleHidden działa prawidłowo
    expect(toggleCartHidden().type).toEqual(CartActionTypes.TOGGLE_CART_HIDDEN);
  });
});

describe('addItem action', () =&gt; {
  it('should create the addItem action', () =&gt; {  // sprawdź czy action additem istnieje
    const mockItem = {
      id: 1,
    };

    const action = addItem(mockItem);

    expect(action.type).toEqual(CartActionTypes.ADD_ITEM);
    expect(action.payload).toEqual(mockItem);
  });
});

describe('removeItem action', () =&gt; {
  it('should create the removeItem action', () =&gt; {  // sprawdź czy action removeItem istnieje
    const mockItem = {
      id: 1,
    };

    const action = removeItem(mockItem);

    expect(action.type).toEqual(CartActionTypes.REMOVE_ITEM);
    expect(action.payload).toEqual(mockItem);
  });
});

describe('clearItemFromCart action', () =&gt; {
  it('should create the clearItemFromCart action', () =&gt; {  // sprawdź czy action clearItemFromCart istnieje
    const mockItem = {
      id: 1,
    };

    const action = clearItemFromCart(mockItem);

    expect(action.type).toEqual(CartActionTypes.CLEAR_ITEM_FROM_CART);
    expect(action.payload).toEqual(mockItem);
  });
});

describe('clearCart action', () =&gt; {
  it('should create the clearCart action', () =&gt; {  // sprawdź czy action clearCart istnieje
    expect(clearCart().type).toEqual(CartActionTypes.CLEAR_CART);
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.reducer
============================ -->
          <section id="idocs_redux_cart_reducer">
            <h2>cart.reducer.js</h2>
            <p>Reducer to funkcja, które przyjmuje bieżący state i action jako argumenty i zwracają wynik nowego
              state</p>
            <pre><code class="language-javascript">import CartActionTypes from './cart.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import { addItemToCart, removeItemFromCart } from './cart.utils';  // import funkcji pomocniczych

const INITIAL_STATE = {  // startowy state
  hidden: true,
  cartItems: [],
};

const cartReducer = (state = INITIAL_STATE, action) =&gt; {  // reducer dla koszyka
  switch (action.type) {
    case CartActionTypes.TOGGLE_CART_HIDDEN:  // schowanie lub pokazanie koszyka
      return {
        ...state,
        hidden: !state.hidden,
      };
    case CartActionTypes.ADD_ITEM:  // dodanie produktu do koszyka
      return {
        ...state,
        cartItems: addItemToCart(state.cartItems, action.payload),
      };
    case CartActionTypes.REMOVE_ITEM:  // zmniejszenie ilości produktu w koszyku o 1
      return {
        ...state,
        cartItems: removeItemFromCart(state.cartItems, action.payload),
      };
    case CartActionTypes.CLEAR_ITEM_FROM_CART:  // usunięcie produktu z koszyka
      return {
        ...state,
        cartItems: state.cartItems.filter(
          (cartItem) =&gt; cartItem.id !== action.payload.id
        ),
      };
    case CartActionTypes.CLEAR_CART:  // wyczyszcenie koszyka
      return {
        ...state,
        cartItems: [],
      };
    default:
      return state;
  }
};

export default cartReducer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.reducer.test
============================ -->
          <section id="idocs_redux_cart_reducer_test">
            <h2>cart.reducer.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import CartActionTypes from './cart.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import cartReducer from './cart.reducer';  // reducers to funkcje, które przyjmują bieżący state i action jako argumenty i zwracają wynik nowego state

const initialState = {  // startowy state
  hidden: true,
  cartItems: [],
};

describe('cartReducer', () =&gt; {
  it('should return initial state', () =&gt; {  // startowy stan koszyka to schowany koszyk, bez produktów w środku
    expect(cartReducer(undefined, {})).toEqual(initialState);
  });

  it('should toggle hidden with toggleHidden action', () =&gt; {  // chowaj lub pokazuj koszyk po wywołaniu akcji TOGGLE_CART_HIDDEN
    expect(
      cartReducer(initialState, { type: CartActionTypes.TOGGLE_CART_HIDDEN })
        .hidden
    ).toBe(false);
  });

  it('should increase quantity of matching item by 1 if addItem action fired with same item as payload', () =&gt; {  // zwiększaj ilość produktu o 1 przy akcji ADD_ITEM
    const mockItem = {
      id: 1,
      quantity: 3,
    };

    const mockPrevState = {
      hidden: true,
      cartItems: [mockItem, { id: 2, quantity: 1 }],
    };

    expect(
      cartReducer(mockPrevState, {
        type: CartActionTypes.ADD_ITEM,
        payload: mockItem,
      }).cartItems[0].quantity
    ).toBe(4);
  });

  it('should decrease quantity of matching item by 1 if removeItem action fired with same item as payload', () =&gt; {  // zmniejszaj ilość produktu o 1 przy akcji REMOVE_ITEM
    const mockItem = {
      id: 1,
      quantity: 3,
    };

    const mockPrevState = {
      hidden: true,
      cartItems: [mockItem, { id: 2, quantity: 1 }],
    };

    expect(
      cartReducer(mockPrevState, {
        type: CartActionTypes.REMOVE_ITEM,
        payload: mockItem,
      }).cartItems[0].quantity
    ).toBe(2);
  });

  it('should remove item from cart if clearItemFromCart action fired with payload of existing item', () =&gt; {  // usuń produkt z koszyka przy wywołaniu akcji CLEAR_ITEM_FROM_CART
    const mockItem = {
      id: 1,
      quantity: 3,
    };

    const mockPrevState = {
      hidden: true,
      cartItems: [mockItem, { id: 2, quantity: 1 }],
    };

    expect(
      cartReducer(mockPrevState, {
        type: CartActionTypes.CLEAR_ITEM_FROM_CART,
        payload: mockItem,
      }).cartItems.includes((item) =&gt; item.id === 1)
    ).toBe(false);
  });

  it('should clear cart if clearCart action fired', () =&gt; {  // wyczyść koszyk przy wywołaniu akcji CLEAR_CART
    const mockPrevState = {
      hidden: true,
      cartItems: [
        { id: 1, quantity: 3 },
        { id: 2, quantity: 1 },
      ],
    };

    expect(
      cartReducer(mockPrevState, {
        type: CartActionTypes.CLEAR_CART,
      }).cartItems.length
    ).toBe(0);
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.sagas
============================ -->
          <section id="idocs_redux_cart_sagas">
            <h2>cart.sagas.js</h2>
            <p>Sagi pozwalają na wstawienie dodatkowego kodu pomiędzy dispatchem akcji, a dotarciem tej akcji do
              store.</p>
            <pre><code class="language-javascript">import { all, call, takeLatest, put, select } from 'redux-saga/effects';  // all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję

import UserActionTypes from '../user/user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import { selectCurrentUser } from '../user/user.selectors';  // selektor to getter dla store
import { selectCartItems } from './cart.selectors';  // selektor to getter dla store
import CartActionTypes from './cart.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

export function* clearCartOnSignOut() {  // wyczyść koszyk przy wylogowaniu się
  yield put(clearCart());  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
}

export function* onSignOutSuccess() {  // sukces wylogowania
  yield takeLatest(UserActionTypes.SIGN_OUT_SUCCESS, clearCartOnSignOut);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
}

export function* onCartChange() {  // przy zmianie stanu koszyka
  yield takeLatest(  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    [
      CartActionTypes.ADD_ITEM,
      CartActionTypes.REMOVE_ITEM,
      CartActionTypes.CLEAR_ITEM_FROM_CART,
    ],
  );
}

export function* cartSagas() {  // sagi dla koszyka
  yield all([call(onSignOutSuccess), call(onCartChange), call(onUserSignIn)]);  // all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie, yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.sagas.test
============================ -->
          <section id="idocs_redux_cart_sagas_test">
            <h2>cart.sagas.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import { takeLatest, put } from 'redux-saga/effects';    // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu

import UserActionTypes from '../user/user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import { clearCart } from './cart.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.
import { clearCartOnSignOut, onSignOutSuccess } from './cart.sagas';  // saga pozwala na stworzenie "skutków ubocznych" w trakcie dispatchowania akcji

describe('on signout success saga', () =&gt; {  // saga dla wylogowywania się
  it('should trigger on SIGN_OUT_SUCCESS', async () =&gt; {
    const generator = onSignOutSuccess();
    expect(generator.next().value).toEqual(
      takeLatest(UserActionTypes.SIGN_OUT_SUCCESS, clearCartOnSignOut)
    );
  });
});

describe('clear cart on signout saga', () =&gt; {  // wyczyść koszyk po wylogowaniu się
  it('should fire clearCart', () =&gt; {
    const generator = clearCartOnSignOut();
    expect(generator.next().value).toEqual(put(clearCart()));  // put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart.selectors
============================ -->
          <section id="idocs_redux_cart_selectors">
            <h2>cart.selectors.js</h2>
            <p>Selectors to gettery dla store w Redux</p>
            <pre><code class="language-javascript">import { createSelector } from 'reselect';  // createSelector może akceptować wiele selectorów wejściowych, które mogą być dostarczone jako oddzielne argumenty lub jako tablica. Wyniki ze wszystkich selectorów danych wejściowych są dostarczane jako osobne argumenty do selectora wyjściowego
// poniższe zmienne zwracają zawartość store Reduxa, konkretnych jego części
const selectCart = (state) =&gt; state.cart;

export const selectCartItems = createSelector(
  [selectCart],
  (cart) =&gt; cart.cartItems
);

export const selectCartHidden = createSelector(
  [selectCart],
  (cart) =&gt; cart.hidden
);

export const selectCartItemsCount = createSelector(
  [selectCartItems],
  (cartItems) =&gt;
    cartItems.reduce(
      (accumalatedQuantity, cartItem) =&gt;
        accumalatedQuantity + cartItem.quantity,
      0
    )
);

export const selectCartTotal = createSelector([selectCartItems], (cartItems) =&gt;
  cartItems.reduce(
    (accumalatedQuantity, cartItem) =&gt;
      accumalatedQuantity + cartItem.quantity * cartItem.price,
    0
  )
);</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart-types
============================ -->
          <section id="idocs_redux_cart_types">
            <h2>cart.types.js</h2>
            <p>CartTypes zawiera typy akcji, czyli rodzaju akcji, którą chcemy wysłać do state</p>
            <pre><code class="language-javascript">const CartActionTypes = {
  TOGGLE_CART_HIDDEN: 'TOGGLE_CART_HIDDEN',
  ADD_ITEM: 'ADD_ITEM',
  REMOVE_ITEM: 'REMOVE_ITEM',
  CLEAR_ITEM_FROM_CART: 'CLEAR_ITEM_FROM_CART',
  CLEAR_CART: 'CLEAR_CART',
};

export default CartActionTypes;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />

          <!-- cart-utils
============================ -->
          <section id="idocs_redux_cart_utils">
            <h2>cart.utils.js</h2>
            <p>W CartUtils zebrane są najbardziej przydatne funkcję do obsługi koszyka.</p>
            <pre><code class="language-javascript">export const addItemToCart = (cartItems, cartItemToAdd) =&gt; {  // dodaj produkt do koszyka
  const existingCartItem = cartItems.find(
    cartItem =&gt; cartItem.id === cartItemToAdd.id
  );

  if (existingCartItem) {  // jeżeli produkt już jest w koszyku zwiększ jego ilość o 1
    return cartItems.map(cartItem =&gt;
      cartItem.id === cartItemToAdd.id
        ? { ...cartItem, quantity: cartItem.quantity + 1 }
        : cartItem
    );
  }

  return [...cartItems, { ...cartItemToAdd, quantity: 1 }];  // w przeciwnym wypadku dodaj 1 sztukę produktu
};

export const removeItemFromCart = (cartItems, cartItemToRemove) =&gt; {  // zmniejsz ilość produktu w koszyku
  const existingCartItem = cartItems.find(
    cartItem =&gt; cartItem.id === cartItemToRemove.id
  );

  if (existingCartItem.quantity === 1) {  // jeżeli ilość produktu = 1, usuń produkt z koszyka
    return cartItems.filter(cartItem =&gt; cartItem.id !== cartItemToRemove.id);
  }

  return cartItems.map(cartItem =&gt;  // w przeciwnym wypadku zmniejsz ilość produktu o 1
    cartItem.id === cartItemToRemove.id
      ? { ...cartItem, quantity: cartItem.quantity - 1 }
      : cartItem
  );
};</code></pre>
          </section>
          <hr class="divider" />

          <!-- directory.reducer
============================ -->
          <section id="idocs_redux_directory_reducer">
            <h2>directory.reducer.js</h2>
            <p>Reducer to funkcja, które przyjmuje bieżący state i action jako argumenty i zwracają wynik nowego
              state</p>
            <pre><code class="language-javascript">export const INITIAL_STATE = {  // startowy state
  sections: [
    {
      title: &quot;womens&quot;,
      imageUrl: &quot;https://i.ibb.co/J32zjQV/womens.png&quot;,
      id: 1,
      linkUrl: &quot;shop/womens&quot;,
    },
    {
      title: &quot;mens&quot;,
      imageUrl: &quot;https://i.ibb.co/Q9kcXrN/mens.png&quot;,
      id: 2,
      linkUrl: &quot;shop/mens&quot;,
    },
    {
      title: &quot;kids&quot;,
      imageUrl: &quot;https://i.ibb.co/26YNQbG/kids.png&quot;,
      id: 3,
      linkUrl: &quot;shop/kids&quot;,
    },
    {
      title: &quot;pregnancy&quot;,
      imageUrl: &quot;https://i.ibb.co/kMc8dW7/pregnancy.png&quot;,
      id: 4,
      linkUrl: &quot;shop/pregnancy&quot;,
    },
    {
      title: &quot;jackets&quot;,
      imageUrl: &quot;https://i.ibb.co/7QC9Bdb/jackets.png&quot;,
      id: 5,
      linkUrl: &quot;shop/jackets&quot;,
    },
    {
      title: &quot;sneakers&quot;,
      imageUrl: &quot;https://i.ibb.co/n8GjNJR/sneakers.png&quot;,
      id: 6,
      linkUrl: &quot;shop/sneakers&quot;,
    },
    {
      title: &quot;hats&quot;,
      imageUrl: &quot;https://i.ibb.co/cvpntL1/hats.png&quot;,
      id: 7,
      linkUrl: &quot;shop/hats&quot;,
    },
    {
      title: &quot;watches&quot;,
      imageUrl: &quot;https://i.ibb.co/xgQByt5/accesories.png&quot;,
      id: 8,
      linkUrl: &quot;shop/watches&quot;,
    },
    {
      title: &quot;jewelry&quot;,
      imageUrl: &quot;https://i.ibb.co/10LbRR2/jewelry.png&quot;,
      id: 9,
      linkUrl: &quot;shop/jewelry&quot;,
    },
  ],
};

const directoryReducer = (state = INITIAL_STATE, action) =&gt; {  // reducer dla directory
  switch (action.type) {
    default:
      return state;
  }
};

export default directoryReducer;</code></pre>
          </section>
          <hr class="divider" />

          <!-- directory.reducer.test
============================ -->
          <section id="idocs_redux_directory_reducer_test">
            <h2>directory.reducer.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import directoryReducer, { INITIAL_STATE } from './directory.reducer';  // reducers to funkcje, które przyjmują bieżący state i action jako argumenty i zwracają wynik nowego state

describe('directoryReducer', () =&gt; {
  it('should return initial state', () =&gt; {  // sprawdź czy reducer ustawi stan startowy dla directory
    expect(directoryReducer(undefined, {})).toEqual(INITIAL_STATE);
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- directory.selectors
============================ -->
          <section id="idocs_redux_directory_selectors">
            <h2>directory.selectors.js</h2>
            <p>Selectors to gettery dla store w Redux.</p>
            <pre><code class="language-javascript">import { createSelector } from 'reselect';  // createSelector może akceptować wiele selectorów wejściowych, które mogą być dostarczone jako oddzielne argumenty lub jako tablica. Wyniki ze wszystkich selectorów danych wejściowych są dostarczane jako osobne argumenty do selectora wyjściowego
// poniższe zmienne zwracają zawartość store Reduxa, konkretnych jego części
const selectDirectory = state =&gt; state.directory;

export const selectDirectorySections = createSelector(
  [selectDirectory],
  directory =&gt; directory.sections
);</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.actions
                        ============================ -->
          <section id="idocs_redux_shop_actions">
            <h2>shop.actions.js</h2>
            <p>ShopActions to zwykłe obiekty JavaScript, które mają pole typu. Akcja opisuje coś, co wydarzyło
              się w aplikacji.</p>
            <pre><code class="language-javascript">import ShopActionTypes from './shop.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
// zmienne poniżej definiują akcje, czyli obiekt zawierający typ lub/i payload

export const fetchCollectionsStart = () =&gt; ({  // rozpocznij pobieranie kolekcji
  type: ShopActionTypes.FETCH_COLLECTIONS_START
});

export const fetchCollectionsSuccess = collectionsMap =&gt; ({  // przy sukcesie zwraca kolekcję
  type: ShopActionTypes.FETCH_COLLECTIONS_SUCCESS,
  payload: collectionsMap
});

export const fetchCollectionsFailure = errorMessage =&gt; ({  // przy błędzie zwraca error
  type: ShopActionTypes.FETCH_COLLECTIONS_FAILURE,
  payload: errorMessage
});

export const fetchCollectionsStartAsync = () =&gt; {  // połączenie 3 funkcji powyżej
  return dispatch =&gt; {
    const collectionRef = firestore.collection('collections');
    dispatch(fetchCollectionsStart());

    collectionRef
      .get()
      .then(snapshot =&gt; {
        const collectionsMap = convertCollectionsSnapshotToMap(snapshot);
        dispatch(fetchCollectionsSuccess(collectionsMap));
      })
      .catch(error =&gt; dispatch(fetchCollectionsFailure(error.message)));
  };
};</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.actions.test
============================ -->
          <section id="idocs_redux_shop_actions_test">
            <h2>shop.actions.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import ShopActionTypes from './shop.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import {
  fetchCollectionsStart,
  fetchCollectionsSuccess,
  fetchCollectionsFailure,
  fetchCollectionsStartAsync
} from './shop.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

describe('fetchCollectionsStart action', () =&gt; {
  it('should create the fetchCollectionsStart action', () =&gt; {  // sprawdź czy fetchCollectionsStart się uruchamia
    expect(fetchCollectionsStart().type).toEqual(
      ShopActionTypes.FETCH_COLLECTIONS_START
    );
  });
});

describe('fetchCollectionsSuccess action', () =&gt; {
  it('should create the fetchCollectionsSuccess action', () =&gt; {  // sprawdź czy action fetchCollectionsSuccess istnieje
    const mockCollectionsMap = {
      hats: {
        id: 1
      }
    };

    const action = fetchCollectionsSuccess(mockCollectionsMap);

    expect(action.type).toEqual(ShopActionTypes.FETCH_COLLECTIONS_SUCCESS);
    expect(action.payload).toEqual(mockCollectionsMap);
  });
});

describe('fetchCollectionsFailure action', () =&gt; {
  it('should create the fetchCollectionsFailure action', () =&gt; {  // sprawdź czy action fetchCollectionsFailure istnieje
    const action = fetchCollectionsFailure('errored');

    expect(action.type).toEqual(ShopActionTypes.FETCH_COLLECTIONS_FAILURE);
    expect(action.payload).toEqual('errored');
  });
});

describe('fetchCollectionsStartAsync action', () =&gt; {
  it('should create the fetchCollectionsStartAsync action', () =&gt; {  // sprawdź czy action fetchCollectionsStartAsync istnieje
    const mockActionCreator = fetchCollectionsStartAsync();
    const mockDispatch = jest.fn();
    mockActionCreator(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(fetchCollectionsStart());
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.reducer
============================ -->
          <section id="idocs_redux_shop_reducer">
            <h2>shop.reducer.js</h2>
            <p>Reducer to funkcja, które przyjmuje bieżący state i action jako argumenty i zwracają wynik nowego
              state</p>
            <pre><code class="language-javascript">import ShopActionTypes from './shop.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

const INITIAL_STATE = {  // startowy state
  collections: null,
  isFetching: false,
  errorMessage: undefined
};

const shopReducer = (state = INITIAL_STATE, action) =&gt; {  // reducer dla kategorii i produktów
  switch (action.type) {
    case ShopActionTypes.FETCH_COLLECTIONS_START:
      return {
        ...state,
        isFetching: true
      };
    case ShopActionTypes.FETCH_COLLECTIONS_SUCCESS:
      return {
        ...state,
        isFetching: false,
        collections: action.payload
      };
    case ShopActionTypes.FETCH_COLLECTIONS_FAILURE:
      return {
        ...state,
        isFetching: false,
        errorMessage: action.payload
      };
    default:
      return state;
  }
};

export default shopReducer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.reducer.test
============================ -->
          <section id="idocs_redux_shop_reducer_test">
            <h2>shop.reducer.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import ShopActionTypes from './shop.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import shopReducer from './shop.reducer';

const initialState = {  // startowy state
  collections: null,
  isFetching: false,
  errorMessage: undefined
};

describe('shopReducer', () =&gt; {
  it('should return initial state', () =&gt; {  // sprawdź czy startowy state znajduje się w store
    expect(shopReducer(undefined, {})).toEqual(initialState);
  });

  it('should set isFetching to true if fetchingCollectionsStart action', () =&gt; {  // przy fetchingCollectionsStart zmienna isFetching powinna zmienić się na true
    expect(
      shopReducer(initialState, {
        type: ShopActionTypes.FETCH_COLLECTIONS_START
      }).isFetching
    ).toBe(true);
  });

  it('should set isFetching to false and collections to payload if fetchingCollectionsSuccess', () =&gt; {  // przy fetchingCollectionsSucess, zmienna isFetching powinna zmienić się na falce, a collections powinien przyjąć wartość payload
    const mockItems = [{ id: 1 }, { id: 2 }];
    expect(
      shopReducer(initialState, {
        type: ShopActionTypes.FETCH_COLLECTIONS_SUCCESS,
        payload: mockItems
      })
    ).toEqual({
      ...initialState,
      isFetching: false,
      collections: mockItems
    });
  });

  it('should set isFetching to false and errorMessage to payload if fetchingCollectionsFailure', () =&gt; {  // przy fetchingCollectionsFailure zmienna isFetching powinna zmienić się na false, a errorMessgae przyjąć wartość payload
    expect(
      shopReducer(initialState, {
        type: ShopActionTypes.FETCH_COLLECTIONS_FAILURE,
        payload: 'error'
      })
    ).toEqual({
      ...initialState,
      isFetching: false,
      errorMessage: 'error'
    });
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.sagas
============================ -->
          <section id="idocs_redux_shop_sagas">
            <h2>shop.sagas.js</h2>
            <p>Sagi pozwalają na wstawienie dodatkowego kodu pomiędzy dispatchem akcji, a dotarciem tej akcji do
              store.</p>
            <pre><code class="language-javascript">import { takeLatest, call, put, all } from 'redux-saga/effects';  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu, all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie

import {
  fetchCollectionsSuccess,
  fetchCollectionsFailure
} from './shop.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import ShopActionTypes from './shop.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

export function* fetchCollectionsAsync() {  // pobierz zawartość kolekcji
  try {
    const collectionRef = firestore.collection('collections');
    const snapshot = yield collectionRef.get();  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    const collectionsMap = yield call(  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
      convertCollectionsSnapshotToMap,
      snapshot
    );
    yield put(fetchCollectionsSuccess(collectionsMap));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  } catch (error) {
    yield put(fetchCollectionsFailure(error.message));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  }
}

export function* fetchCollectionsStart() {  // wyślij akcję do store, rozpocznij pobieranie kolekcji
  yield takeLatest(  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
    ShopActionTypes.FETCH_COLLECTIONS_START,
    fetchCollectionsAsync
  );
}

export function* shopSagas() {
  yield all([call(fetchCollectionsStart)]);  // all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie ,yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.sagas.test
============================ -->
          <section id="idocs_redux_shop_sagas_test">
            <h2>shop.sagas.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import { takeLatest, call, put } from 'redux-saga/effects';  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu

import {
  fetchCollectionsSuccess,
  fetchCollectionsFailure
} from './shop.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import ShopActionTypes from './shop.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

import { fetchCollectionsAsync, fetchCollectionsStart } from './shop.sagas';  // saga pozwala na stworzenie "skutków ubocznych" w trakcie dispatchowania akcji

describe('fetch collections start saga', () =&gt; {
  it('should trigger on FETCH_COLLECTIONS_START', () =&gt; {
    const generator = fetchCollectionsStart();
    expect(generator.next().value).toEqual(
      takeLatest(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync)  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
    );
  });
});

describe('fetch collections async saga', () =&gt; {  // saga do fetchCollectionsAsync
  const generator = fetchCollectionsAsync();

  it('should call firestore collection ', () =&gt; {  // połącz się z kolekcja
    const getCollection = jest.spyOn(firestore, 'collection');
    generator.next();
    expect(getCollection).toHaveBeenCalled();
  });

  it('should call convertCollectionsSnapshot saga ', () =&gt; {  // pobierz zawartość 
    const mockSnapshot = {};
    expect(generator.next(mockSnapshot).value).toEqual(
      call(convertCollectionsSnapshotToMap, mockSnapshot)  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
    );
  });

  it('should fire fetchCollectionsSuccess if collectionsMap is succesful', () =&gt; {  // przekonwertuj w tablicę z obiektami
    const mockCollectionsMap = {
      hats: { id: 1 }
    };

    expect(generator.next(mockCollectionsMap).value).toEqual(  // sprawdź czy powyzsze funkcje wykonały się prawidłowo
      put(fetchCollectionsSuccess(mockCollectionsMap))  // put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
    );
  });

  it('should fire fetchCollectionsFailure if get collection fails at any point', () =&gt; {  // w przypadku errorów wywołaj fetchCollectionsFailure
    const newGenerator = fetchCollectionsAsync();
    newGenerator.next();
    expect(newGenerator.throw({ message: 'error' }).value).toEqual(
      put(fetchCollectionsFailure('error'))  // put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
    );
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop.selectors
============================ -->
          <section id="idocs_redux_shop_selectors">
            <h2>shop.selectors.js</h2>
            <p>Selectors to gettery dla store w Redux.</p>
            <pre><code class="language-javascript">import { createSelector } from 'reselect';  // createSelector może akceptować wiele selectorów wejściowych, które mogą być dostarczone jako oddzielne argumenty lub jako tablica. Wyniki ze wszystkich selectorów danych wejściowych są dostarczane jako osobne argumenty do selectora wyjściowego
// poniższe zmienne zwracają zawartość store Reduxa, konkretnych jego części
const selectShop = state =&gt; state.shop;

export const selectCollections = createSelector(
  [selectShop],
  shop =&gt; shop.collections
);

export const selectCollectionsForPreview = createSelector(
  [selectCollections],
  collections =&gt;
    collections ? Object.keys(collections).map(key =&gt; collections[key]) : []
);

export const selectCollection = collectionUrlParam =&gt;
  createSelector(
    [selectCollections],
    collections =&gt; (collections ? collections[collectionUrlParam] : null)
  );

export const selectIsCollectionFetching = createSelector(
  [selectShop],
  shop =&gt; shop.isFetching
);

export const selectIsCollectionsLoaded = createSelector(
  [selectShop],
  shop =&gt; !!shop.collections
);</code></pre>
          </section>
          <hr class="divider" />

          <!-- shop-types
============================ -->
          <section id="idocs_redux_shop_types">
            <h2>shop.types.js</h2>
            <p>ShopTypes zawiera typy akcji, czyli rodzaju akcji, którą chcemy wysłać do state</p>
            <pre><code class="language-javascript">const ShopActionTypes = {
  FETCH_COLLECTIONS_START: 'FETCH_COLLECTIONS_START',
  FETCH_COLLECTIONS_SUCCESS: 'FETCH_COLLECTIONS_SUCCESS',
  FETCH_COLLECTIONS_FAILURE: 'FETCH_COLLECTIONS_FAILURE'
};

export default ShopActionTypes;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />

          <!-- user.actions
                        ============================ -->
          <section id="idocs_redux_user_actions">
            <h2>user.actions.js</h2>
            <p>UserActions to zwykłe obiekty JavaScript, które mają pole typu. Akcja opisuje coś, co wydarzyło
              się w aplikacji.</p>
            <pre><code class="language-javascript">import UserActionTypes from './user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
// zmienne poniżej definiują akcje, czyli obiekt zawierający typ lub/i payload

export const signInSuccess = user =&gt; ({
  type: UserActionTypes.SIGN_IN_SUCCESS,
  payload: user
});

export const signInFailure = error =&gt; ({
  type: UserActionTypes.SIGN_IN_FAILURE,
  payload: error
});

export const emailSignInStart = emailAndPassword =&gt; ({
  type: UserActionTypes.EMAIL_SIGN_IN_START,
  payload: emailAndPassword
});

export const checkUserSession = () =&gt; ({
  type: UserActionTypes.CHECK_USER_SESSION
});

export const signOutStart = () =&gt; ({
  type: UserActionTypes.SIGN_OUT_START
});

export const signOutSuccess = () =&gt; ({
  type: UserActionTypes.SIGN_OUT_SUCCESS
});

export const signOutFailure = error =&gt; ({
  type: UserActionTypes.SIGN_OUT_FAILURE,
  payload: error
});

export const signUpStart = userCredentials =&gt; ({
  type: UserActionTypes.SIGN_UP_START,
  payload: userCredentials
});

export const signUpSuccess = ({ user, additionalData }) =&gt; ({
  type: UserActionTypes.SIGN_UP_SUCCESS,
  payload: { user, additionalData }
});

export const signUpFailure = error =&gt; ({
  type: UserActionTypes.SIGN_UP_FAILURE,
  payload: error
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- user.reducer
============================ -->
          <section id="idocs_redux_user_reducer">
            <h2>user.reducer.js</h2>
            <p>Reducer to funkcja, które przyjmuje bieżący state i action jako argumenty i zwracają wynik nowego
              state</p>
            <pre><code class="language-javascript">import UserActionTypes from './user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

const INITIAL_STATE = {  // startowy state
  currentUser: null,
  error: null
};

const userReducer = (state = INITIAL_STATE, action) =&gt; {  // reducer do operacji na użytkownikach
  switch (action.type) {
    case UserActionTypes.SIGN_IN_SUCCESS:
      return {
        ...state,
        currentUser: action.payload,
        error: null
      };
    case UserActionTypes.SIGN_OUT_SUCCESS:
      return {
        ...state,
        currentUser: null,
        error: null
      };
    case UserActionTypes.SIGN_IN_FAILURE:
    case UserActionTypes.SIGN_OUT_FAILURE:
    case UserActionTypes.SIGN_UP_FAILURE:
      return {
        ...state,
        error: action.payload
      };
    default:
      return state;
  }
};

export default userReducer;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />

          <!-- user.reducer.test
============================ -->
          <section id="idocs_redux_user_reducer_test">
            <h2>user.reducer.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import UserActionTypes from './user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state
import userReducer from './user.reducer';

const initialState = {  // startowy state
  currentUser: null,
  error: null
};

describe('userReducer', () =&gt; {
  it('should return initial state', () =&gt; {  // sprawdź czy store zawiera startowe state, wysłany przez reducer
    expect(userReducer(undefined, {})).toEqual(initialState);
  });

  it('should set currentUser to payload on signInSuccess action', () =&gt; {  // po wywołaniu akcji signInSucces, ustaw currentUser jako wartość payload tej akcji
    const mockUser = { id: 1, displayName: 'Yihua' };

    expect(
      userReducer(initialState, {
        type: UserActionTypes.SIGN_IN_SUCCESS,
        payload: mockUser
      }).currentUser
    ).toEqual(mockUser);
  });

  it('should set currentUser to null on signOutSuccess action', () =&gt; {  // po wywołaniu akcji signOutSucces, ustaw currentUser jako wartość null
    expect(
      userReducer(initialState, {
        type: UserActionTypes.SIGN_OUT_SUCCESS
      }).currentUser
    ).toBe(null);
  });

  it('should set errorMessage to payload on signInFailure, signUpFailure, signOutFailure action', () =&gt; {  // po wywołaniu akcji signInFailure lub signUpFailure lub signOutFailure ustaw errorMessage jako wartość payload tej akcji
    const mockError = {
      message: 'errored',
      code: 404
    };

    expect(
      userReducer(initialState, {
        type: UserActionTypes.SIGN_IN_FAILURE,
        payload: mockError
      }).error
    ).toBe(mockError);

    expect(
      userReducer(initialState, {
        type: UserActionTypes.SIGN_UP_FAILURE,
        payload: mockError
      }).error
    ).toBe(mockError);

    expect(
      userReducer(initialState, {
        type: UserActionTypes.SIGN_OUT_FAILURE,
        payload: mockError
      }).error
    ).toBe(mockError);
  });
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- user.sagas
============================ -->
          <section id="idocs_redux_user_sagas">
            <h2>user.sagas.js</h2>
            <p>Sagi pozwalają na wstawienie dodatkowego kodu pomiędzy dispatchem akcji, a dotarciem tej akcji do
              store.</p>
            <pre><code class="language-javascript">import { takeLatest, put, all, call } from 'redux-saga/effects';  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu, all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie

import UserActionTypes from './user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

import {
  signInSuccess,
  signInFailure,
  signOutSuccess,
  signOutFailure,
  signUpSuccess,
  signUpFailure
} from './user.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

export function* getSnapshotFromUserAuth(userAuth, additionalData) {  // sprawdź dane użytkownika
  try {
    const userRef = yield call(  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
      createUserProfileDocument,
      userAuth,
      additionalData
    );
    const userSnapshot = yield userRef.get();  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    yield put(signInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  } catch (error) {
    yield put(signInFailure(error));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  }
}

export function* signInWithEmail({ payload: { email, password } }) {  // zaloguj się za pomocą podane maila
  try {
    const { user } = yield auth.signInWithEmailAndPassword(email, password);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    yield getSnapshotFromUserAuth(user);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
  } catch (error) {
    yield put(signInFailure(error));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  }
}

export function* isUserAuthenticated() {  // sprawdź czy user jest autoryzowany (prawidłowy email i hasło)
  try {
    const userAuth = yield getCurrentUser();  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    if (!userAuth) return;
    yield getSnapshotFromUserAuth(userAuth);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
  } catch (error) {
    yield put(signInFailure(error));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  }
}

export function* signOut() {  // wyloguj użytkownika
  try {
    yield auth.signOut();  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    yield put(signOutSuccess());  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  } catch (error) {
    yield put(signOutFailure(error));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  }
}

export function* signUp({ payload: { email, password, displayName } }) {  // zarejestruj użytkownika
  try {
    const { user } = yield auth.createUserWithEmailAndPassword(email, password);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
    yield put(signUpSuccess({ user, additionalData: { displayName } }));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  } catch (error) {
    yield put(signUpFailure(error));  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  }
}

export function* signInAfterSignUp({ payload: { user, additionalData } }) {  // po udanej rejestracji zaloguj użytkownika
  yield getSnapshotFromUserAuth(user, additionalData);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise
}

export function* onEmailSignInStart() {  // start logowania za pomocą email
  yield takeLatest(UserActionTypes.EMAIL_SIGN_IN_START, signInWithEmail);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
}

export function* onCheckUserSession() {  // sprawdź sesję użytkownika (czy jest zalogowany)
  yield takeLatest(UserActionTypes.CHECK_USER_SESSION, isUserAuthenticated);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
}

export function* onSignOutStart() {  // wyloguj użytkownika
  yield takeLatest(UserActionTypes.SIGN_OUT_START, signOut);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
}

export function* onSignUpStart() {  // zarejestruj użytkownika
  yield takeLatest(UserActionTypes.SIGN_UP_START, signUp);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
}

export function* onSignUpSuccess() {  // udana rejestracja
  yield takeLatest(UserActionTypes.SIGN_UP_SUCCESS, signInAfterSignUp);  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
}

export function* userSagas() {  // sagi dotyczące użytkownika
  yield all([  // yield jest rodzajem instrukcji, która ma być zinterpretowana przez middleware. Gdy promise zostanie przekazana middleware, middleware "zawiesi" sagę do czasu zakończenia promise, all tworzy opis efektu, który instruuje middleware, aby równolegle uruchamiało wiele efektów i czekało na ich ukończenie
    call(onEmailSignInStart),  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
    call(isUserAuthenticated),  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
    call(onSignOutStart),  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
    call(onSignUpStart),  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
    call(onSignUpSuccess)  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
  ]);
}</code></pre>
          </section>
          <hr class="divider" />

          <!-- user.sagas.test
============================ -->
          <section id="idocs_redux_user_sagas_test">
            <h2>user.sagas.test.js</h2>
            <p>
              <strong>Pliki {component}.test.jsx zawierają testy napisane w frameworku Jest.</strong>
              Testy mają na celu sprawdzenie czy strona działa bez błędow.
            </p>
            <pre><code class="language-javascript">import { takeLatest, put, call } from 'redux-saga/effects';  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany, call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję, put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu

import UserActionTypes from './user.types';  // import typów akcji, czyli rodzaju akcji, którą chcemy wysłać do state

import {
  signInSuccess,
  signInFailure,
  signOutSuccess,
  signOutFailure,
  signUpSuccess,
  signUpFailure
} from './user.actions';  // action to zwykły obiekt JavaScript, które ma pole typu. Akcja opisuje coś, co wydarzyło się w aplikacji.

import {
  getSnapshotFromUserAuth,
  signInWithEmail,
  isUserAuthenticated,
  signOut,
  signUp,
  signInAfterSignUp,
  onEmailSignInStart,
  onCheckUserSession,
  onSignOutStart,
  onSignUpStart,
  onSignUpSuccess
} from './user.sagas';  // saga pozwala na stworzenie "skutków ubocznych" w trakcie dispatchowania akcji

describe('on signup success saga', () =&gt; {
  it('should trigger on SIGN_UP_SUCCESS', () =&gt; {  // udana rejestracja powinna wywołać akcję SIGN_UP_SUCCESS
    const generator = onSignUpSuccess();
    expect(generator.next().value).toEqual(
      takeLatest(UserActionTypes.SIGN_UP_SUCCESS, signInAfterSignUp)
    );
  });
});

describe('on signup start saga', () =&gt; {
  it('should trigger on SIGN_UP_START', () =&gt; {  // rejestracja powinna wywołać akcję SIGN_UP_START
    const generator = onSignUpStart();
    expect(generator.next().value).toEqual(
      takeLatest(UserActionTypes.SIGN_UP_START, signUp)  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
    );
  });
});

describe('on signout start saga', () =&gt; {
  it('should trigger on SIGN_UP_START', () =&gt; {  // logowanie powinno wywołać akcję SIGN_UP_START
    const generator = onSignOutStart();
    expect(generator.next().value).toEqual(
      takeLatest(UserActionTypes.SIGN_OUT_START, signOut)  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
    );
  });
});

describe('on check user session saga', () =&gt; {
  it('should trigger on CHECK_USER_SESSION', () =&gt; {  // sprawdzenie czy użytkownik jest zalogowany za pomocą akcji CHECK_USER_SESSION
    const generator = onCheckUserSession();
    expect(generator.next().value).toEqual(
      takeLatest(UserActionTypes.CHECK_USER_SESSION, isUserAuthenticated)  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
    );
  });
});

describe('on email sign in start saga', () =&gt; {
  it('should trigger on EMAIL_SIGN_IN_START', () =&gt; {  // rejestracja użytkownika za pomocą akcji EMAIL_SIGN_IN_START
    const generator = onEmailSignInStart();
    expect(generator.next().value).toEqual(
      takeLatest(UserActionTypes.EMAIL_SIGN_IN_START, signInWithEmail)  // take czeka na wywołanie action i zwraca payload action, reszta kodu się nie wykona dopóki take nie zostanie wykonany
    );
  });
});

describe('on sign in after sign up saga', () =&gt; {
  it('should fire getSnapshotFromUserAuth', () =&gt; {  // sprawdzenie czy użytkownik istnieje
    const mockUser = {};
    const mockAdditionalData = {};
    const mockAction = {
      payload: {
        user: mockUser,
        additionalData: mockAdditionalData
      }
    };

    const generator = signInAfterSignUp(mockAction);
    expect(generator.next().value).toEqual(
      getSnapshotFromUserAuth(mockUser, mockAdditionalData)
    );
  });
});

describe('on sign up saga', () =&gt; {  // saga do rejestracji użytkownika -> sprawdzenie krok po kroku rejestracji
  const mockEmail = 'cindy@gmail.com';  // dane użytkownika z formularza
  const mockPassword = 'test123';
  const mockDisplayName = 'cindy';

  const mockAction = {  // akcja i jej payload
    payload: {
      email: mockEmail,
      password: mockPassword,
      displayName: mockDisplayName
    }
  };

  const generator = signUp(mockAction);  // funkcja do rejestracji

  it('should call auth.createUserWithEmailAndPassword', () =&gt; {  // symulacja rejestrowania się emailem i hasłem
    const createUserWithEmailAndPassword = jest.spyOn(
      auth,
      'createUserWithEmailAndPassword'
    );
    generator.next();
    expect(createUserWithEmailAndPassword).toHaveBeenCalled();
  });
});

describe('on sign out saga', () =&gt; {  // saga do wylogowania użytkownika -> sprawdzenie krok po kroku wylogowania
  const generator = signOut();  // funkcja do wylogowania się

  it('should call auth.signOut', () =&gt; {  // symulacja wylogowania się
    const expectSignOut = jest.spyOn(auth, 'signOut');
    generator.next();
    expect(expectSignOut).toHaveBeenCalled();
  });

  it('should call signOutSuccess', () =&gt; {  // symulacja wylogowania się bez błędów
    expect(generator.next().value).toEqual(put(signOutSuccess()));  // put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
  });

  it('should call signOutFailure on error', () =&gt; {  // symulacja wystąpienie błędu
    const newGenerator = signOut();
    newGenerator.next();
    expect(newGenerator.throw('error').value).toEqual(
      put(signOutFailure('error'))  // put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
    );
  });
});

describe('is user authenticated saga', () =&gt; {  // sprawdzenie czy użytkownik jest autentyfikowany
  const generator = isUserAuthenticated();

  it('should call getCurrentUser', () =&gt; {  // sprawdź użytkownika
    expect(generator.next().value).toEqual(getCurrentUser());
  });

  it('should call getSnapshotFromUserAuth if userAuth exists', () =&gt; {  /// porównaj dane
    const mockUserAuth = { uid: '123da' };
    expect(generator.next(mockUserAuth).value).toEqual(
      getSnapshotFromUserAuth(mockUserAuth)
    );
  });

  it('should call signInFailure on error', () =&gt; {  // error logowania się
    const newGenerator = isUserAuthenticated();
    newGenerator.next();
    expect(newGenerator.throw('error').value).toEqual(
      put(signInFailure('error'))  // put tworzy opis efektu, który instruuje middleware, aby umieścić akcję w podanym miejscu
    );
  });
});

describe('get snapshot from userAuth', () =&gt; {  // snapshot
  const mockUserAuth = {};
  const mockAdditionalData = {};
  const generator = getSnapshotFromUserAuth(mockUserAuth, mockAdditionalData);

  expect(generator.next().value).toEqual(
    call(createUserProfileDocument, mockUserAuth, mockAdditionalData)  // call tworzy opis efektu, który instruuje middleware, aby wywołało podaną funkcję
  );
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- user.selectors
============================ -->
          <section id="idocs_redux_user_selectors">
            <h2>user.selectors.js</h2>
            <p>Selectors to gettery dla store w Redux.</p>
            <pre><code class="language-javascript">import { createSelector } from 'reselect';  // createSelector może akceptować wiele selectorów wejściowych, które mogą być dostarczone jako oddzielne argumenty lub jako tablica. Wyniki ze wszystkich selectorów danych wejściowych są dostarczane jako osobne argumenty do selectora wyjściowego
// poniższe zmienne zwracają zawartość store Reduxa, konkretnych jego części
const selectUser = state =&gt; state.user;

export const selectCurrentUser = createSelector(
  [selectUser],
  user =&gt; user.currentUser
);</code></pre>
          </section>
          <hr class="divider" />

          <!-- user-types
============================ -->
          <section id="idocs_redux_user_types">
            <h2>user.types.js</h2>
            <p>UserTypes zawiera typy akcji, czyli rodzaju akcji, którą chcemy wysłać do state</p>
            <pre><code class="language-javascript">const UserActionTypes = {
  SET_CURRENT_USER: 'SET_CURRENT_USER',
  EMAIL_SIGN_IN_START: 'EMAIL_SIGN_IN_START',
  SIGN_IN_SUCCESS: 'SIGN_IN_SUCCESS',
  SIGN_IN_FAILURE: 'SIGN_IN_FAILURE',
  CHECK_USER_SESSION: 'CHECK_USER_SESSION',
  SIGN_OUT_START: 'SIGN_OUT_START',
  SIGN_OUT_SUCCESS: 'SIGN_OUT_SUCCESS',
  SIGN_OUT_FAILURE: 'SIGN_OUT_FAILURE',
  SIGN_UP_START: 'SIGN_UP_START',
  SIGN_UP_SUCCESS: 'SIGN_UP_SUCCESS',
  SIGN_UP_FAILURE: 'SIGN_UP_FAILURE'
};

export default UserActionTypes;  // wyeksportowanie komponentu, aby inne mogły go importować</code></pre>
          </section>
          <hr class="divider" />


          <!-- Dodatkowe wyjaśnienia
              ============================ -->
          <section id="idocs_dodatkowe_wyjasnienia">
            <h2>Dodatkowe wyjaśnienia</h2>
            <p class="text-4">Szybkie wytłumaczenie wybranych tematów.</p>
          </section>
          <hr class="divider" />

          <!-- Komponent
              ============================ -->
          <section id="idocs_komponent">
            <h2>Komponent w React</h2>
            <p>
              Komponent to jeden z podstawowych elementów konstrukcyjnych
              Reacta. <br />
              <br />Innymi słowy, możemy powiedzieć, że każda aplikacja, którą
              stworzysz w React, będzie składała się z części zwanych
              komponentami. <br />
              <br />Możesz zobaczyć interfejs użytkownika podzielony na wiele
              pojedynczych elementów zwanych komponentami i pracować nad nimi
              niezależnie, a następnie scalić je wszystkie w komponencie
              nadrzędnym, który będzie twoim ostatecznym interfejsem
              użytkownika.
            </p>
            <h5>Przykład:</h5>
            <pre><code class="language-javascript">import React from 'react';
import { FooterContainer, AuthorContainer } from './footer.styles';

export const Footer = () =&gt; (
  &lt;FooterContainer&gt;
    &lt;AuthorContainer&gt;&amp;copy; Ingrid Pruszyńska&lt;/AuthorContainer&gt;
  &lt;/FooterContainer&gt;
);

export default Footer;</code></pre>
          </section>
          <hr class="divider" />

          <!-- Rozkład komponentów
              ============================ -->
          <section id="idocs_rozklad_komponentow">
            <h2>Rozkład komponentów</h2>
            <p>
              Jak sprawdzić z jakich komponentów składa się strona? <br />
              <br />
              W każdej popularnej przeglądarce powinno być dostępne
              rozszerzenie/wtyczka o nazwie React Developer Tools.
              <br />Po otwarciu strony i otworzeniu inspektora będziecie mieć
              nową zakładkę Components, na której widać drzewko komponentów.
            </p>
            <h5>Przykład:</h5>
            <p>
              <a class="popup-img" href="assets/images/react-developer-tools.png"><img class="img-fluid border"
                  src="assets/images/react-developer-tools.png" alt="" /></a>
            </p>
          </section>
          <hr class="divider" />

          <!-- Props
              ============================ -->
          <section id="idocs_props">
            <h2>Czym są props?</h2>
            <p>
              „Props” to specjalne słowo kluczowe w React, które oznacza
              właściwości i służy do przekazywania danych z jednego komponentu
              do drugiego.<br />
              Ale ważną częścią jest to, że dane z propami są przekazywane w
              jednokierunkowym przepływie. (w jedną stronę od rodzica do
              dziecka).<br />
              Ponadto dane props są tylko do odczytu, co oznacza, że ​​dane
              pochodzące od rodzica nie powinny być zmieniane przez komponenty
              potomne.
            </p>
            <h5>Przykład:</h5>
            <p>Kod poniżej renderuje napis „Cześć Sara”</p>
            <pre><code class="language-javascript">function Welcome(props) {
  return &lt;h1&gt;Cześć, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name='Sara' /&gt;;</code></pre>
          </section>
          <hr class="divider" />

          <!-- Styled Components
              ============================ -->
          <section id="idocs_styled_components">
            <h2>Biblioteka Styled Components</h2>
            <p>
              Styled-components to biblioteka stworzona dla programistów React
              i React Native. <br />
              Pozwala na używanie w aplikacjach stylów na poziomie
              komponentów. Styled-components wykorzystują mieszankę JavaScript
              i CSS przy użyciu techniki zwanej CSS-in-JS.<br />
              Styled-components są oparte na otagowanych literałach szablonów,
              co oznacza, że ​​rzeczywisty kod CSS jest zapisywany między
              backtickami podczas stylizowania komponentów. Daje to
              programistom elastyczność w ponownym wykorzystywaniu kodu CSS z
              jednego projektu do drugiego.
            </p>
            <h5>Przykład:</h5>
            <p>
              Kod poniżej stworzy komponent Title, który wyrenderuje tag
              &lt;h1&gt; z określonymi stylami.
            </p>
            <pre><code class="language-javascript">import styled from 'styled-components';  // import biblioteki styled components

export const Title = styled.h1`  
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
`;</code></pre>
          </section>
          <hr class="divider" />

          <!-- Jest
              ============================ -->
          <section id="idocs_jest">
            <h2>Framework Jest</h2>
            <p>
              Framework do testowania JavaScriptu, który koncentruje się na
              prostocie. Działa z projektami wykorzystującymi: Babel,
              TypeScript, Node, React, Angular, Vue itd.<br />
              Testowanie jednostkowe to testowanie oprogramowania, podczas
              którego testowane są poszczególne komponenty oprogramowania.
              <br />
              Celem testów jednostkowych jest sprawdzenie, czy każda jednostka
              oprogramowania działa zgodnie z założeniami.<br /><br />

              Mockowanie to technika, w której części kodu są zastępowane
              fikcyjnymi implementacjami, które emulują prawdziwy kod. <br />
              Mocking pomaga osiągnąć izolację testów. Mocking jest używany
              głównie w testach jednostkowych.<br /><br />

              W naszych testach sprawdzamy, czy wartości spełniają określone
              warunki. <br />
              Funkcja expect daje nam szereg dopasowań, które pozwalają nam
              sprawdzać różne rzeczy, takie jak toBe, toBeFalsy lub toEqual.
            </p>
            <h5>Przykład:</h5>
            <p>Test poniżej sprawdza czy suma 1 + 2 jest równa 3.</p>
            <pre><code class="language-javascript">const sum = require('./sum');

test('adds 1 + 2 to equal 3', () =&gt; {
  expect(sum(1, 2)).toBe(3);
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- Mock
              ============================ -->
          <section id="idocs_mock">
            <h2>Mock</h2>
            <p>
              Mockowanie to udawanie, symulowanie odpowiedzi jakiegoś serwisu,
              aby była zgodna z naszymi oczekiwaniami. <br />
              Czyli udawanie, że system, który działa, nie działa albo
              odwrotnie (np. testowanie obsługi błędów). <br />
              Można też symulować konkretne odpowiedzi, aby sprawdzić, czy
              zwracane wartości są przez naszą aplikację poprawnie obliczane.
              <br />
              <br />
              W testach jednostkowych, gdzie mamy większe pole do popisu,
              mockować można obiekty klas, z którymi wchodzimy w interakcję.
              <br />
            </p>
            <h5>Przykład:</h5>
            <p>
              Test poniżej sprawdza czy funkcja mock została poprawnie
              wywołana 3 razy.
            </p>
            <pre><code class="language-javascript">it('returns undefined and has been called correct number of times', () =&gt; {
  const mock = jest.fn();

  const result = mock();

  expect(result).toBeUndefined();
  expect(mock).toHaveBeenCalledTimes(1);
  expect(mock).toHaveBeenCalledWith();
});</code></pre>
          </section>
          <hr class="divider" />

          <!-- Snapshot testing
              ============================ -->
          <section id="idocs_snapshot_testing">
            <h2>Snapshot Testing</h2>
            <p>
              Snapshot testy są bardzo przydatnym narzędziem, gdy chcesz mieć
              pewność, że Twój interfejs użytkownika nie zmieni się
              nieoczekiwanie. <br />
              Typowy snapshot test renderuje składniki interfejsu użytkownika,
              wykonuje snapshot, a następnie porównuje go z referencyjnym
              plikiem snapshota przechowywanym wraz z testem. <br />
              Test zakończy się niepowodzeniem, jeśli dwie migawki nie będą
              pasować: zmiana jest nieoczekiwana lub migawka referencyjna musi
              zostać zaktualizowana do nowej wersji składnika interfejsu
              użytkownika.
            </p>
            <h5>Przykład:</h5>
            <p>
              Test poniżej sprawdza czy funkcja zrenderuje się tak samo jak
              zapisany snapshot.
            </p>
            <pre><code class="language-javascript">import React from 'react';
import renderer from 'react-test-renderer';

import Items from './Items';

it('renders correctly when there are no items', () =&gt; {
  const tree = renderer.create(&lt;Items /&gt;).toJSON();
  expect(tree).toMatchSnapshot();
});</code></pre>
          </section>
          <hr class="divider" />
          <!-- Baza danych
              ============================ -->
              <section id="idocs_baza_danych">
                <h2>Baza danych</h2>
                <p class="text-4">Informacje na temat bazy danych</p>
              </section>
              <hr class="divider" />
    
              <!-- Ogólne informacje
                  ============================ -->
              <section id="idocs_ogolne_informacje">
                <h2>Ogólne informacje</h2>
                <p>
                  Na potrzeby projektu potrzebujemy przechowywać produkty występujące w naszym sklepie internetowym oraz konta użytkowników.
                  <br>
                  Produkty są przechowywane w tabeli 'products'. W celu zmniejszenia redundancji utworzona została również tabela 
                  'categories' przechowująca kategorie produktów.
                  <br>
                  Użytkownicy znajdują się w tabeli 'users', a role użytkowników w osobnej tabeli 'roles'.
                </p>
                
              </section>
              <hr class="divider" />
              <!-- Schemat
                  ============================ -->
                  <section id="idocs_schemat">
                    <h2>Schemat</h2>
                      <p>
                        <a class="popup-img" href="assets/images/diagram_bazy_danych.png"><img 
                            src="assets/images/diagram_bazy_danych.png" alt="" /></a>
                      </p>
                      <p>
                        Tabele 'products' i 'categories' połączone są relacją wiele do jednego, tak jak tabele 'users' i 'roles'.
                        <br>
                        W polach image przechowywane są linki do zdjęć.
                    </p>
                    
                  </section>
        </div>
      </div>
    </div>
    <!-- Content end -->

    <!-- Footer
  ============================ -->
    <footer id="footer" class="section bg-dark footer-text-light">
      <div class="container">
        <ul class="
              social-icons social-icons-lg social-icons-muted
              justify-content-center
              mb-3
            ">
          <li>
            <a data-toggle="tooltip" href="https://twitter.com/harnishdesign/" target="_blank" title=""
              data-original-title="Twitter"><i class="fab fa-twitter"></i></a>
          </li>
          <li>
            <a data-toggle="tooltip" href="http://www.facebook.com/harnishdesign/" target="_blank" title=""
              data-original-title="Facebook"><i class="fab fa-facebook-f"></i></a>
          </li>
          <li>
            <a data-toggle="tooltip" href="http://www.dribbble.com/harnishdesign/" target="_blank" title=""
              data-original-title="Dribbble"><i class="fab fa-dribbble"></i></a>
          </li>
          <li>
            <a data-toggle="tooltip" href="http://www.github.com/" target="_blank" title=""
              data-original-title="GitHub"><i class="fab fa-github"></i></a>
          </li>
        </ul>
        <p class="text-center">
          Copyright &copy; 2020
          <a href="http://www.harnishdesign.net/idocs-one-page-documentation-html-template/">iDocs</a>. All Rights
          Reserved.
        </p>
        <p class="text-2 text-center mb-0">
          Design &amp; Develop by
          <a class="btn-link" target="_blank" href="http://www.harnishdesign.net/">HarnishDesign</a>.
        </p>
      </div>
    </footer>
    <!-- Footer end -->
  </div>
  <!-- Document Wrapper end -->

  <!-- Back To Top -->
  <a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)"><i
      class="fa fa-chevron-up"></i></a>

  <!-- JavaScript
============================ -->
  <script src="assets/vendor/jquery/jquery.min.js"></script>
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- Highlight JS -->
  <script src="assets/vendor/highlight.js/highlight.min.js"></script>
  <!-- Easing -->
  <script src="assets/vendor/jquery.easing/jquery.easing.min.js"></script>
  <!-- Magnific Popup -->
  <script src="assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script>
  <!-- Custom Script -->
  <script src="assets/js/theme.js"></script>
</body>

</html>